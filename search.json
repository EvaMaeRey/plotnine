[
  {
    "objectID": "tutorials/index.html",
    "href": "tutorials/index.html",
    "title": "Tutorials",
    "section": "",
    "text": "Tutorials\n\na-pyqt5-application\naltering-colors\nautomatic-grouping-insufficient\nmanipulating-date-breaks-and-date-labels\norder-plot-series\nshow-counts-and-percentages-for-bar-plots\nshow-counts-on-a-stacked-bar-plot\nusing-letter-as-shapes\nusing-notebook-widgets"
  },
  {
    "objectID": "gallery/index.html",
    "href": "gallery/index.html",
    "title": "Gallery",
    "section": "",
    "text": "Spiral Animation\n\n\n\n\n\n\n\n\n\n\n\nTwo Variable Bar Plot\n\n\n\n\n\n\n\n\n\n\n\nShading a Region under a Density Curve\n\n\n\n\n\n\n\n\n\n\n\nThe Political Territories of Westeros\n\n\n\n\n\n\n\n\n\n\n\nRanges of Similar Variables\n\n\n\n\n\n\n\n\n\n\n\nChange in Rank\n\n\n\n\n\n\n\n\n\n\n\nSmoothed conditional means\n\n\n\n\n\n\n\n\n\n\n\nPeriodic Table of Elements\n\n\n\n\n\n\n\n\n\n\n\nAnnotated Heatmap\n\n\n\n\n\n\n\n\n\n\n\nViolins, Boxes, Points and Lines\n\n\n\n\n\n\n\n\n\n\n\nGuitar Neck"
  },
  {
    "objectID": "reference/ylim.html",
    "href": "reference/ylim.html",
    "title": "ylim",
    "section": "",
    "text": "scales.ylim()\n\n\nSet y-axis limits\n\n\n\n\nlimits: array_like\n\nMin and max limits. Must be of size 2. You can also pass two values e.g ylim(40, 100)\n\n\n\n\n\nIf the 2nd value of limits is less than the first, a reversed scale will be created."
  },
  {
    "objectID": "reference/ylim.html#parameters",
    "href": "reference/ylim.html#parameters",
    "title": "ylim",
    "section": "",
    "text": "limits: array_like\n\nMin and max limits. Must be of size 2. You can also pass two values e.g ylim(40, 100)"
  },
  {
    "objectID": "reference/ylim.html#notes",
    "href": "reference/ylim.html#notes",
    "title": "ylim",
    "section": "",
    "text": "If the 2nd value of limits is less than the first, a reversed scale will be created."
  },
  {
    "objectID": "reference/xlim.html",
    "href": "reference/xlim.html",
    "title": "xlim",
    "section": "",
    "text": "scales.xlim()\n\n\nSet x-axis limits\n\n\n\n\nlimits: array_like\n\nMin and max limits. Must be of size 2. You can also pass two values e.g xlim(40, 100)"
  },
  {
    "objectID": "reference/xlim.html#parameters",
    "href": "reference/xlim.html#parameters",
    "title": "xlim",
    "section": "",
    "text": "limits: array_like\n\nMin and max limits. Must be of size 2. You can also pass two values e.g xlim(40, 100)"
  },
  {
    "objectID": "reference/watermark.html",
    "href": "reference/watermark.html",
    "title": "watermark",
    "section": "",
    "text": "watermark(self, filename, xo=0, yo=0, alpha=None, **kwargs)\n\n\nAdd watermark to plot\n\n\n\n\nfilename: str | pathlib.Path\n\nImage file\n\nxo: int = 0\n\nx position offset in pixels.\n\nyo: int = 0\n\ny position offset in pixels.\n\nalpha: float = None\n\nAlpha blending value.\n\nkwargs: dict = {}\n\nAdditional parameters passed to :meth:matplotlib.figure.figimage.\n\n\n\n\n\nYou can add more than one watermark to a plot.\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ndraw\nDraw watermark\n\n\n\n\n\n\nwatermark.draw(figure)\n\n\nDraw watermark\n\n\n\n\nfigure: Matplotlib.figure.Figure\n\nMatplolib figure on which to draw"
  },
  {
    "objectID": "reference/watermark.html#parameters",
    "href": "reference/watermark.html#parameters",
    "title": "watermark",
    "section": "",
    "text": "filename: str | pathlib.Path\n\nImage file\n\nxo: int = 0\n\nx position offset in pixels.\n\nyo: int = 0\n\ny position offset in pixels.\n\nalpha: float = None\n\nAlpha blending value.\n\nkwargs: dict = {}\n\nAdditional parameters passed to :meth:matplotlib.figure.figimage."
  },
  {
    "objectID": "reference/watermark.html#notes",
    "href": "reference/watermark.html#notes",
    "title": "watermark",
    "section": "",
    "text": "You can add more than one watermark to a plot."
  },
  {
    "objectID": "reference/watermark.html#methods",
    "href": "reference/watermark.html#methods",
    "title": "watermark",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ndraw\nDraw watermark\n\n\n\n\n\n\nwatermark.draw(figure)\n\n\nDraw watermark\n\n\n\n\nfigure: Matplotlib.figure.Figure\n\nMatplolib figure on which to draw"
  },
  {
    "objectID": "reference/title.html",
    "href": "reference/title.html",
    "title": "title",
    "section": "",
    "text": "themes.themeable.title()\n\n\nAll titles on the plot\n\n\n\n\ntheme_element: element_text"
  },
  {
    "objectID": "reference/title.html#parameters",
    "href": "reference/title.html#parameters",
    "title": "title",
    "section": "",
    "text": "theme_element: element_text"
  },
  {
    "objectID": "reference/theme_xkcd.html",
    "href": "reference/theme_xkcd.html",
    "title": "theme_xkcd",
    "section": "",
    "text": "themes.theme_xkcd(self, base_size=12, scale=1, length=100, randomness=2, stroke_size=4, stroke_color='white')\n\n\nxkcd theme\n\n\n\n\nbase_size: int = 12\n\nBase font size. All text sizes are a scaled versions of the base font size.\n\nscale: float = 1\n\nThe amplitude of the wiggle perpendicular to the line (in pixels)\n\nlength: float = 100\n\nThe length of the wiggle along the line (in pixels).\n\nrandomness: float = 2\n\nThe factor by which the length is randomly scaled. Default is 2.\n\nstroke_size: float = 4\n\nSize of the stroke to apply to the lines and text paths.\n\nstroke_color: str | tuple = ‘white’\n\nColor of the strokes. Use \"none\" for no color."
  },
  {
    "objectID": "reference/theme_xkcd.html#parameters",
    "href": "reference/theme_xkcd.html#parameters",
    "title": "theme_xkcd",
    "section": "",
    "text": "base_size: int = 12\n\nBase font size. All text sizes are a scaled versions of the base font size.\n\nscale: float = 1\n\nThe amplitude of the wiggle perpendicular to the line (in pixels)\n\nlength: float = 100\n\nThe length of the wiggle along the line (in pixels).\n\nrandomness: float = 2\n\nThe factor by which the length is randomly scaled. Default is 2.\n\nstroke_size: float = 4\n\nSize of the stroke to apply to the lines and text paths.\n\nstroke_color: str | tuple = ‘white’\n\nColor of the strokes. Use \"none\" for no color."
  },
  {
    "objectID": "reference/theme_update.html",
    "href": "reference/theme_update.html",
    "title": "theme_update",
    "section": "",
    "text": "themes.theme_update(**kwargs)\n\n\nModify elements of the current theme\n\n\n\n\nkwargs: dict = {}\n\nTheme elements"
  },
  {
    "objectID": "reference/theme_update.html#parameters",
    "href": "reference/theme_update.html#parameters",
    "title": "theme_update",
    "section": "",
    "text": "kwargs: dict = {}\n\nTheme elements"
  },
  {
    "objectID": "reference/theme_set.html",
    "href": "reference/theme_set.html",
    "title": "theme_set",
    "section": "",
    "text": "themes.theme_set(new)\n\n\nChange the current(default) theme\n\n\n\n\nnew: theme\n\nNew default theme\n\n\n\n\n\n\nout: theme\n\nPrevious theme"
  },
  {
    "objectID": "reference/theme_set.html#parameters",
    "href": "reference/theme_set.html#parameters",
    "title": "theme_set",
    "section": "",
    "text": "new: theme\n\nNew default theme"
  },
  {
    "objectID": "reference/theme_set.html#returns",
    "href": "reference/theme_set.html#returns",
    "title": "theme_set",
    "section": "",
    "text": "out: theme\n\nPrevious theme"
  },
  {
    "objectID": "reference/theme_minimal.html",
    "href": "reference/theme_minimal.html",
    "title": "theme_minimal",
    "section": "",
    "text": "themes.theme_minimal(self, base_size=11, base_family=None)\n\n\nA minimalistic theme with no background annotations\n\n\n\n\nbase_size: int = 11\n\nBase font size. All text sizes are a scaled versions of the base font size.\n\nbase_family: str = None\n\nBase font family. If None, use plotnine.options.base_family."
  },
  {
    "objectID": "reference/theme_minimal.html#parameters",
    "href": "reference/theme_minimal.html#parameters",
    "title": "theme_minimal",
    "section": "",
    "text": "base_size: int = 11\n\nBase font size. All text sizes are a scaled versions of the base font size.\n\nbase_family: str = None\n\nBase font family. If None, use plotnine.options.base_family."
  },
  {
    "objectID": "reference/theme_linedraw.html",
    "href": "reference/theme_linedraw.html",
    "title": "theme_linedraw",
    "section": "",
    "text": "themes.theme_linedraw(self, base_size=11, base_family=None)\n\n\nA theme with only black lines of various widths on white backgrounds\n\n\n\n\nbase_size: int = 11\n\nBase font size. All text sizes are a scaled versions of the base font size.\n\nbase_family: str = None\n\nBase font family. If None, use plotnine.options.base_family."
  },
  {
    "objectID": "reference/theme_linedraw.html#parameters",
    "href": "reference/theme_linedraw.html#parameters",
    "title": "theme_linedraw",
    "section": "",
    "text": "base_size: int = 11\n\nBase font size. All text sizes are a scaled versions of the base font size.\n\nbase_family: str = None\n\nBase font family. If None, use plotnine.options.base_family."
  },
  {
    "objectID": "reference/theme_grey.html",
    "href": "reference/theme_grey.html",
    "title": "theme_grey",
    "section": "",
    "text": "themes.theme_grey\n\nA gray background with white gridlines.\nThis is the default theme\n\n\n\nbase_size : int Base font size. All text sizes are a scaled versions of the base font size. base_family : str Base font family. If None, use plotnine.options.base_family."
  },
  {
    "objectID": "reference/theme_grey.html#parameters",
    "href": "reference/theme_grey.html#parameters",
    "title": "theme_grey",
    "section": "",
    "text": "base_size : int Base font size. All text sizes are a scaled versions of the base font size. base_family : str Base font family. If None, use plotnine.options.base_family."
  },
  {
    "objectID": "reference/theme_get.html",
    "href": "reference/theme_get.html",
    "title": "theme_get",
    "section": "",
    "text": "theme_get\n\nthemes.theme_get()\n\n\nReturn the default theme\nThe default theme is the one set (using theme_set) by the user. If none has been set, then theme_gray is the default."
  },
  {
    "objectID": "reference/theme_classic.html",
    "href": "reference/theme_classic.html",
    "title": "theme_classic",
    "section": "",
    "text": "themes.theme_classic(self, base_size=11, base_family=None)\n\n\nA classic-looking theme, with x & y axis lines and no gridlines\n\n\n\n\nbase_size: int = 11\n\nBase font size. All text sizes are a scaled versions of the base font size.\n\nbase_family: str = None\n\nBase font family. If None, use plotnine.options.base_family."
  },
  {
    "objectID": "reference/theme_classic.html#parameters",
    "href": "reference/theme_classic.html#parameters",
    "title": "theme_classic",
    "section": "",
    "text": "base_size: int = 11\n\nBase font size. All text sizes are a scaled versions of the base font size.\n\nbase_family: str = None\n\nBase font family. If None, use plotnine.options.base_family."
  },
  {
    "objectID": "reference/theme_538.html",
    "href": "reference/theme_538.html",
    "title": "theme_538",
    "section": "",
    "text": "themes.theme_538(self, base_size=11, base_family='DejaVu Sans')\n\n\nTheme in the likeness of fivethirtyeight.com plots\n\n\n\n\nbase_size: int = 11\n\nBase font size. All text sizes are a scaled versions of the base font size.\n\nbase_family: str = ‘DejaVu Sans’\n\nBase font family."
  },
  {
    "objectID": "reference/theme_538.html#parameters",
    "href": "reference/theme_538.html#parameters",
    "title": "theme_538",
    "section": "",
    "text": "base_size: int = 11\n\nBase font size. All text sizes are a scaled versions of the base font size.\n\nbase_family: str = ‘DejaVu Sans’\n\nBase font family."
  },
  {
    "objectID": "reference/text.html",
    "href": "reference/text.html",
    "title": "text",
    "section": "",
    "text": "themes.themeable.text()\n\n\nAll text elements in the plot\n\n\n\n\ntheme_element: element_text"
  },
  {
    "objectID": "reference/text.html#parameters",
    "href": "reference/text.html#parameters",
    "title": "text",
    "section": "",
    "text": "theme_element: element_text"
  },
  {
    "objectID": "reference/strip_text_x.html",
    "href": "reference/strip_text_x.html",
    "title": "strip_text_x",
    "section": "",
    "text": "themes.themeable.strip_text_x()\n\n\nFacet labels along the horizontal axis\n\n\n\n\ntheme_element: element_text"
  },
  {
    "objectID": "reference/strip_text_x.html#parameters",
    "href": "reference/strip_text_x.html#parameters",
    "title": "strip_text_x",
    "section": "",
    "text": "theme_element: element_text"
  },
  {
    "objectID": "reference/strip_background_y.html",
    "href": "reference/strip_background_y.html",
    "title": "strip_background_y",
    "section": "",
    "text": "themes.themeable.strip_background_y()\n\n\nVertical facet label background\n\n\n\n\ntheme_element: element_rect"
  },
  {
    "objectID": "reference/strip_background_y.html#parameters",
    "href": "reference/strip_background_y.html#parameters",
    "title": "strip_background_y",
    "section": "",
    "text": "theme_element: element_rect"
  },
  {
    "objectID": "reference/strip_background.html",
    "href": "reference/strip_background.html",
    "title": "strip_background",
    "section": "",
    "text": "themes.themeable.strip_background()\n\n\nFacet label background\n\n\n\n\ntheme_element: element_rect"
  },
  {
    "objectID": "reference/strip_background.html#parameters",
    "href": "reference/strip_background.html#parameters",
    "title": "strip_background",
    "section": "",
    "text": "theme_element: element_rect"
  },
  {
    "objectID": "reference/strip_align_x.html",
    "href": "reference/strip_align_x.html",
    "title": "strip_align_x",
    "section": "",
    "text": "themes.themeable.strip_align_x()\n\n\nVertical alignment of the strip & its background w.r.t the panel border\n\n\n\n\ntheme_element: float\n\nValue as a proportion of the strip size. A good value should be the range [-1, 0.5]. A negative value puts the strip inside the axes. A positive value creates a margin between the strip and the axes. 0 puts the strip on top of the panels."
  },
  {
    "objectID": "reference/strip_align_x.html#parameters",
    "href": "reference/strip_align_x.html#parameters",
    "title": "strip_align_x",
    "section": "",
    "text": "theme_element: float\n\nValue as a proportion of the strip size. A good value should be the range [-1, 0.5]. A negative value puts the strip inside the axes. A positive value creates a margin between the strip and the axes. 0 puts the strip on top of the panels."
  },
  {
    "objectID": "reference/stat_ydensity.html",
    "href": "reference/stat_ydensity.html",
    "title": "stat_ydensity",
    "section": "",
    "text": "stats.stat_ydensity()\n\n\nDensity estimate\nUsage\nstat_ydensity(mapping=None, data=None, geom='violin', position='dodge',\n              na_rm=False, n=1024, bw='nrd0', scale='area', kernel='gaussian',\n              trim=True, adjust=1, **kwargs)\nOnly the mapping and data can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the geom.\n\n\n\n\nmapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nweight\n\n\nNone\n\n\n\n\nThe bold aesthetics are required.\nOptions for computed aesthetics\n\"width\"        # Maximum width of density, [0, 1] range.\n\"violinwidth\"  # Shape of the violin\nCalculated aesthetics are accessed using the after_stat function. e.g. after_stat('width').\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom: str | geom = “violin”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “dodge”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\nkernel: str = ‘gaussian’\n\nKernel used for density estimation. One of:\n\"biweight\"\n\"cosine\"\n\"cosine2\"\n\"epanechnikov\"\n\"gaussian\"\n\"triangular\"\n\"triweight\"\n\"uniform\"\n\nadjust: float = 1\n\nAn adjustment factor for the bw. Bandwidth becomes bw * adjust. Adjustment of the bandwidth.\n\ntrim: bool = False\n\nThis parameter only matters if you are displaying multiple densities in one plot. If False, the default, each density is computed on the full range of the data. If True, each density is computed over the range of that group; this typically means the estimated x values will not line-up, and hence you won’t be able to stack density values.\n\nn: int = 1024\n\nNumber of equally spaced points at which the density is to be estimated. For efficient computation, it should be a power of two.\n\nbw: str | float = “nrd0”\n\nThe bandwidth to use, If a float is given, it is the bandwidth. The str choices are:\n\"nrd0\"\n\"normal_reference\"\n\"scott\"\n\"silverman\"\nnrd0 is a port of stats::bw.nrd0 in R; it is eqiuvalent to silverman when there is more than 1 value in a group.\n\nscale: area | count | width = “area”\n\nHow to scale the violins. The options are: If area all violins have the same area, before trimming the tails. If count the areas are scaled proportionally to the number of observations. If width all violins have the same maximum width.\n\n\n\n\n\n\nplotnine.geoms.geom_violin\n\n\n\nstatsmodels.nonparametric.kde.KDEUnivariate\n\n\n\nstatsmodels.nonparametric.kde.KDEUnivariate.fit"
  },
  {
    "objectID": "reference/stat_ydensity.html#parameters",
    "href": "reference/stat_ydensity.html#parameters",
    "title": "stat_ydensity",
    "section": "",
    "text": "mapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nweight\n\n\nNone\n\n\n\n\nThe bold aesthetics are required.\nOptions for computed aesthetics\n\"width\"        # Maximum width of density, [0, 1] range.\n\"violinwidth\"  # Shape of the violin\nCalculated aesthetics are accessed using the after_stat function. e.g. after_stat('width').\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom: str | geom = “violin”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “dodge”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\nkernel: str = ‘gaussian’\n\nKernel used for density estimation. One of:\n\"biweight\"\n\"cosine\"\n\"cosine2\"\n\"epanechnikov\"\n\"gaussian\"\n\"triangular\"\n\"triweight\"\n\"uniform\"\n\nadjust: float = 1\n\nAn adjustment factor for the bw. Bandwidth becomes bw * adjust. Adjustment of the bandwidth.\n\ntrim: bool = False\n\nThis parameter only matters if you are displaying multiple densities in one plot. If False, the default, each density is computed on the full range of the data. If True, each density is computed over the range of that group; this typically means the estimated x values will not line-up, and hence you won’t be able to stack density values.\n\nn: int = 1024\n\nNumber of equally spaced points at which the density is to be estimated. For efficient computation, it should be a power of two.\n\nbw: str | float = “nrd0”\n\nThe bandwidth to use, If a float is given, it is the bandwidth. The str choices are:\n\"nrd0\"\n\"normal_reference\"\n\"scott\"\n\"silverman\"\nnrd0 is a port of stats::bw.nrd0 in R; it is eqiuvalent to silverman when there is more than 1 value in a group.\n\nscale: area | count | width = “area”\n\nHow to scale the violins. The options are: If area all violins have the same area, before trimming the tails. If count the areas are scaled proportionally to the number of observations. If width all violins have the same maximum width."
  },
  {
    "objectID": "reference/stat_ydensity.html#see-also",
    "href": "reference/stat_ydensity.html#see-also",
    "title": "stat_ydensity",
    "section": "",
    "text": "plotnine.geoms.geom_violin\n\n\n\nstatsmodels.nonparametric.kde.KDEUnivariate\n\n\n\nstatsmodels.nonparametric.kde.KDEUnivariate.fit"
  },
  {
    "objectID": "reference/stat_summary_bin.html",
    "href": "reference/stat_summary_bin.html",
    "title": "stat_summary_bin",
    "section": "",
    "text": "stats.stat_summary_bin()\n\n\nSummarise y values at x intervals\nUsage\nstat_summary_bin(mapping=None, data=None, geom='pointrange',\n                 position='identity', na_rm=False, fun_args=None, breaks=None,\n                 fun_y=None, fun_ymin=None, bins=30, binwidth=None,\n                 boundary=None, fun_ymax=None, fun_data=None,\n                 random_state=None, **kwargs)\nOnly the mapping and data can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the geom.\n\n\n\n\nmapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nThe bold aesthetics are required.\nOptions for computed aesthetics\n\"bin\"    # bin identifier\n\"width\"  # bin width\n\"ymin\"   # ymin computed by the summary function\n\"ymax\"   # ymax computed by the summary function\nCalculated aesthetics are accessed using the after_stat function. e.g. after_stat('ymin').\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom: str | geom = “pointrange”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\nbinwidth: float | tuple = None\n\nThe width of the bins. The default is to use bins bins that cover the range of the data. You should always override this value, exploring multiple widths to find the best to illustrate the stories in your data.\n\nbins: int | tuple = 30\n\nNumber of bins. Overridden by binwidth.\n\nbreaks: array - likes = None\n\nBin boundaries. This supercedes the binwidth, bins and boundary arguments.\n\nboundary: float | tuple = None\n\nA boundary between two bins. As with center, things are shifted when boundary is outside the range of the data. For example, to center on integers, use width=1 and boundary=0.5, even if 1 is outside the range of the data. At most one of center and boundary may be specified.\n\nfun_data: str | callable = “mean_se”\n\nIf a string, should be one of mean_cl_boot, mean_cl_normal, mean_sdl, median_hilow, mean_se. If a function, it should that takes an array and return a dataframe with three rows indexed as y, ymin and ymax.\n\nfun_y: callable = None\n\nA function that takes an array-like and returns a single value\n\nfun_ymax: callable = None\n\nA function that takes an array-like and returns a single value\n\nfun_args: dict = None\n\nArguments to any of the functions. Provided the names of the arguments of the different functions are in not conflict, the arguments will be assigned to the right functions. If there is a conflict, create a wrapper function that resolves the ambiguity in the argument names.\n\nrandom_state: int | ~numpy.random.RandomState = None\n\nSeed or Random number generator to use. If None, then numpy global generator :class:numpy.random is used.\n\n\n\n\n\nThe binwidth, bins, breaks and bounary arguments can be a tuples with two values ((xaxis-value, yaxis-value)) of the required type.\n\n\n\n\nplotnine.geoms.geom_pointrange"
  },
  {
    "objectID": "reference/stat_summary_bin.html#parameters",
    "href": "reference/stat_summary_bin.html#parameters",
    "title": "stat_summary_bin",
    "section": "",
    "text": "mapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nThe bold aesthetics are required.\nOptions for computed aesthetics\n\"bin\"    # bin identifier\n\"width\"  # bin width\n\"ymin\"   # ymin computed by the summary function\n\"ymax\"   # ymax computed by the summary function\nCalculated aesthetics are accessed using the after_stat function. e.g. after_stat('ymin').\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom: str | geom = “pointrange”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\nbinwidth: float | tuple = None\n\nThe width of the bins. The default is to use bins bins that cover the range of the data. You should always override this value, exploring multiple widths to find the best to illustrate the stories in your data.\n\nbins: int | tuple = 30\n\nNumber of bins. Overridden by binwidth.\n\nbreaks: array - likes = None\n\nBin boundaries. This supercedes the binwidth, bins and boundary arguments.\n\nboundary: float | tuple = None\n\nA boundary between two bins. As with center, things are shifted when boundary is outside the range of the data. For example, to center on integers, use width=1 and boundary=0.5, even if 1 is outside the range of the data. At most one of center and boundary may be specified.\n\nfun_data: str | callable = “mean_se”\n\nIf a string, should be one of mean_cl_boot, mean_cl_normal, mean_sdl, median_hilow, mean_se. If a function, it should that takes an array and return a dataframe with three rows indexed as y, ymin and ymax.\n\nfun_y: callable = None\n\nA function that takes an array-like and returns a single value\n\nfun_ymax: callable = None\n\nA function that takes an array-like and returns a single value\n\nfun_args: dict = None\n\nArguments to any of the functions. Provided the names of the arguments of the different functions are in not conflict, the arguments will be assigned to the right functions. If there is a conflict, create a wrapper function that resolves the ambiguity in the argument names.\n\nrandom_state: int | ~numpy.random.RandomState = None\n\nSeed or Random number generator to use. If None, then numpy global generator :class:numpy.random is used."
  },
  {
    "objectID": "reference/stat_summary_bin.html#notes",
    "href": "reference/stat_summary_bin.html#notes",
    "title": "stat_summary_bin",
    "section": "",
    "text": "The binwidth, bins, breaks and bounary arguments can be a tuples with two values ((xaxis-value, yaxis-value)) of the required type."
  },
  {
    "objectID": "reference/stat_summary_bin.html#see-also",
    "href": "reference/stat_summary_bin.html#see-also",
    "title": "stat_summary_bin",
    "section": "",
    "text": "plotnine.geoms.geom_pointrange"
  },
  {
    "objectID": "reference/stat_sum.html",
    "href": "reference/stat_sum.html",
    "title": "stat_sum",
    "section": "",
    "text": "stats.stat_sum()\n\n\nSum unique values\nUseful for overplotting on scatterplots.\nUsage\nstat_sum(mapping=None, data=None, geom='point', position='identity',\n         na_rm=False, **kwargs)\nOnly the mapping and data can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the geom.\n\n\n\n\nmapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nsize\n\n\nafter_stat('n')\n\n\n\n\nweight\n\n\n1\n\n\n\n\nThe bold aesthetics are required.\nOptions for computed aesthetics\n\"n\"     # Number of observations at a position\n\"prop\"  # Ratio of points in that panel at a position\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom: str | geom = “point”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values."
  },
  {
    "objectID": "reference/stat_sum.html#parameters",
    "href": "reference/stat_sum.html#parameters",
    "title": "stat_sum",
    "section": "",
    "text": "mapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nsize\n\n\nafter_stat('n')\n\n\n\n\nweight\n\n\n1\n\n\n\n\nThe bold aesthetics are required.\nOptions for computed aesthetics\n\"n\"     # Number of observations at a position\n\"prop\"  # Ratio of points in that panel at a position\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom: str | geom = “point”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values."
  },
  {
    "objectID": "reference/stat_sina.html",
    "href": "reference/stat_sina.html",
    "title": "stat_sina",
    "section": "",
    "text": "stats.stat_sina()\n\n\nCompute Sina plot values\nUsage\nstat_sina(mapping=None, data=None, geom='sina', position='dodge', na_rm=False,\n          bin_limit=1, method='density', bins=None, binwidth=None, bw='nrd0',\n          scale='area', maxwidth=None, adjust=1, random_state=None, **kwargs)\nOnly the mapping and data can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the geom.\n\n\n\n\nmapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nxend\n\n\nafter_stat('scaled')\n\n\n\n\nThe bold aesthetics are required.\nOptions for computed aesthetics\n\"quantile\"  # quantile\n\"group\"     # group identifier\nCalculated aesthetics are accessed using the after_stat function. e.g. after_stat('quantile').\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom: str | geom = “sina”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “dodge”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\nbinwidth: float = None\n\nThe width of the bins. The default is to use bins that cover the range of the data. You should always override this value, exploring multiple widths to find the best to illustrate the stories in your data.\n\nbins: int = 50\n\nNumber of bins. Overridden by binwidth.\n\nmethod: density | counts = “density”\n\nChoose the method to spread the samples within the same bin along the x-axis. Available methods: “density”, “counts” (can be abbreviated, e.g. “d”). See Details.\n\nmaxwidth: float = None\n\nControl the maximum width the points can spread into. Values should be in the range (0, 1).\n\nadjust: float = 1\n\nAdjusts the bandwidth of the density kernel when method=\"density\". see stat_density.\n\nbw: str | float = “nrd0”\n\nThe bandwidth to use, If a float is given, it is the bandwidth. The str choices are: \"nrd0\", \"normal_reference\", \"scott\", \"silverman\"\nnrd0 is a port of stats::bw.nrd0 in R; it is eqiuvalent to silverman when there is more than 1 value in a group.\n\nbin_limit: int = 1\n\nIf the samples within the same y-axis bin are more than bin_limit, the samples’s X coordinates will be adjusted. This parameter is effective only when method='counts'\n\nrandom_state: int | ~numpy.random.RandomState = None\n\nSeed or Random number generator to use. If None, then numpy global generator :class:numpy.random is used.\n\nscale: area | count | width = “area”\n\nHow to scale the sina groups.\n\narea - Scale by the largest density/bin among the different sinas\ncount - areas are scaled proportionally to the number of points\nwidth - Only scale according to the maxwidth parameter.\n\n\n\n\n\n\n\nplotnine.geoms.geom_sina"
  },
  {
    "objectID": "reference/stat_sina.html#parameters",
    "href": "reference/stat_sina.html#parameters",
    "title": "stat_sina",
    "section": "",
    "text": "mapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nxend\n\n\nafter_stat('scaled')\n\n\n\n\nThe bold aesthetics are required.\nOptions for computed aesthetics\n\"quantile\"  # quantile\n\"group\"     # group identifier\nCalculated aesthetics are accessed using the after_stat function. e.g. after_stat('quantile').\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom: str | geom = “sina”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “dodge”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\nbinwidth: float = None\n\nThe width of the bins. The default is to use bins that cover the range of the data. You should always override this value, exploring multiple widths to find the best to illustrate the stories in your data.\n\nbins: int = 50\n\nNumber of bins. Overridden by binwidth.\n\nmethod: density | counts = “density”\n\nChoose the method to spread the samples within the same bin along the x-axis. Available methods: “density”, “counts” (can be abbreviated, e.g. “d”). See Details.\n\nmaxwidth: float = None\n\nControl the maximum width the points can spread into. Values should be in the range (0, 1).\n\nadjust: float = 1\n\nAdjusts the bandwidth of the density kernel when method=\"density\". see stat_density.\n\nbw: str | float = “nrd0”\n\nThe bandwidth to use, If a float is given, it is the bandwidth. The str choices are: \"nrd0\", \"normal_reference\", \"scott\", \"silverman\"\nnrd0 is a port of stats::bw.nrd0 in R; it is eqiuvalent to silverman when there is more than 1 value in a group.\n\nbin_limit: int = 1\n\nIf the samples within the same y-axis bin are more than bin_limit, the samples’s X coordinates will be adjusted. This parameter is effective only when method='counts'\n\nrandom_state: int | ~numpy.random.RandomState = None\n\nSeed or Random number generator to use. If None, then numpy global generator :class:numpy.random is used.\n\nscale: area | count | width = “area”\n\nHow to scale the sina groups.\n\narea - Scale by the largest density/bin among the different sinas\ncount - areas are scaled proportionally to the number of points\nwidth - Only scale according to the maxwidth parameter."
  },
  {
    "objectID": "reference/stat_sina.html#see-also",
    "href": "reference/stat_sina.html#see-also",
    "title": "stat_sina",
    "section": "",
    "text": "plotnine.geoms.geom_sina"
  },
  {
    "objectID": "reference/stat_qq_line.html",
    "href": "reference/stat_qq_line.html",
    "title": "stat_qq_line",
    "section": "",
    "text": "stats.stat_qq_line()\n\n\nCalculate line through quantile-quantile plot\nUsage\nstat_qq_line(mapping=None, data=None, geom='qq_line', position='identity',\n             na_rm=False, alpha_beta=(0.375, 0.375), dparams={},\n             quantiles=None, distribution='norm', line_p=(0.25, 0.75),\n             fullrange=False, **kwargs)\nOnly the mapping and data can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the geom.\n\n\n\n\nmapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nsample\n\n\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom: str | geom = “qq_line”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ndistribution: str = “norm”\n\nDistribution or distribution function name. The default is norm for a normal probability plot. Objects that look enough like a stats.distributions instance (i.e. they have a ppf method) are also accepted. See :mod:scipy stats &lt;scipy.stats&gt; for available distributions.\n\ndparams: dict = None\n\nDistribution-specific shape parameters (shape parameters plus location and scale).\n\nquantiles: array_like = None\n\nProbability points at which to calculate the theoretical quantile values. If provided, must be the same number as as the sample data points. The default is to use calculated theoretical points, use to alpha_beta control how these points are generated.\n\nalpha_beta: tuple = (3/8, 3/8)\n\nParameter values to use when calculating the quantiles.\n\nline_p: tuple = (0.25, 0.75)\n\nQuantiles to use when fitting a Q-Q line. Must be 2 values.\n\nfullrange: bool = False\n\nIf True the fit will span the full range of the plot.\n\n\n\n\n\n\nscipy.stats.mstats.plotting_positions\n\nUses alpha_beta to calculate the quantiles."
  },
  {
    "objectID": "reference/stat_qq_line.html#parameters",
    "href": "reference/stat_qq_line.html#parameters",
    "title": "stat_qq_line",
    "section": "",
    "text": "mapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nsample\n\n\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom: str | geom = “qq_line”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ndistribution: str = “norm”\n\nDistribution or distribution function name. The default is norm for a normal probability plot. Objects that look enough like a stats.distributions instance (i.e. they have a ppf method) are also accepted. See :mod:scipy stats &lt;scipy.stats&gt; for available distributions.\n\ndparams: dict = None\n\nDistribution-specific shape parameters (shape parameters plus location and scale).\n\nquantiles: array_like = None\n\nProbability points at which to calculate the theoretical quantile values. If provided, must be the same number as as the sample data points. The default is to use calculated theoretical points, use to alpha_beta control how these points are generated.\n\nalpha_beta: tuple = (3/8, 3/8)\n\nParameter values to use when calculating the quantiles.\n\nline_p: tuple = (0.25, 0.75)\n\nQuantiles to use when fitting a Q-Q line. Must be 2 values.\n\nfullrange: bool = False\n\nIf True the fit will span the full range of the plot."
  },
  {
    "objectID": "reference/stat_qq_line.html#see-also",
    "href": "reference/stat_qq_line.html#see-also",
    "title": "stat_qq_line",
    "section": "",
    "text": "scipy.stats.mstats.plotting_positions\n\nUses alpha_beta to calculate the quantiles."
  },
  {
    "objectID": "reference/stat_identity.html",
    "href": "reference/stat_identity.html",
    "title": "stat_identity",
    "section": "",
    "text": "stats.stat_identity()\n\n\nIdentity (do nothing) statistic\nUsage\nstat_identity(mapping=None, data=None, geom='point', position='identity',\n              na_rm=False, **kwargs)\nOnly the mapping and data can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the geom.\n\n\n\n\nmapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom: str | geom = “point”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values."
  },
  {
    "objectID": "reference/stat_identity.html#parameters",
    "href": "reference/stat_identity.html#parameters",
    "title": "stat_identity",
    "section": "",
    "text": "mapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom: str | geom = “point”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values."
  },
  {
    "objectID": "reference/stat_function.html",
    "href": "reference/stat_function.html",
    "title": "stat_function",
    "section": "",
    "text": "stats.stat_function(self, mapping=None, data=None, **kwargs)\n\n\nSuperimpose a function onto a plot\nUsage\nstat_function(mapping=None, data=None, geom='path', position='identity',\n              na_rm=False, args=None, xlim=None, n=101, fun=None, **kwargs)\nOnly the mapping and data can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the geom.\n\n\n\n\nmapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\ny\n\n\nafter_stat('fx')\n\n\n\n\nThe bold aesthetics are required.\nOptions for computed aesthetics\n\"x\"   # x points at which the function is evaluated\n\"fx\"  # points evaluated at each x\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom: str | geom = “path”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\nfun: callable\n\nFunction to evaluate.\n\nn: int = 101\n\nNumber of points at which to evaluate the function.\n\nxlim: tuple = None\n\nx limits for the range. The default depends on the x aesthetic. There is not an x aesthetic then the xlim must be provided.\n\nargs: tuple | dict = None\n\nArguments to pass to fun."
  },
  {
    "objectID": "reference/stat_function.html#parameters",
    "href": "reference/stat_function.html#parameters",
    "title": "stat_function",
    "section": "",
    "text": "mapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\ny\n\n\nafter_stat('fx')\n\n\n\n\nThe bold aesthetics are required.\nOptions for computed aesthetics\n\"x\"   # x points at which the function is evaluated\n\"fx\"  # points evaluated at each x\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom: str | geom = “path”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\nfun: callable\n\nFunction to evaluate.\n\nn: int = 101\n\nNumber of points at which to evaluate the function.\n\nxlim: tuple = None\n\nx limits for the range. The default depends on the x aesthetic. There is not an x aesthetic then the xlim must be provided.\n\nargs: tuple | dict = None\n\nArguments to pass to fun."
  },
  {
    "objectID": "reference/stat_ecdf.html",
    "href": "reference/stat_ecdf.html",
    "title": "stat_ecdf",
    "section": "",
    "text": "stats.stat_ecdf()\n\n\nEmperical Cumulative Density Function\nUsage\nstat_ecdf(mapping=None, data=None, geom='step', position='identity',\n          na_rm=False, n=None, **kwargs)\nOnly the mapping and data can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the geom.\n\n\n\n\nmapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\nafter_stat('ecdf')\n\n\n\n\nThe bold aesthetics are required.\nOptions for computed aesthetics\n\"x\"     # x in the data\n\"ecdf\"  # cumulative density corresponding to x\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom: str | geom = “step”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\nn\n\nThis is the number of points to interpolate with. If :py:None, do not interpolate.\n\n\n\n\n\n\nplotnine.geoms.geom_step"
  },
  {
    "objectID": "reference/stat_ecdf.html#parameters",
    "href": "reference/stat_ecdf.html#parameters",
    "title": "stat_ecdf",
    "section": "",
    "text": "mapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\nafter_stat('ecdf')\n\n\n\n\nThe bold aesthetics are required.\nOptions for computed aesthetics\n\"x\"     # x in the data\n\"ecdf\"  # cumulative density corresponding to x\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom: str | geom = “step”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\nn\n\nThis is the number of points to interpolate with. If :py:None, do not interpolate."
  },
  {
    "objectID": "reference/stat_ecdf.html#see-also",
    "href": "reference/stat_ecdf.html#see-also",
    "title": "stat_ecdf",
    "section": "",
    "text": "plotnine.geoms.geom_step"
  },
  {
    "objectID": "reference/stat_density.html",
    "href": "reference/stat_density.html",
    "title": "stat_density",
    "section": "",
    "text": "stats.stat_density()\n\n\nCompute density estimate\nUsage\nstat_density(mapping=None, data=None, geom='density', position='stack',\n             na_rm=False, n=1024, cut=3, bw='nrd0', gridsize=None,\n             kernel='gaussian', trim=False, adjust=1, clip=(-inf, inf),\n             **kwargs)\nOnly the mapping and data can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the geom.\n\n\n\n\nmapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\nafter_stat('density')\n\n\n\n\nThe bold aesthetics are required.\nOptions for computed aesthetics\n'density'   # density estimate\n\n'count'     # density * number of points,\n            # useful for stacked density plots\n\n'scaled'    # density estimate, scaled to maximum of 1\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom: str | geom = “density”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “stack”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\nkernel: str = “gaussian”\n\nKernel used for density estimation. One of:\n\"biweight\"\n\"cosine\"\n\"cosine2\"\n\"epanechnikov\"\n\"gaussian\"\n\"triangular\"\n\"triweight\"\n\"uniform\"\n\nadjust: float = 1\n\nAn adjustment factor for the bw. Bandwidth becomes bw * adjust. Adjustment of the bandwidth.\n\ntrim: bool = False\n\nThis parameter only matters if you are displaying multiple densities in one plot. If False, the default, each density is computed on the full range of the data. If True, each density is computed over the range of that group; this typically means the estimated x values will not line-up, and hence you won’t be able to stack density values.\n\nn: int = 1024\n\nNumber of equally spaced points at which the density is to be estimated. For efficient computation, it should be a power of two.\n\ngridsize: int = None\n\nIf gridsize is None, max(len(x), 50) is used.\n\nbw: str | float = “nrd0”\n\nThe bandwidth to use, If a float is given, it is the bandwidth. The options are:\n\"nrd0\"\n\"normal_reference\"\n\"scott\"\n\"silverman\"\nnrd0 is a port of stats::bw.nrd0 in R; it is eqiuvalent to silverman when there is more than 1 value in a group.\n\ncut: float = 3\n\nDefines the length of the grid past the lowest and highest values of x so that the kernel goes to zero. The end points are -/+ cut*bw*{min(x) or max(x)}.\n\nclip: tuple = (-inf, inf)\n\nValues in x that are outside of the range given by clip are dropped. The number of values in x is then shortened.\n\n\n\n\n\n\nplotnine.geoms.geom_density\n\n\n\nstatsmodels.nonparametric.kde.KDEUnivariate\n\n\n\nstatsmodels.nonparametric.kde.KDEUnivariate.fit"
  },
  {
    "objectID": "reference/stat_density.html#parameters",
    "href": "reference/stat_density.html#parameters",
    "title": "stat_density",
    "section": "",
    "text": "mapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\nafter_stat('density')\n\n\n\n\nThe bold aesthetics are required.\nOptions for computed aesthetics\n'density'   # density estimate\n\n'count'     # density * number of points,\n            # useful for stacked density plots\n\n'scaled'    # density estimate, scaled to maximum of 1\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom: str | geom = “density”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “stack”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\nkernel: str = “gaussian”\n\nKernel used for density estimation. One of:\n\"biweight\"\n\"cosine\"\n\"cosine2\"\n\"epanechnikov\"\n\"gaussian\"\n\"triangular\"\n\"triweight\"\n\"uniform\"\n\nadjust: float = 1\n\nAn adjustment factor for the bw. Bandwidth becomes bw * adjust. Adjustment of the bandwidth.\n\ntrim: bool = False\n\nThis parameter only matters if you are displaying multiple densities in one plot. If False, the default, each density is computed on the full range of the data. If True, each density is computed over the range of that group; this typically means the estimated x values will not line-up, and hence you won’t be able to stack density values.\n\nn: int = 1024\n\nNumber of equally spaced points at which the density is to be estimated. For efficient computation, it should be a power of two.\n\ngridsize: int = None\n\nIf gridsize is None, max(len(x), 50) is used.\n\nbw: str | float = “nrd0”\n\nThe bandwidth to use, If a float is given, it is the bandwidth. The options are:\n\"nrd0\"\n\"normal_reference\"\n\"scott\"\n\"silverman\"\nnrd0 is a port of stats::bw.nrd0 in R; it is eqiuvalent to silverman when there is more than 1 value in a group.\n\ncut: float = 3\n\nDefines the length of the grid past the lowest and highest values of x so that the kernel goes to zero. The end points are -/+ cut*bw*{min(x) or max(x)}.\n\nclip: tuple = (-inf, inf)\n\nValues in x that are outside of the range given by clip are dropped. The number of values in x is then shortened."
  },
  {
    "objectID": "reference/stat_density.html#see-also",
    "href": "reference/stat_density.html#see-also",
    "title": "stat_density",
    "section": "",
    "text": "plotnine.geoms.geom_density\n\n\n\nstatsmodels.nonparametric.kde.KDEUnivariate\n\n\n\nstatsmodels.nonparametric.kde.KDEUnivariate.fit"
  },
  {
    "objectID": "reference/stat_boxplot.html",
    "href": "reference/stat_boxplot.html",
    "title": "stat_boxplot",
    "section": "",
    "text": "stats.stat_boxplot()\n\n\nCompute boxplot statistics\nUsage\nstat_boxplot(mapping=None, data=None, geom='boxplot', position='dodge',\n             na_rm=False, coef=1.5, width=None, **kwargs)\nOnly the mapping and data can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the geom.\n\n\n\n\nmapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nThe bold aesthetics are required.\nOptions for computed aesthetics\n\"width\"  # width of boxplot\n\"lower\"  # lower hinge, 25% quantile\n\"middle\" # median, 50% quantile\n\"upper\"  # upper hinge, 75% quantile\n\n# lower edge of notch, computed as;\n# median - 1.58 * IQR / sqrt(n)\n\"notchlower\"\n\n# upper edge of notch, computed as;\n# median + 1.58 * IQR / sqrt(n)\n\"notchupper\"\n\n# lower whisker, computed as; smallest observation\n# greater than or equal to lower hinge - 1.5 * IQR\n\"ymin\"\n\n# upper whisker, computed as; largest observation\n# less than or equal to upper hinge + 1.5 * IQR\n\"ymax\"\nCalculated aesthetics are accessed using the after_stat function. e.g. after_stat('width').\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom: str | geom = “boxplot”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “dodge”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ncoef: float = 1.5\n\nLength of the whiskers as a multiple of the Interquartile Range.\n\n\n\n\n\n\nplotnine.geoms.geom_boxplot"
  },
  {
    "objectID": "reference/stat_boxplot.html#parameters",
    "href": "reference/stat_boxplot.html#parameters",
    "title": "stat_boxplot",
    "section": "",
    "text": "mapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nThe bold aesthetics are required.\nOptions for computed aesthetics\n\"width\"  # width of boxplot\n\"lower\"  # lower hinge, 25% quantile\n\"middle\" # median, 50% quantile\n\"upper\"  # upper hinge, 75% quantile\n\n# lower edge of notch, computed as;\n# median - 1.58 * IQR / sqrt(n)\n\"notchlower\"\n\n# upper edge of notch, computed as;\n# median + 1.58 * IQR / sqrt(n)\n\"notchupper\"\n\n# lower whisker, computed as; smallest observation\n# greater than or equal to lower hinge - 1.5 * IQR\n\"ymin\"\n\n# upper whisker, computed as; largest observation\n# less than or equal to upper hinge + 1.5 * IQR\n\"ymax\"\nCalculated aesthetics are accessed using the after_stat function. e.g. after_stat('width').\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom: str | geom = “boxplot”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “dodge”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ncoef: float = 1.5\n\nLength of the whiskers as a multiple of the Interquartile Range."
  },
  {
    "objectID": "reference/stat_boxplot.html#see-also",
    "href": "reference/stat_boxplot.html#see-also",
    "title": "stat_boxplot",
    "section": "",
    "text": "plotnine.geoms.geom_boxplot"
  },
  {
    "objectID": "reference/stat_bin_2d.html",
    "href": "reference/stat_bin_2d.html",
    "title": "stat_bin_2d",
    "section": "",
    "text": "stats.stat_bin_2d()\n\n\n2 Dimensional bin counts\nUsage\nstat_bin_2d(mapping=None, data=None, geom='rect', position='identity',\n            na_rm=False, bins=30, binwidth=None, breaks=None, drop=True,\n            **kwargs)\nOnly the mapping and data can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the geom.\n\n\n\n\nmapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nfill\n\n\nafter_stat('count')\n\n\n\n\nweight\n\n\nNone\n\n\n\n\nThe bold aesthetics are required.\nOptions for computed aesthetics\n\"xmin\"    # x lower bound for the bin\n\"xmax\"    # x upper bound for the bin\n\"ymin\"    # y lower bound for the bin\n\"ymax\"    # y upper bound for the bin\n\"count\"   # number of points in bin\n\"density\" # density of points in bin, scaled to integrate to 1\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom: str | geom = “rect”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\nbins: int = 30\n\nNumber of bins. Overridden by binwidth.\n\nbreaks: array - like(s) = None\n\nBin boundaries. This supercedes the binwidth, bins, center and boundary. It can be an array_like or a list of two array_likes to provide distinct breaks for the x and y axes.\n\nbinwidth: float = None\n\nThe width of the bins. The default is to use bins bins that cover the range of the data. You should always override this value, exploring multiple widths to find the best to illustrate the stories in your data.\n\ndrop: bool = False\n\nIf True, removes all cells with zero counts."
  },
  {
    "objectID": "reference/stat_bin_2d.html#parameters",
    "href": "reference/stat_bin_2d.html#parameters",
    "title": "stat_bin_2d",
    "section": "",
    "text": "mapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nfill\n\n\nafter_stat('count')\n\n\n\n\nweight\n\n\nNone\n\n\n\n\nThe bold aesthetics are required.\nOptions for computed aesthetics\n\"xmin\"    # x lower bound for the bin\n\"xmax\"    # x upper bound for the bin\n\"ymin\"    # y lower bound for the bin\n\"ymax\"    # y upper bound for the bin\n\"count\"   # number of points in bin\n\"density\" # density of points in bin, scaled to integrate to 1\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom: str | geom = “rect”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\nbins: int = 30\n\nNumber of bins. Overridden by binwidth.\n\nbreaks: array - like(s) = None\n\nBin boundaries. This supercedes the binwidth, bins, center and boundary. It can be an array_like or a list of two array_likes to provide distinct breaks for the x and y axes.\n\nbinwidth: float = None\n\nThe width of the bins. The default is to use bins bins that cover the range of the data. You should always override this value, exploring multiple widths to find the best to illustrate the stories in your data.\n\ndrop: bool = False\n\nIf True, removes all cells with zero counts."
  },
  {
    "objectID": "reference/stat.html",
    "href": "reference/stat.html",
    "title": "stat",
    "section": "",
    "text": "stats.stat\n\n\n\n\n\nName\nDescription\n\n\n\n\nstat\nBase class of all stats\n\n\n\n\n\n\nstats.stat.stat(self, mapping=None, data=None, **kwargs)\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nCREATES\nset() -&gt; new empty set object\n\n\nDEFAULT_AES\ndict() -&gt; new empty dictionary\n\n\nDEFAULT_PARAMS\ndict() -&gt; new empty dictionary\n\n\nNON_MISSING_AES\nset() -&gt; new empty set object\n\n\nREQUIRED_AES\nset() -&gt; new empty set object\n\n\n\n\nBase class of all stats\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\naesthetics\nReturn a set of all non-computed aesthetics for this stat.\n\n\ncompute_group\nCalculate statistics for the group\n\n\ncompute_layer\nCalculate statistics for this layers\n\n\ncompute_panel\nCalculate the statistics for all the groups\n\n\nfinish_layer\nModify data after the aesthetics have been mapped\n\n\nfrom_geom\nReturn an instantiated stat object\n\n\nsetup_data\nOveride to modify data before compute_layer is called\n\n\nsetup_params\nOveride this to verify or adjust parameters\n\n\nto_layer\nMake a layer that represents this stat\n\n\nuse_defaults\nCombine data with defaults and set aesthetics from parameters\n\n\n\n\n\n\nstats.stat.stat.aesthetics()\n\n\nReturn a set of all non-computed aesthetics for this stat.\nstats should not override this method.\n\n\n\n\n\nstats.stat.stat.compute_group(data, scales, **params)\n\n\nCalculate statistics for the group\nAll stats should implement this method\n\n\n\n\ndata: dataframe\n\nData for a group\n\nscales: types.SimpleNamespace\n\nx (scales.x) and y (scales.y) scale objects. The most likely reason to use scale information is to find out the physical size of a scale. e.g.\nrange_x = scales.x.dimension()\n\nparams: dict = {}\n\nParameters\n\n\n\n\n\n\n\nstats.stat.stat.compute_layer(data, params, layout)\n\n\nCalculate statistics for this layers\nThis is the top-most computation method for the stat. It does not do any computations, but it knows how to verify the data, partition it call the next computation method and merge results.\nstats should not override this method.\n\n\n\n\ndata: panda.DataFrame\n\nData points for all objects in a layer.\n\nparams: dict\n\nStat parameters\n\nlayout: plotnine.layout.Layout\n\nPanel layout information\n\n\n\n\n\n\n\nstats.stat.stat.compute_panel(data, scales, **params)\n\n\nCalculate the statistics for all the groups\nReturn the results in a single dataframe.\nThis is a default function that can be overriden by individual stats\n\n\n\n\ndata: dataframe\n\ndata for the computing\n\nscales: dataclass\n\nx (scales.x) and y (scales.y) scale objects. The most likely reason to use scale information is to find out the physical size of a scale. e.g.\nrange_x = scales.x.dimension()\n\nparams: dict = {}\n\nThe parameters for the stat. It includes default values if user did not set a particular parameter.\n\n\n\n\n\n\n\nstats.stat.stat.finish_layer(data, params)\n\n\nModify data after the aesthetics have been mapped\nThis can be used by stats that require access to the mapped values of the computed aesthetics, part 3 as shown below.\n1. stat computes and creates variables\n2. variables mapped to aesthetics\n3. stat sees and modifies data according to the\n   aesthetic values\nThe default to is to do nothing.\n\n\n\n\ndata: dataframe\n\nData for the layer\n\nparams: dict\n\nParemeters\n\n\n\n\n\n\ndata: dataframe\n\nModified data\n\n\n\n\n\n\n\nstats.stat.stat.from_geom(geom)\n\n\nReturn an instantiated stat object\nstats should not override this method.\n\n\n\n\ngeom: geom\n\ngeom\n\n\n\n\n\n\nout: stat\n\nA stat object\n\n\n\n\n\n\n if unable to create a stat.\n\n\n\n\n\n\n\n\n\nstats.stat.stat.setup_data(data)\n\n\nOveride to modify data before compute_layer is called\n\n\n\n\ndata: dataframe\n\nData\n\n\n\n\n\n\nout: dataframe\n\nData\n\n\n\n\n\n\n\nstats.stat.stat.setup_params(data)\n\n\nOveride this to verify or adjust parameters\n\n\n\n\ndata: dataframe\n\nData\n\n\n\n\n\n\nout: dict\n\nParameters used by the stats.\n\n\n\n\n\n\n\nstats.stat.stat.to_layer()\n\n\nMake a layer that represents this stat\n\n\n\n\nout: layer\n\nLayer\n\n\n\n\n\n\n\nstats.stat.stat.use_defaults(data)\n\n\nCombine data with defaults and set aesthetics from parameters\nstats should not override this method.\n\n\n\n\ndata: dataframe\n\nData used for drawing the geom.\n\n\n\n\n\n\nout: dataframe\n\nData used for drawing the geom."
  },
  {
    "objectID": "reference/stat.html#classes",
    "href": "reference/stat.html#classes",
    "title": "stat",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nstat\nBase class of all stats\n\n\n\n\n\n\nstats.stat.stat(self, mapping=None, data=None, **kwargs)\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nCREATES\nset() -&gt; new empty set object\n\n\nDEFAULT_AES\ndict() -&gt; new empty dictionary\n\n\nDEFAULT_PARAMS\ndict() -&gt; new empty dictionary\n\n\nNON_MISSING_AES\nset() -&gt; new empty set object\n\n\nREQUIRED_AES\nset() -&gt; new empty set object\n\n\n\n\nBase class of all stats\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\naesthetics\nReturn a set of all non-computed aesthetics for this stat.\n\n\ncompute_group\nCalculate statistics for the group\n\n\ncompute_layer\nCalculate statistics for this layers\n\n\ncompute_panel\nCalculate the statistics for all the groups\n\n\nfinish_layer\nModify data after the aesthetics have been mapped\n\n\nfrom_geom\nReturn an instantiated stat object\n\n\nsetup_data\nOveride to modify data before compute_layer is called\n\n\nsetup_params\nOveride this to verify or adjust parameters\n\n\nto_layer\nMake a layer that represents this stat\n\n\nuse_defaults\nCombine data with defaults and set aesthetics from parameters\n\n\n\n\n\n\nstats.stat.stat.aesthetics()\n\n\nReturn a set of all non-computed aesthetics for this stat.\nstats should not override this method.\n\n\n\n\n\nstats.stat.stat.compute_group(data, scales, **params)\n\n\nCalculate statistics for the group\nAll stats should implement this method\n\n\n\n\ndata: dataframe\n\nData for a group\n\nscales: types.SimpleNamespace\n\nx (scales.x) and y (scales.y) scale objects. The most likely reason to use scale information is to find out the physical size of a scale. e.g.\nrange_x = scales.x.dimension()\n\nparams: dict = {}\n\nParameters\n\n\n\n\n\n\n\nstats.stat.stat.compute_layer(data, params, layout)\n\n\nCalculate statistics for this layers\nThis is the top-most computation method for the stat. It does not do any computations, but it knows how to verify the data, partition it call the next computation method and merge results.\nstats should not override this method.\n\n\n\n\ndata: panda.DataFrame\n\nData points for all objects in a layer.\n\nparams: dict\n\nStat parameters\n\nlayout: plotnine.layout.Layout\n\nPanel layout information\n\n\n\n\n\n\n\nstats.stat.stat.compute_panel(data, scales, **params)\n\n\nCalculate the statistics for all the groups\nReturn the results in a single dataframe.\nThis is a default function that can be overriden by individual stats\n\n\n\n\ndata: dataframe\n\ndata for the computing\n\nscales: dataclass\n\nx (scales.x) and y (scales.y) scale objects. The most likely reason to use scale information is to find out the physical size of a scale. e.g.\nrange_x = scales.x.dimension()\n\nparams: dict = {}\n\nThe parameters for the stat. It includes default values if user did not set a particular parameter.\n\n\n\n\n\n\n\nstats.stat.stat.finish_layer(data, params)\n\n\nModify data after the aesthetics have been mapped\nThis can be used by stats that require access to the mapped values of the computed aesthetics, part 3 as shown below.\n1. stat computes and creates variables\n2. variables mapped to aesthetics\n3. stat sees and modifies data according to the\n   aesthetic values\nThe default to is to do nothing.\n\n\n\n\ndata: dataframe\n\nData for the layer\n\nparams: dict\n\nParemeters\n\n\n\n\n\n\ndata: dataframe\n\nModified data\n\n\n\n\n\n\n\nstats.stat.stat.from_geom(geom)\n\n\nReturn an instantiated stat object\nstats should not override this method.\n\n\n\n\ngeom: geom\n\ngeom\n\n\n\n\n\n\nout: stat\n\nA stat object\n\n\n\n\n\n\n if unable to create a stat.\n\n\n\n\n\n\n\n\n\nstats.stat.stat.setup_data(data)\n\n\nOveride to modify data before compute_layer is called\n\n\n\n\ndata: dataframe\n\nData\n\n\n\n\n\n\nout: dataframe\n\nData\n\n\n\n\n\n\n\nstats.stat.stat.setup_params(data)\n\n\nOveride this to verify or adjust parameters\n\n\n\n\ndata: dataframe\n\nData\n\n\n\n\n\n\nout: dict\n\nParameters used by the stats.\n\n\n\n\n\n\n\nstats.stat.stat.to_layer()\n\n\nMake a layer that represents this stat\n\n\n\n\nout: layer\n\nLayer\n\n\n\n\n\n\n\nstats.stat.stat.use_defaults(data)\n\n\nCombine data with defaults and set aesthetics from parameters\nstats should not override this method.\n\n\n\n\ndata: dataframe\n\nData used for drawing the geom.\n\n\n\n\n\n\nout: dataframe\n\nData used for drawing the geom."
  },
  {
    "objectID": "reference/set_option.html",
    "href": "reference/set_option.html",
    "title": "set_option",
    "section": "",
    "text": "options.set_option(name, value)\n\n\nSet package option\n\n\n\n\nname: str\n\nName of the option\n\nvalue: object\n\nNew value of the option\n\n\n\n\n\n\nold: object\n\nOld value of the option"
  },
  {
    "objectID": "reference/set_option.html#parameters",
    "href": "reference/set_option.html#parameters",
    "title": "set_option",
    "section": "",
    "text": "name: str\n\nName of the option\n\nvalue: object\n\nNew value of the option"
  },
  {
    "objectID": "reference/set_option.html#returns",
    "href": "reference/set_option.html#returns",
    "title": "set_option",
    "section": "",
    "text": "old: object\n\nOld value of the option"
  },
  {
    "objectID": "reference/scale_y_timedelta.html",
    "href": "reference/scale_y_timedelta.html",
    "title": "scale_y_timedelta",
    "section": "",
    "text": "scales.scale_y_timedelta()\n\n\nContinuous y position for timedelta data points\n\n\n\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\nna_value: scalar = float(“nan”)\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default."
  },
  {
    "objectID": "reference/scale_y_timedelta.html#parameters",
    "href": "reference/scale_y_timedelta.html#parameters",
    "title": "scale_y_timedelta",
    "section": "",
    "text": "breaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\nna_value: scalar = float(“nan”)\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default."
  },
  {
    "objectID": "reference/scale_y_reverse.html",
    "href": "reference/scale_y_reverse.html",
    "title": "scale_y_reverse",
    "section": "",
    "text": "scales.scale_y_reverse()\n\n\nContinuous y position reverse transformed scale\n\n\n\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\nna_value: scalar = float(“nan”)\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default."
  },
  {
    "objectID": "reference/scale_y_reverse.html#parameters",
    "href": "reference/scale_y_reverse.html#parameters",
    "title": "scale_y_reverse",
    "section": "",
    "text": "breaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\nna_value: scalar = float(“nan”)\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default."
  },
  {
    "objectID": "reference/scale_y_discrete.html",
    "href": "reference/scale_y_discrete.html",
    "title": "scale_y_discrete",
    "section": "",
    "text": "scales.scale_y_discrete()\n\n\nDiscrete y position\n\n\n\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values. Default value is True\n\nna_value: object\n\nIf na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right.\n\nlimits: array_like = None\n\nLimits of the scale. For discrete scale, these are the categories (unique values) of the variable. For scales that deal with categoricals, these may be a subset or superset of the categories."
  },
  {
    "objectID": "reference/scale_y_discrete.html#parameters",
    "href": "reference/scale_y_discrete.html#parameters",
    "title": "scale_y_discrete",
    "section": "",
    "text": "breaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values. Default value is True\n\nna_value: object\n\nIf na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right.\n\nlimits: array_like = None\n\nLimits of the scale. For discrete scale, these are the categories (unique values) of the variable. For scales that deal with categoricals, these may be a subset or superset of the categories."
  },
  {
    "objectID": "reference/scale_y_date.html",
    "href": "reference/scale_y_date.html",
    "title": "scale_y_date",
    "section": "",
    "text": "scales.scale_y_date\n\nContinuous y position for datetime data points\n\n\n\ndate_breaks : str, default=None A string giving the distance between major breaks. For example '2 weeks', '5 years'. If specified, date_breaks takes precedence over breaks. date_labels : str, default=None Format string for the labels. See :ref:strftime &lt;strftime-strptime-behavior&gt;. If specified, date_labels takes precedence over labels. date_minor_breaks : str, default=None A string giving the distance between minor breaks. For example '2 weeks', '5 years'. If specified, date_minor_breaks takes precedence over minor_breaks. breaks : bool | list | callable, default=True List of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks. expand : tuple, default=None Multiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n```\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\n```\n\nFor example,\n\n- `(0, 0)` - Do not expand.\n- `(0, 1)` - Expand lower and upper limits by 1 unit.\n- `(1, 0)` - Expand lower and upper limits by 100%.\n- `(0, 0, 0, 0)` - Do not expand, as `(0, 0)`.\n- `(0, 0, 0, 1)` - Expand upper limit by 1 unit.\n- `(0, 1, 0.1, 0)` - Expand lower limit by 1 unit and\n  upper limit by 10%.\n- `(0, 0, 0.1, 2)` - Expand upper limit by 10% plus\n  2 units.\n\nIf not specified, suitable defaults are chosen.\nname : str, default=None Name used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale. labels : bool | list | callable, default=True List of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings. limits : array_like, default=None Limits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories. na_value : scalar, default=float(“nan”) What value to assign to missing values. Default is to assign np.nan. palette : callable, default=None Function to map data points onto the scale. Most scales define their own palettes. aesthetics : list | str, default=None list of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun. trans : str | callable Name of a trans function or a trans function. See :mod:mizani.transforms for possible options. oob : callable, default=mizani.bounds.censor Function to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped. minor_breaks : list | int | callable, default=None If a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them. rescaler : callable, default=mizani.bounds.rescale Function to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default."
  },
  {
    "objectID": "reference/scale_y_date.html#parameters",
    "href": "reference/scale_y_date.html#parameters",
    "title": "scale_y_date",
    "section": "",
    "text": "date_breaks : str, default=None A string giving the distance between major breaks. For example '2 weeks', '5 years'. If specified, date_breaks takes precedence over breaks. date_labels : str, default=None Format string for the labels. See :ref:strftime &lt;strftime-strptime-behavior&gt;. If specified, date_labels takes precedence over labels. date_minor_breaks : str, default=None A string giving the distance between minor breaks. For example '2 weeks', '5 years'. If specified, date_minor_breaks takes precedence over minor_breaks. breaks : bool | list | callable, default=True List of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks. expand : tuple, default=None Multiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n```\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\n```\n\nFor example,\n\n- `(0, 0)` - Do not expand.\n- `(0, 1)` - Expand lower and upper limits by 1 unit.\n- `(1, 0)` - Expand lower and upper limits by 100%.\n- `(0, 0, 0, 0)` - Do not expand, as `(0, 0)`.\n- `(0, 0, 0, 1)` - Expand upper limit by 1 unit.\n- `(0, 1, 0.1, 0)` - Expand lower limit by 1 unit and\n  upper limit by 10%.\n- `(0, 0, 0.1, 2)` - Expand upper limit by 10% plus\n  2 units.\n\nIf not specified, suitable defaults are chosen.\nname : str, default=None Name used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale. labels : bool | list | callable, default=True List of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings. limits : array_like, default=None Limits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories. na_value : scalar, default=float(“nan”) What value to assign to missing values. Default is to assign np.nan. palette : callable, default=None Function to map data points onto the scale. Most scales define their own palettes. aesthetics : list | str, default=None list of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun. trans : str | callable Name of a trans function or a trans function. See :mod:mizani.transforms for possible options. oob : callable, default=mizani.bounds.censor Function to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped. minor_breaks : list | int | callable, default=None If a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them. rescaler : callable, default=mizani.bounds.rescale Function to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default."
  },
  {
    "objectID": "reference/scale_x_timedelta.html",
    "href": "reference/scale_x_timedelta.html",
    "title": "scale_x_timedelta",
    "section": "",
    "text": "scales.scale_x_timedelta()\n\n\nContinuous x position for timedelta data points\n\n\n\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\nna_value: scalar = float(“nan”)\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default."
  },
  {
    "objectID": "reference/scale_x_timedelta.html#parameters",
    "href": "reference/scale_x_timedelta.html#parameters",
    "title": "scale_x_timedelta",
    "section": "",
    "text": "breaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\nna_value: scalar = float(“nan”)\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default."
  },
  {
    "objectID": "reference/scale_x_reverse.html",
    "href": "reference/scale_x_reverse.html",
    "title": "scale_x_reverse",
    "section": "",
    "text": "scales.scale_x_reverse()\n\n\nContinuous x position reverse transformed scale\n\n\n\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\nna_value: scalar = float(“nan”)\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default."
  },
  {
    "objectID": "reference/scale_x_reverse.html#parameters",
    "href": "reference/scale_x_reverse.html#parameters",
    "title": "scale_x_reverse",
    "section": "",
    "text": "breaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\nna_value: scalar = float(“nan”)\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default."
  },
  {
    "objectID": "reference/scale_x_discrete.html",
    "href": "reference/scale_x_discrete.html",
    "title": "scale_x_discrete",
    "section": "",
    "text": "scales.scale_x_discrete()\n\n\nDiscrete x position\n\n\n\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values. Default value is True\n\nna_value: object\n\nIf na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right.\n\nlimits: array_like = None\n\nLimits of the scale. For discrete scale, these are the categories (unique values) of the variable. For scales that deal with categoricals, these may be a subset or superset of the categories."
  },
  {
    "objectID": "reference/scale_x_discrete.html#parameters",
    "href": "reference/scale_x_discrete.html#parameters",
    "title": "scale_x_discrete",
    "section": "",
    "text": "breaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values. Default value is True\n\nna_value: object\n\nIf na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right.\n\nlimits: array_like = None\n\nLimits of the scale. For discrete scale, these are the categories (unique values) of the variable. For scales that deal with categoricals, these may be a subset or superset of the categories."
  },
  {
    "objectID": "reference/scale_x_date.html",
    "href": "reference/scale_x_date.html",
    "title": "scale_x_date",
    "section": "",
    "text": "scales.scale_x_date\n\nContinuous x position for datetime data points\n\n\n\ndate_breaks : str, default=None A string giving the distance between major breaks. For example '2 weeks', '5 years'. If specified, date_breaks takes precedence over breaks. date_labels : str, default=None Format string for the labels. See :ref:strftime &lt;strftime-strptime-behavior&gt;. If specified, date_labels takes precedence over labels. date_minor_breaks : str, default=None A string giving the distance between minor breaks. For example '2 weeks', '5 years'. If specified, date_minor_breaks takes precedence over minor_breaks. breaks : bool | list | callable, default=True List of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks. expand : tuple, default=None Multiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n```\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\n```\n\nFor example,\n\n- `(0, 0)` - Do not expand.\n- `(0, 1)` - Expand lower and upper limits by 1 unit.\n- `(1, 0)` - Expand lower and upper limits by 100%.\n- `(0, 0, 0, 0)` - Do not expand, as `(0, 0)`.\n- `(0, 0, 0, 1)` - Expand upper limit by 1 unit.\n- `(0, 1, 0.1, 0)` - Expand lower limit by 1 unit and\n  upper limit by 10%.\n- `(0, 0, 0.1, 2)` - Expand upper limit by 10% plus\n  2 units.\n\nIf not specified, suitable defaults are chosen.\nname : str, default=None Name used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale. labels : bool | list | callable, default=True List of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings. limits : array_like, default=None Limits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories. na_value : scalar, default=float(“nan”) What value to assign to missing values. Default is to assign np.nan. palette : callable, default=None Function to map data points onto the scale. Most scales define their own palettes. aesthetics : list | str, default=None list of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun. trans : str | callable Name of a trans function or a trans function. See :mod:mizani.transforms for possible options. oob : callable, default=mizani.bounds.censor Function to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped. minor_breaks : list | int | callable, default=None If a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them. rescaler : callable, default=mizani.bounds.rescale Function to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default."
  },
  {
    "objectID": "reference/scale_x_date.html#parameters",
    "href": "reference/scale_x_date.html#parameters",
    "title": "scale_x_date",
    "section": "",
    "text": "date_breaks : str, default=None A string giving the distance between major breaks. For example '2 weeks', '5 years'. If specified, date_breaks takes precedence over breaks. date_labels : str, default=None Format string for the labels. See :ref:strftime &lt;strftime-strptime-behavior&gt;. If specified, date_labels takes precedence over labels. date_minor_breaks : str, default=None A string giving the distance between minor breaks. For example '2 weeks', '5 years'. If specified, date_minor_breaks takes precedence over minor_breaks. breaks : bool | list | callable, default=True List of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks. expand : tuple, default=None Multiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n```\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\n```\n\nFor example,\n\n- `(0, 0)` - Do not expand.\n- `(0, 1)` - Expand lower and upper limits by 1 unit.\n- `(1, 0)` - Expand lower and upper limits by 100%.\n- `(0, 0, 0, 0)` - Do not expand, as `(0, 0)`.\n- `(0, 0, 0, 1)` - Expand upper limit by 1 unit.\n- `(0, 1, 0.1, 0)` - Expand lower limit by 1 unit and\n  upper limit by 10%.\n- `(0, 0, 0.1, 2)` - Expand upper limit by 10% plus\n  2 units.\n\nIf not specified, suitable defaults are chosen.\nname : str, default=None Name used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale. labels : bool | list | callable, default=True List of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings. limits : array_like, default=None Limits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories. na_value : scalar, default=float(“nan”) What value to assign to missing values. Default is to assign np.nan. palette : callable, default=None Function to map data points onto the scale. Most scales define their own palettes. aesthetics : list | str, default=None list of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun. trans : str | callable Name of a trans function or a trans function. See :mod:mizani.transforms for possible options. oob : callable, default=mizani.bounds.censor Function to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped. minor_breaks : list | int | callable, default=None If a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them. rescaler : callable, default=mizani.bounds.rescale Function to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default."
  },
  {
    "objectID": "reference/scale_size_radius.html",
    "href": "reference/scale_size_radius.html",
    "title": "scale_size_radius",
    "section": "",
    "text": "scales.scale_size_radius(self, range=(1, 6), **kwargs)\n\n\nContinuous radius size scale\n\n\n\n\nrange: array_like = (1, 6)\n\nMinimum and maximum radius of the plotting symbol. It must be of size 2.\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\nna_value: scalar = float(“nan”)\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default."
  },
  {
    "objectID": "reference/scale_size_radius.html#parameters",
    "href": "reference/scale_size_radius.html#parameters",
    "title": "scale_size_radius",
    "section": "",
    "text": "range: array_like = (1, 6)\n\nMinimum and maximum radius of the plotting symbol. It must be of size 2.\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\nna_value: scalar = float(“nan”)\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default."
  },
  {
    "objectID": "reference/scale_size_identity.html",
    "href": "reference/scale_size_identity.html",
    "title": "scale_size_identity",
    "section": "",
    "text": "scales.scale_identity.scale_size_identity()\n\n\nNo size scaling\n\n\n\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\nna_value: scalar = float(“nan”)\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\nguide: None | ‘legend’ = None\n\nWhether to include a legend."
  },
  {
    "objectID": "reference/scale_size_identity.html#parameters",
    "href": "reference/scale_size_identity.html#parameters",
    "title": "scale_size_identity",
    "section": "",
    "text": "breaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\nna_value: scalar = float(“nan”)\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\nguide: None | ‘legend’ = None\n\nWhether to include a legend."
  },
  {
    "objectID": "reference/scale_size_datetime.html",
    "href": "reference/scale_size_datetime.html",
    "title": "scale_size_datetime",
    "section": "",
    "text": "scales.scale_size_datetime(self, range=(1, 6), **kwargs)\n\n\nDatetime area-size scale\n\n\n\n\nrange: array_like = (1, 6)\n\nMinimum and maximum area of the plotting symbol. It must be of size 2.\n\ndate_breaks: str = None\n\nA string giving the distance between major breaks. For example '2 weeks', '5 years'. If specified, date_breaks takes precedence over breaks.\n\ndate_labels: str = None\n\nFormat string for the labels. See :ref:strftime &lt;strftime-strptime-behavior&gt;. If specified, date_labels takes precedence over labels.\n\ndate_minor_breaks: str = None\n\nA string giving the distance between minor breaks. For example '2 weeks', '5 years'. If specified, date_minor_breaks takes precedence over minor_breaks.\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\nna_value: scalar = float(“nan”)\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default."
  },
  {
    "objectID": "reference/scale_size_datetime.html#parameters",
    "href": "reference/scale_size_datetime.html#parameters",
    "title": "scale_size_datetime",
    "section": "",
    "text": "range: array_like = (1, 6)\n\nMinimum and maximum area of the plotting symbol. It must be of size 2.\n\ndate_breaks: str = None\n\nA string giving the distance between major breaks. For example '2 weeks', '5 years'. If specified, date_breaks takes precedence over breaks.\n\ndate_labels: str = None\n\nFormat string for the labels. See :ref:strftime &lt;strftime-strptime-behavior&gt;. If specified, date_labels takes precedence over labels.\n\ndate_minor_breaks: str = None\n\nA string giving the distance between minor breaks. For example '2 weeks', '5 years'. If specified, date_minor_breaks takes precedence over minor_breaks.\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\nna_value: scalar = float(“nan”)\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default."
  },
  {
    "objectID": "reference/scale_size_area.html",
    "href": "reference/scale_size_area.html",
    "title": "scale_size_area",
    "section": "",
    "text": "scales.scale_size_area(self, max_size=6, **kwargs)\n\n\nContinuous area size scale\n\n\n\n\nmax_size: float = 6\n\nMaximum size of the plotting symbol.\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\nna_value: scalar = float(“nan”)\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default."
  },
  {
    "objectID": "reference/scale_size_area.html#parameters",
    "href": "reference/scale_size_area.html#parameters",
    "title": "scale_size_area",
    "section": "",
    "text": "max_size: float = 6\n\nMaximum size of the plotting symbol.\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\nna_value: scalar = float(“nan”)\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default."
  },
  {
    "objectID": "reference/scale_shape_manual.html",
    "href": "reference/scale_shape_manual.html",
    "title": "scale_shape_manual",
    "section": "",
    "text": "scales.scale_shape_manual()\n\n\nCustom discrete shape scale\n\n\n\n\nvalues: array_like | dict\n\nShapes that make up the palette. See :mod:matplotlib.markers. for list of all possible shapes. The values will be matched with the limits of the scale or the breaks if provided. If it is a dict then it should map data values to shapes.\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nlimits: array_like = None\n\nLimits of the scale. For scales that deal with categoricals, these may be a subset or superset of the categories. Data values that are not in the limits will be treated as missing data and represented with the na_value.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values. Default value is True\n\nna_value: object\n\nIf na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right.\n\n\n\n\n\n\nmatplotlib.markers"
  },
  {
    "objectID": "reference/scale_shape_manual.html#parameters",
    "href": "reference/scale_shape_manual.html#parameters",
    "title": "scale_shape_manual",
    "section": "",
    "text": "values: array_like | dict\n\nShapes that make up the palette. See :mod:matplotlib.markers. for list of all possible shapes. The values will be matched with the limits of the scale or the breaks if provided. If it is a dict then it should map data values to shapes.\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nlimits: array_like = None\n\nLimits of the scale. For scales that deal with categoricals, these may be a subset or superset of the categories. Data values that are not in the limits will be treated as missing data and represented with the na_value.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values. Default value is True\n\nna_value: object\n\nIf na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right."
  },
  {
    "objectID": "reference/scale_shape_manual.html#see-also",
    "href": "reference/scale_shape_manual.html#see-also",
    "title": "scale_shape_manual",
    "section": "",
    "text": "matplotlib.markers"
  },
  {
    "objectID": "reference/scale_shape_discrete.html",
    "href": "reference/scale_shape_discrete.html",
    "title": "scale_shape_discrete",
    "section": "",
    "text": "scales.scale_shape_discrete\n\nScale for shapes\n\n\n\nunfilled : bool If True, then all shapes will have no interiors that can be a filled. breaks : bool | list | callable, default=True List of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks. expand : tuple, default=None Multiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n```\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\n```\n\nFor example,\n\n- `(0, 0)` - Do not expand.\n- `(0, 1)` - Expand lower and upper limits by 1 unit.\n- `(1, 0)` - Expand lower and upper limits by 100%.\n- `(0, 0, 0, 0)` - Do not expand, as `(0, 0)`.\n- `(0, 0, 0, 1)` - Expand upper limit by 1 unit.\n- `(0, 1, 0.1, 0)` - Expand lower limit by 1 unit and\n  upper limit by 10%.\n- `(0, 0, 0.1, 2)` - Expand upper limit by 10% plus\n  2 units.\n\nIf not specified, suitable defaults are chosen.\nname : str, default=None Name used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale. labels : bool | list | callable, default=True List of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings. palette : callable, default=None Function to map data points onto the scale. Most scales define their own palettes. aesthetics : list | str, default=None list of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun. limits : array_like, default=None Limits of the scale. For scales that deal with categoricals, these may be a subset or superset of the categories. Data values that are not in the limits will be treated as missing data and represented with the na_value. drop : bool, default=True Whether to drop unused categories from the scale na_translate : bool, default=True If True translate missing values and show them. If False remove missing values. Default value is True na_value : object If na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right."
  },
  {
    "objectID": "reference/scale_shape_discrete.html#parameters",
    "href": "reference/scale_shape_discrete.html#parameters",
    "title": "scale_shape_discrete",
    "section": "",
    "text": "unfilled : bool If True, then all shapes will have no interiors that can be a filled. breaks : bool | list | callable, default=True List of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks. expand : tuple, default=None Multiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n```\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\n```\n\nFor example,\n\n- `(0, 0)` - Do not expand.\n- `(0, 1)` - Expand lower and upper limits by 1 unit.\n- `(1, 0)` - Expand lower and upper limits by 100%.\n- `(0, 0, 0, 0)` - Do not expand, as `(0, 0)`.\n- `(0, 0, 0, 1)` - Expand upper limit by 1 unit.\n- `(0, 1, 0.1, 0)` - Expand lower limit by 1 unit and\n  upper limit by 10%.\n- `(0, 0, 0.1, 2)` - Expand upper limit by 10% plus\n  2 units.\n\nIf not specified, suitable defaults are chosen.\nname : str, default=None Name used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale. labels : bool | list | callable, default=True List of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings. palette : callable, default=None Function to map data points onto the scale. Most scales define their own palettes. aesthetics : list | str, default=None list of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun. limits : array_like, default=None Limits of the scale. For scales that deal with categoricals, these may be a subset or superset of the categories. Data values that are not in the limits will be treated as missing data and represented with the na_value. drop : bool, default=True Whether to drop unused categories from the scale na_translate : bool, default=True If True translate missing values and show them. If False remove missing values. Default value is True na_value : object If na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right."
  },
  {
    "objectID": "reference/scale_linetype_manual.html",
    "href": "reference/scale_linetype_manual.html",
    "title": "scale_linetype_manual",
    "section": "",
    "text": "scales.scale_linetype_manual()\n\n\nCustom discrete linetype scale\n\n\n\n\nvalues: list | dict\n\nLinetypes that make up the palette. Possible values of the list are:\n\nStrings like\n\n'solid'                # solid line\n'dashed'               # dashed line\n'dashdot'              # dash-dotted line\n'dotted'               # dotted line\n'None' or ' ' or ''    # draw nothing\n\nTuples of the form (offset, (on, off, on, off, ….)) e.g. (0, (1, 1)), (1, (2, 2)), (2, (5, 3, 1, 3))\n\nThe values will be matched with the limits of the scale or the breaks if provided. If it is a dict then it should map data values to linetypes.\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nlimits: array_like = None\n\nLimits of the scale. For scales that deal with categoricals, these may be a subset or superset of the categories. Data values that are not in the limits will be treated as missing data and represented with the na_value.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values. Default value is True\n\nna_value: object\n\nIf na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right.\n\n\n\n\n\n\nmatplotlib.markers"
  },
  {
    "objectID": "reference/scale_linetype_manual.html#parameters",
    "href": "reference/scale_linetype_manual.html#parameters",
    "title": "scale_linetype_manual",
    "section": "",
    "text": "values: list | dict\n\nLinetypes that make up the palette. Possible values of the list are:\n\nStrings like\n\n'solid'                # solid line\n'dashed'               # dashed line\n'dashdot'              # dash-dotted line\n'dotted'               # dotted line\n'None' or ' ' or ''    # draw nothing\n\nTuples of the form (offset, (on, off, on, off, ….)) e.g. (0, (1, 1)), (1, (2, 2)), (2, (5, 3, 1, 3))\n\nThe values will be matched with the limits of the scale or the breaks if provided. If it is a dict then it should map data values to linetypes.\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nlimits: array_like = None\n\nLimits of the scale. For scales that deal with categoricals, these may be a subset or superset of the categories. Data values that are not in the limits will be treated as missing data and represented with the na_value.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values. Default value is True\n\nna_value: object\n\nIf na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right."
  },
  {
    "objectID": "reference/scale_linetype_manual.html#see-also",
    "href": "reference/scale_linetype_manual.html#see-also",
    "title": "scale_linetype_manual",
    "section": "",
    "text": "matplotlib.markers"
  },
  {
    "objectID": "reference/scale_linetype_discrete.html",
    "href": "reference/scale_linetype_discrete.html",
    "title": "scale_linetype_discrete",
    "section": "",
    "text": "scales.scale_linetype_discrete\n\nScale for line patterns\n\n\n\nbreaks : bool | list | callable, default=True List of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks. expand : tuple, default=None Multiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n```\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\n```\n\nFor example,\n\n- `(0, 0)` - Do not expand.\n- `(0, 1)` - Expand lower and upper limits by 1 unit.\n- `(1, 0)` - Expand lower and upper limits by 100%.\n- `(0, 0, 0, 0)` - Do not expand, as `(0, 0)`.\n- `(0, 0, 0, 1)` - Expand upper limit by 1 unit.\n- `(0, 1, 0.1, 0)` - Expand lower limit by 1 unit and\n  upper limit by 10%.\n- `(0, 0, 0.1, 2)` - Expand upper limit by 10% plus\n  2 units.\n\nIf not specified, suitable defaults are chosen.\nname : str, default=None Name used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale. labels : bool | list | callable, default=True List of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings. palette : callable, default=None Function to map data points onto the scale. Most scales define their own palettes. aesthetics : list | str, default=None list of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun. limits : array_like, default=None Limits of the scale. For scales that deal with categoricals, these may be a subset or superset of the categories. Data values that are not in the limits will be treated as missing data and represented with the na_value. drop : bool, default=True Whether to drop unused categories from the scale na_translate : bool, default=True If True translate missing values and show them. If False remove missing values. Default value is True na_value : object If na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right.\n\n\n\nThe available linetypes are 'solid', 'dashed', 'dashdot', 'dotted' If you need more custom linetypes, use scale_linetype_manual"
  },
  {
    "objectID": "reference/scale_linetype_discrete.html#parameters",
    "href": "reference/scale_linetype_discrete.html#parameters",
    "title": "scale_linetype_discrete",
    "section": "",
    "text": "breaks : bool | list | callable, default=True List of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks. expand : tuple, default=None Multiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n```\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\n```\n\nFor example,\n\n- `(0, 0)` - Do not expand.\n- `(0, 1)` - Expand lower and upper limits by 1 unit.\n- `(1, 0)` - Expand lower and upper limits by 100%.\n- `(0, 0, 0, 0)` - Do not expand, as `(0, 0)`.\n- `(0, 0, 0, 1)` - Expand upper limit by 1 unit.\n- `(0, 1, 0.1, 0)` - Expand lower limit by 1 unit and\n  upper limit by 10%.\n- `(0, 0, 0.1, 2)` - Expand upper limit by 10% plus\n  2 units.\n\nIf not specified, suitable defaults are chosen.\nname : str, default=None Name used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale. labels : bool | list | callable, default=True List of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings. palette : callable, default=None Function to map data points onto the scale. Most scales define their own palettes. aesthetics : list | str, default=None list of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun. limits : array_like, default=None Limits of the scale. For scales that deal with categoricals, these may be a subset or superset of the categories. Data values that are not in the limits will be treated as missing data and represented with the na_value. drop : bool, default=True Whether to drop unused categories from the scale na_translate : bool, default=True If True translate missing values and show them. If False remove missing values. Default value is True na_value : object If na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right."
  },
  {
    "objectID": "reference/scale_linetype_discrete.html#notes",
    "href": "reference/scale_linetype_discrete.html#notes",
    "title": "scale_linetype_discrete",
    "section": "",
    "text": "The available linetypes are 'solid', 'dashed', 'dashdot', 'dotted' If you need more custom linetypes, use scale_linetype_manual"
  },
  {
    "objectID": "reference/scale_fill_manual.html",
    "href": "reference/scale_fill_manual.html",
    "title": "scale_fill_manual",
    "section": "",
    "text": "scales.scale_fill_manual()\n\n\nCustom discrete fill scale\n\n\n\n\nvalues: array_like | dict\n\nColors that make up the palette. The values will be matched with the limits of the scale or the breaks if provided. If it is a dict then it should map data values to colors.\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nlimits: array_like = None\n\nLimits of the scale. For scales that deal with categoricals, these may be a subset or superset of the categories. Data values that are not in the limits will be treated as missing data and represented with the na_value.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values. Default value is True\n\nna_value: object\n\nIf na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right."
  },
  {
    "objectID": "reference/scale_fill_manual.html#parameters",
    "href": "reference/scale_fill_manual.html#parameters",
    "title": "scale_fill_manual",
    "section": "",
    "text": "values: array_like | dict\n\nColors that make up the palette. The values will be matched with the limits of the scale or the breaks if provided. If it is a dict then it should map data values to colors.\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nlimits: array_like = None\n\nLimits of the scale. For scales that deal with categoricals, these may be a subset or superset of the categories. Data values that are not in the limits will be treated as missing data and represented with the na_value.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values. Default value is True\n\nna_value: object\n\nIf na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right."
  },
  {
    "objectID": "reference/scale_fill_hue.html",
    "href": "reference/scale_fill_hue.html",
    "title": "scale_fill_hue",
    "section": "",
    "text": "scales.scale_fill_hue()\n\n\nQualitative color scale with evenly spaced hues\n\n\n\n\nh: float\n\nfirst hue. Must be in the range [0, 1]\n\nl: float\n\nlightness. Must be in the range [0, 1]\n\ns: float\n\nsaturation. Must be in the range [0, 1]\n\ncolorspace: str = “hls”\n\nColor space to use. Should be one of hls or husl.\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nlimits: array_like = None\n\nLimits of the scale. For scales that deal with categoricals, these may be a subset or superset of the categories. Data values that are not in the limits will be treated as missing data and represented with the na_value.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values. Default value is True\n\nna_value: str = “#7F7F7F”\n\nColor of missing values."
  },
  {
    "objectID": "reference/scale_fill_hue.html#parameters",
    "href": "reference/scale_fill_hue.html#parameters",
    "title": "scale_fill_hue",
    "section": "",
    "text": "h: float\n\nfirst hue. Must be in the range [0, 1]\n\nl: float\n\nlightness. Must be in the range [0, 1]\n\ns: float\n\nsaturation. Must be in the range [0, 1]\n\ncolorspace: str = “hls”\n\nColor space to use. Should be one of hls or husl.\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nlimits: array_like = None\n\nLimits of the scale. For scales that deal with categoricals, these may be a subset or superset of the categories. Data values that are not in the limits will be treated as missing data and represented with the na_value.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values. Default value is True\n\nna_value: str = “#7F7F7F”\n\nColor of missing values."
  },
  {
    "objectID": "reference/scale_fill_gray.html",
    "href": "reference/scale_fill_gray.html",
    "title": "scale_fill_gray",
    "section": "",
    "text": "scales.scale_fill_gray\n\nSequential grey color scale.\n\n\n\nstart : float, default=0.2 grey value at low end of palette. end : float, default=0.8 grey value at high end of palette breaks : bool | list | callable, default=True List of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks. expand : tuple, default=None Multiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n```\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\n```\n\nFor example,\n\n- `(0, 0)` - Do not expand.\n- `(0, 1)` - Expand lower and upper limits by 1 unit.\n- `(1, 0)` - Expand lower and upper limits by 100%.\n- `(0, 0, 0, 0)` - Do not expand, as `(0, 0)`.\n- `(0, 0, 0, 1)` - Expand upper limit by 1 unit.\n- `(0, 1, 0.1, 0)` - Expand lower limit by 1 unit and\n  upper limit by 10%.\n- `(0, 0, 0.1, 2)` - Expand upper limit by 10% plus\n  2 units.\n\nIf not specified, suitable defaults are chosen.\nname : str, default=None Name used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale. labels : bool | list | callable, default=True List of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings. palette : callable, default=None Function to map data points onto the scale. Most scales define their own palettes. aesthetics : list | str, default=None list of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun. limits : array_like, default=None Limits of the scale. For scales that deal with categoricals, these may be a subset or superset of the categories. Data values that are not in the limits will be treated as missing data and represented with the na_value. drop : bool, default=True Whether to drop unused categories from the scale na_translate : bool, default=True If True translate missing values and show them. If False remove missing values. Default value is True na_value : object If na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right."
  },
  {
    "objectID": "reference/scale_fill_gray.html#parameters",
    "href": "reference/scale_fill_gray.html#parameters",
    "title": "scale_fill_gray",
    "section": "",
    "text": "start : float, default=0.2 grey value at low end of palette. end : float, default=0.8 grey value at high end of palette breaks : bool | list | callable, default=True List of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks. expand : tuple, default=None Multiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n```\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\n```\n\nFor example,\n\n- `(0, 0)` - Do not expand.\n- `(0, 1)` - Expand lower and upper limits by 1 unit.\n- `(1, 0)` - Expand lower and upper limits by 100%.\n- `(0, 0, 0, 0)` - Do not expand, as `(0, 0)`.\n- `(0, 0, 0, 1)` - Expand upper limit by 1 unit.\n- `(0, 1, 0.1, 0)` - Expand lower limit by 1 unit and\n  upper limit by 10%.\n- `(0, 0, 0.1, 2)` - Expand upper limit by 10% plus\n  2 units.\n\nIf not specified, suitable defaults are chosen.\nname : str, default=None Name used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale. labels : bool | list | callable, default=True List of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings. palette : callable, default=None Function to map data points onto the scale. Most scales define their own palettes. aesthetics : list | str, default=None list of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun. limits : array_like, default=None Limits of the scale. For scales that deal with categoricals, these may be a subset or superset of the categories. Data values that are not in the limits will be treated as missing data and represented with the na_value. drop : bool, default=True Whether to drop unused categories from the scale na_translate : bool, default=True If True translate missing values and show them. If False remove missing values. Default value is True na_value : object If na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right."
  },
  {
    "objectID": "reference/scale_fill_gradient2.html",
    "href": "reference/scale_fill_gradient2.html",
    "title": "scale_fill_gradient2",
    "section": "",
    "text": "scales.scale_fill_gradient2()\n\n\nCreate a 3 point diverging color gradient\n\n\n\n\nlow: str\n\nlow color\n\nmid: str\n\nmid point color\n\nhigh: str\n\nhigh color\n\nmidpoint: float = 0\n\nMid point of the input data range.\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\nna_value: str = “#7F7F7F”\n\nColor of missing values"
  },
  {
    "objectID": "reference/scale_fill_gradient2.html#parameters",
    "href": "reference/scale_fill_gradient2.html#parameters",
    "title": "scale_fill_gradient2",
    "section": "",
    "text": "low: str\n\nlow color\n\nmid: str\n\nmid point color\n\nhigh: str\n\nhigh color\n\nmidpoint: float = 0\n\nMid point of the input data range.\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\nna_value: str = “#7F7F7F”\n\nColor of missing values"
  },
  {
    "objectID": "reference/scale_fill_distiller.html",
    "href": "reference/scale_fill_distiller.html",
    "title": "scale_fill_distiller",
    "section": "",
    "text": "scales.scale_fill_distiller()\n\n\nSequential, diverging continuous color scales\n\n\n\n\ntype: ‘seq’ | ‘div’ = “seq”\n\nType of data. Sequential, diverging or qualitative\n\npalette: int | str = 1\n\nIf a string, will use that named palette. If a number, will index into the list of palettes of appropriate type. Default is 1\n\nvalues: list = None\n\nlist of points in the range [0, 1] at which to place each color. Must be the same size as colors. Default to evenly space the colors\n\ndirection\n\nSets the order of colors in the scale. If 1 colors are as output by brewer_pal. If -1, the order of colors is reversed.\n\ncolors: (list)\n\nlist of colors\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\nna_value: str = “#7F7F7F”\n\nColor of missing values."
  },
  {
    "objectID": "reference/scale_fill_distiller.html#parameters",
    "href": "reference/scale_fill_distiller.html#parameters",
    "title": "scale_fill_distiller",
    "section": "",
    "text": "type: ‘seq’ | ‘div’ = “seq”\n\nType of data. Sequential, diverging or qualitative\n\npalette: int | str = 1\n\nIf a string, will use that named palette. If a number, will index into the list of palettes of appropriate type. Default is 1\n\nvalues: list = None\n\nlist of points in the range [0, 1] at which to place each color. Must be the same size as colors. Default to evenly space the colors\n\ndirection\n\nSets the order of colors in the scale. If 1 colors are as output by brewer_pal. If -1, the order of colors is reversed.\n\ncolors: (list)\n\nlist of colors\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\nna_value: str = “#7F7F7F”\n\nColor of missing values."
  },
  {
    "objectID": "reference/scale_fill_desaturate.html",
    "href": "reference/scale_fill_desaturate.html",
    "title": "scale_fill_desaturate",
    "section": "",
    "text": "scales.scale_fill_desaturate()\n\n\nCreate a desaturated color gradient\n\n\n\n\ncolor: str = “red”\n\nColor to desaturate\n\nprop: float = 0\n\nSaturation channel of color will be multiplied by this value.\n\nreverse: bool = False\n\nWhether to go from color to desaturated color or desaturated color to color.\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\nna_value: str = “#7F7F7F”\n\nColor of missing values."
  },
  {
    "objectID": "reference/scale_fill_desaturate.html#parameters",
    "href": "reference/scale_fill_desaturate.html#parameters",
    "title": "scale_fill_desaturate",
    "section": "",
    "text": "color: str = “red”\n\nColor to desaturate\n\nprop: float = 0\n\nSaturation channel of color will be multiplied by this value.\n\nreverse: bool = False\n\nWhether to go from color to desaturated color or desaturated color to color.\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\nna_value: str = “#7F7F7F”\n\nColor of missing values."
  },
  {
    "objectID": "reference/scale_fill_continuous.html",
    "href": "reference/scale_fill_continuous.html",
    "title": "scale_fill_continuous",
    "section": "",
    "text": "scales.scale_fill_continuous\n\nCreate color scales using Matplotlib colormaps\n\n\n\ncmap_name : str, default=“viridis” A standard Matplotlib colormap name. The default is viridis. For the list of names checkout the output of matplotlib.cm.cmap_d.keys() or see the documentation &lt;http://matplotlib.org/users/colormaps.html&gt;_. breaks : bool | list | callable, default=True List of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks. expand : tuple, default=None Multiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n```\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\n```\n\nFor example,\n\n- `(0, 0)` - Do not expand.\n- `(0, 1)` - Expand lower and upper limits by 1 unit.\n- `(1, 0)` - Expand lower and upper limits by 100%.\n- `(0, 0, 0, 0)` - Do not expand, as `(0, 0)`.\n- `(0, 0, 0, 1)` - Expand upper limit by 1 unit.\n- `(0, 1, 0.1, 0)` - Expand lower limit by 1 unit and\n  upper limit by 10%.\n- `(0, 0, 0.1, 2)` - Expand upper limit by 10% plus\n  2 units.\n\nIf not specified, suitable defaults are chosen.\nname : str, default=None Name used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale. labels : bool | list | callable, default=True List of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings. limits : array_like, default=None Limits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories. palette : callable, default=None Function to map data points onto the scale. Most scales define their own palettes. aesthetics : list | str, default=None list of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun. trans : str | callable Name of a trans function or a trans function. See :mod:mizani.transforms for possible options. oob : callable, default=mizani.bounds.censor Function to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped. minor_breaks : list | int | callable, default=None If a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them. rescaler : callable, default=mizani.bounds.rescale Function to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default. na_value : str, default=“#7F7F7F” Color of missing values."
  },
  {
    "objectID": "reference/scale_fill_continuous.html#parameters",
    "href": "reference/scale_fill_continuous.html#parameters",
    "title": "scale_fill_continuous",
    "section": "",
    "text": "cmap_name : str, default=“viridis” A standard Matplotlib colormap name. The default is viridis. For the list of names checkout the output of matplotlib.cm.cmap_d.keys() or see the documentation &lt;http://matplotlib.org/users/colormaps.html&gt;_. breaks : bool | list | callable, default=True List of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks. expand : tuple, default=None Multiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n```\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\n```\n\nFor example,\n\n- `(0, 0)` - Do not expand.\n- `(0, 1)` - Expand lower and upper limits by 1 unit.\n- `(1, 0)` - Expand lower and upper limits by 100%.\n- `(0, 0, 0, 0)` - Do not expand, as `(0, 0)`.\n- `(0, 0, 0, 1)` - Expand upper limit by 1 unit.\n- `(0, 1, 0.1, 0)` - Expand lower limit by 1 unit and\n  upper limit by 10%.\n- `(0, 0, 0.1, 2)` - Expand upper limit by 10% plus\n  2 units.\n\nIf not specified, suitable defaults are chosen.\nname : str, default=None Name used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale. labels : bool | list | callable, default=True List of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings. limits : array_like, default=None Limits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories. palette : callable, default=None Function to map data points onto the scale. Most scales define their own palettes. aesthetics : list | str, default=None list of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun. trans : str | callable Name of a trans function or a trans function. See :mod:mizani.transforms for possible options. oob : callable, default=mizani.bounds.censor Function to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped. minor_breaks : list | int | callable, default=None If a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them. rescaler : callable, default=mizani.bounds.rescale Function to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default. na_value : str, default=“#7F7F7F” Color of missing values."
  },
  {
    "objectID": "reference/scale_fill_brewer.html",
    "href": "reference/scale_fill_brewer.html",
    "title": "scale_fill_brewer",
    "section": "",
    "text": "scales.scale_fill_brewer()\n\n\nSequential, diverging and qualitative color scales\n\n\n\n\ntype: ‘seq’ | ‘div’ | ‘qual’ = “seq”\n\nType of data. Sequential, diverging or qualitative\n\npalette: int | str = 1\n\nIf a string, will use that named palette. If a number, will index into the list of palettes of appropriate type.\n\ndirection\n\nSets the order of colors in the scale. If 1, colors are as output by brewer_pal. If -1, the order of colors is reversed.\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nlimits: array_like = None\n\nLimits of the scale. For scales that deal with categoricals, these may be a subset or superset of the categories. Data values that are not in the limits will be treated as missing data and represented with the na_value.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values. Default value is True\n\nna_value: str = “#7F7F7F”\n\nColor of missing values."
  },
  {
    "objectID": "reference/scale_fill_brewer.html#parameters",
    "href": "reference/scale_fill_brewer.html#parameters",
    "title": "scale_fill_brewer",
    "section": "",
    "text": "type: ‘seq’ | ‘div’ | ‘qual’ = “seq”\n\nType of data. Sequential, diverging or qualitative\n\npalette: int | str = 1\n\nIf a string, will use that named palette. If a number, will index into the list of palettes of appropriate type.\n\ndirection\n\nSets the order of colors in the scale. If 1, colors are as output by brewer_pal. If -1, the order of colors is reversed.\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nlimits: array_like = None\n\nLimits of the scale. For scales that deal with categoricals, these may be a subset or superset of the categories. Data values that are not in the limits will be treated as missing data and represented with the na_value.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values. Default value is True\n\nna_value: str = “#7F7F7F”\n\nColor of missing values."
  },
  {
    "objectID": "reference/scale_datetime.html",
    "href": "reference/scale_datetime.html",
    "title": "scale_datetime",
    "section": "",
    "text": "scales.scale_datetime.scale_datetime(self, **kwargs)\n\n\nBase class for all date/datetime scales\n\n\n\n\ndate_breaks: str = None\n\nA string giving the distance between major breaks. For example '2 weeks', '5 years'. If specified, date_breaks takes precedence over breaks.\n\ndate_labels: str = None\n\nFormat string for the labels. See :ref:strftime &lt;strftime-strptime-behavior&gt;. If specified, date_labels takes precedence over labels.\n\ndate_minor_breaks: str = None\n\nA string giving the distance between minor breaks. For example '2 weeks', '5 years'. If specified, date_minor_breaks takes precedence over minor_breaks.\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\nna_value: scalar = float(“nan”)\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default."
  },
  {
    "objectID": "reference/scale_datetime.html#parameters",
    "href": "reference/scale_datetime.html#parameters",
    "title": "scale_datetime",
    "section": "",
    "text": "date_breaks: str = None\n\nA string giving the distance between major breaks. For example '2 weeks', '5 years'. If specified, date_breaks takes precedence over breaks.\n\ndate_labels: str = None\n\nFormat string for the labels. See :ref:strftime &lt;strftime-strptime-behavior&gt;. If specified, date_labels takes precedence over labels.\n\ndate_minor_breaks: str = None\n\nA string giving the distance between minor breaks. For example '2 weeks', '5 years'. If specified, date_minor_breaks takes precedence over minor_breaks.\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\nna_value: scalar = float(“nan”)\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default."
  },
  {
    "objectID": "reference/scale_colour_manual.html",
    "href": "reference/scale_colour_manual.html",
    "title": "scale_colour_manual",
    "section": "",
    "text": "scales.scale_colour_manual\n\nCustom discrete color scale\n\n\n\nvalues : array_like | dict Colors that make up the palette. The values will be matched with the limits of the scale or the breaks if provided. If it is a dict then it should map data values to colors.\nbreaks : bool | list | callable, default=True List of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks. expand : tuple, default=None Multiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n```\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\n```\n\nFor example,\n\n- `(0, 0)` - Do not expand.\n- `(0, 1)` - Expand lower and upper limits by 1 unit.\n- `(1, 0)` - Expand lower and upper limits by 100%.\n- `(0, 0, 0, 0)` - Do not expand, as `(0, 0)`.\n- `(0, 0, 0, 1)` - Expand upper limit by 1 unit.\n- `(0, 1, 0.1, 0)` - Expand lower limit by 1 unit and\n  upper limit by 10%.\n- `(0, 0, 0.1, 2)` - Expand upper limit by 10% plus\n  2 units.\n\nIf not specified, suitable defaults are chosen.\nname : str, default=None Name used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale. labels : bool | list | callable, default=True List of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings. palette : callable, default=None Function to map data points onto the scale. Most scales define their own palettes. aesthetics : list | str, default=None list of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun. limits : array_like, default=None Limits of the scale. For scales that deal with categoricals, these may be a subset or superset of the categories. Data values that are not in the limits will be treated as missing data and represented with the na_value. drop : bool, default=True Whether to drop unused categories from the scale na_translate : bool, default=True If True translate missing values and show them. If False remove missing values. Default value is True na_value : object If na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right."
  },
  {
    "objectID": "reference/scale_colour_manual.html#parameters",
    "href": "reference/scale_colour_manual.html#parameters",
    "title": "scale_colour_manual",
    "section": "",
    "text": "values : array_like | dict Colors that make up the palette. The values will be matched with the limits of the scale or the breaks if provided. If it is a dict then it should map data values to colors.\nbreaks : bool | list | callable, default=True List of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks. expand : tuple, default=None Multiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n```\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\n```\n\nFor example,\n\n- `(0, 0)` - Do not expand.\n- `(0, 1)` - Expand lower and upper limits by 1 unit.\n- `(1, 0)` - Expand lower and upper limits by 100%.\n- `(0, 0, 0, 0)` - Do not expand, as `(0, 0)`.\n- `(0, 0, 0, 1)` - Expand upper limit by 1 unit.\n- `(0, 1, 0.1, 0)` - Expand lower limit by 1 unit and\n  upper limit by 10%.\n- `(0, 0, 0.1, 2)` - Expand upper limit by 10% plus\n  2 units.\n\nIf not specified, suitable defaults are chosen.\nname : str, default=None Name used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale. labels : bool | list | callable, default=True List of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings. palette : callable, default=None Function to map data points onto the scale. Most scales define their own palettes. aesthetics : list | str, default=None list of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun. limits : array_like, default=None Limits of the scale. For scales that deal with categoricals, these may be a subset or superset of the categories. Data values that are not in the limits will be treated as missing data and represented with the na_value. drop : bool, default=True Whether to drop unused categories from the scale na_translate : bool, default=True If True translate missing values and show them. If False remove missing values. Default value is True na_value : object If na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right."
  },
  {
    "objectID": "reference/scale_color_manual.html",
    "href": "reference/scale_color_manual.html",
    "title": "scale_color_manual",
    "section": "",
    "text": "scales.scale_color_manual()\n\n\nCustom discrete color scale\n\n\n\n\nvalues: array_like | dict\n\nColors that make up the palette. The values will be matched with the limits of the scale or the breaks if provided. If it is a dict then it should map data values to colors.\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nlimits: array_like = None\n\nLimits of the scale. For scales that deal with categoricals, these may be a subset or superset of the categories. Data values that are not in the limits will be treated as missing data and represented with the na_value.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values. Default value is True\n\nna_value: object\n\nIf na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right."
  },
  {
    "objectID": "reference/scale_color_manual.html#parameters",
    "href": "reference/scale_color_manual.html#parameters",
    "title": "scale_color_manual",
    "section": "",
    "text": "values: array_like | dict\n\nColors that make up the palette. The values will be matched with the limits of the scale or the breaks if provided. If it is a dict then it should map data values to colors.\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nlimits: array_like = None\n\nLimits of the scale. For scales that deal with categoricals, these may be a subset or superset of the categories. Data values that are not in the limits will be treated as missing data and represented with the na_value.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values. Default value is True\n\nna_value: object\n\nIf na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right."
  },
  {
    "objectID": "reference/scale_color_hue.html",
    "href": "reference/scale_color_hue.html",
    "title": "scale_color_hue",
    "section": "",
    "text": "scales.scale_color_hue(self, h=0.01, l=0.6, s=0.65, color_space='hls', **kwargs)\n\n\nQualitative color scale with evenly spaced hues\n\n\n\n\nh: float = 0.01\n\nfirst hue. Must be in the range [0, 1]\n\nl: float = 0.6\n\nlightness. Must be in the range [0, 1]\n\ns: float = 0.65\n\nsaturation. Must be in the range [0, 1]\n\ncolorspace: str = “hls”\n\nColor space to use. Should be one of hls or husl.\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nlimits: array_like = None\n\nLimits of the scale. For scales that deal with categoricals, these may be a subset or superset of the categories. Data values that are not in the limits will be treated as missing data and represented with the na_value.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values. Default value is True\n\nna_value: str = “#7F7F7F”\n\nColor of missing values."
  },
  {
    "objectID": "reference/scale_color_hue.html#parameters",
    "href": "reference/scale_color_hue.html#parameters",
    "title": "scale_color_hue",
    "section": "",
    "text": "h: float = 0.01\n\nfirst hue. Must be in the range [0, 1]\n\nl: float = 0.6\n\nlightness. Must be in the range [0, 1]\n\ns: float = 0.65\n\nsaturation. Must be in the range [0, 1]\n\ncolorspace: str = “hls”\n\nColor space to use. Should be one of hls or husl.\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nlimits: array_like = None\n\nLimits of the scale. For scales that deal with categoricals, these may be a subset or superset of the categories. Data values that are not in the limits will be treated as missing data and represented with the na_value.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values. Default value is True\n\nna_value: str = “#7F7F7F”\n\nColor of missing values."
  },
  {
    "objectID": "reference/scale_color_gray.html",
    "href": "reference/scale_color_gray.html",
    "title": "scale_color_gray",
    "section": "",
    "text": "scales.scale_color_gray\n\nSequential grey color scale.\n\n\n\nstart : float, default=0.2 grey value at low end of palette. end : float, default=0.8 grey value at high end of palette breaks : bool | list | callable, default=True List of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks. expand : tuple, default=None Multiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n```\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\n```\n\nFor example,\n\n- `(0, 0)` - Do not expand.\n- `(0, 1)` - Expand lower and upper limits by 1 unit.\n- `(1, 0)` - Expand lower and upper limits by 100%.\n- `(0, 0, 0, 0)` - Do not expand, as `(0, 0)`.\n- `(0, 0, 0, 1)` - Expand upper limit by 1 unit.\n- `(0, 1, 0.1, 0)` - Expand lower limit by 1 unit and\n  upper limit by 10%.\n- `(0, 0, 0.1, 2)` - Expand upper limit by 10% plus\n  2 units.\n\nIf not specified, suitable defaults are chosen.\nname : str, default=None Name used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale. labels : bool | list | callable, default=True List of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings. palette : callable, default=None Function to map data points onto the scale. Most scales define their own palettes. aesthetics : list | str, default=None list of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun. limits : array_like, default=None Limits of the scale. For scales that deal with categoricals, these may be a subset or superset of the categories. Data values that are not in the limits will be treated as missing data and represented with the na_value. drop : bool, default=True Whether to drop unused categories from the scale na_translate : bool, default=True If True translate missing values and show them. If False remove missing values. Default value is True na_value : object If na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right."
  },
  {
    "objectID": "reference/scale_color_gray.html#parameters",
    "href": "reference/scale_color_gray.html#parameters",
    "title": "scale_color_gray",
    "section": "",
    "text": "start : float, default=0.2 grey value at low end of palette. end : float, default=0.8 grey value at high end of palette breaks : bool | list | callable, default=True List of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks. expand : tuple, default=None Multiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n```\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\n```\n\nFor example,\n\n- `(0, 0)` - Do not expand.\n- `(0, 1)` - Expand lower and upper limits by 1 unit.\n- `(1, 0)` - Expand lower and upper limits by 100%.\n- `(0, 0, 0, 0)` - Do not expand, as `(0, 0)`.\n- `(0, 0, 0, 1)` - Expand upper limit by 1 unit.\n- `(0, 1, 0.1, 0)` - Expand lower limit by 1 unit and\n  upper limit by 10%.\n- `(0, 0, 0.1, 2)` - Expand upper limit by 10% plus\n  2 units.\n\nIf not specified, suitable defaults are chosen.\nname : str, default=None Name used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale. labels : bool | list | callable, default=True List of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings. palette : callable, default=None Function to map data points onto the scale. Most scales define their own palettes. aesthetics : list | str, default=None list of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun. limits : array_like, default=None Limits of the scale. For scales that deal with categoricals, these may be a subset or superset of the categories. Data values that are not in the limits will be treated as missing data and represented with the na_value. drop : bool, default=True Whether to drop unused categories from the scale na_translate : bool, default=True If True translate missing values and show them. If False remove missing values. Default value is True na_value : object If na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right."
  },
  {
    "objectID": "reference/scale_color_gradient2.html",
    "href": "reference/scale_color_gradient2.html",
    "title": "scale_color_gradient2",
    "section": "",
    "text": "scales.scale_color_gradient2(self, low='#832424', mid='#FFFFFF', high='#3A3A98', midpoint=0, **kwargs)\n\n\nCreate a 3 point diverging color gradient\n\n\n\n\nlow: str = ‘#832424’\n\nlow color\n\nmid: str = ‘#FFFFFF’\n\nmid point color\n\nhigh: str = ‘#3A3A98’\n\nhigh color\n\nmidpoint: float = 0\n\nMid point of the input data range.\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\nna_value: str = “#7F7F7F”\n\nColor of missing values\n\n\n\n\n\n\nplotnine.scales.scale_color_gradient\n\n\n\nplotnine.scales.scale_color_gradientn"
  },
  {
    "objectID": "reference/scale_color_gradient2.html#parameters",
    "href": "reference/scale_color_gradient2.html#parameters",
    "title": "scale_color_gradient2",
    "section": "",
    "text": "low: str = ‘#832424’\n\nlow color\n\nmid: str = ‘#FFFFFF’\n\nmid point color\n\nhigh: str = ‘#3A3A98’\n\nhigh color\n\nmidpoint: float = 0\n\nMid point of the input data range.\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\nna_value: str = “#7F7F7F”\n\nColor of missing values"
  },
  {
    "objectID": "reference/scale_color_gradient2.html#see-also",
    "href": "reference/scale_color_gradient2.html#see-also",
    "title": "scale_color_gradient2",
    "section": "",
    "text": "plotnine.scales.scale_color_gradient\n\n\n\nplotnine.scales.scale_color_gradientn"
  },
  {
    "objectID": "reference/scale_color_distiller.html",
    "href": "reference/scale_color_distiller.html",
    "title": "scale_color_distiller",
    "section": "",
    "text": "scales.scale_color_distiller(self, type='seq', palette=1, values=None, direction=-1, **kwargs)\n\n\nSequential and diverging continuous color scales\nThis is a convinience scale around scale_color_gradientn with colors from colorbrewer.org. It smoothly interpolates 7 colors from a brewer palette to create a continuous palette.\n\n\n\n\ntype: ‘seq’ | ‘div’ = “seq”\n\nType of data. Sequential, diverging or qualitative\n\npalette: int | str = 1\n\nIf a string, will use that named palette. If a number, will index into the list of palettes of appropriate type. Default is 1\n\nvalues: list = None\n\nlist of points in the range [0, 1] at which to place each color. Must be the same size as colors. Default to evenly space the colors\n\ndirection: Literal[1, -1] = -1\n\nSets the order of colors in the scale. If 1 colors are as output by brewer_pal. If -1, the order of colors is reversed.\n\ncolors: (list)\n\nlist of colors\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\nna_value: str = “#7F7F7F”\n\nColor of missing values."
  },
  {
    "objectID": "reference/scale_color_distiller.html#parameters",
    "href": "reference/scale_color_distiller.html#parameters",
    "title": "scale_color_distiller",
    "section": "",
    "text": "type: ‘seq’ | ‘div’ = “seq”\n\nType of data. Sequential, diverging or qualitative\n\npalette: int | str = 1\n\nIf a string, will use that named palette. If a number, will index into the list of palettes of appropriate type. Default is 1\n\nvalues: list = None\n\nlist of points in the range [0, 1] at which to place each color. Must be the same size as colors. Default to evenly space the colors\n\ndirection: Literal[1, -1] = -1\n\nSets the order of colors in the scale. If 1 colors are as output by brewer_pal. If -1, the order of colors is reversed.\n\ncolors: (list)\n\nlist of colors\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\nna_value: str = “#7F7F7F”\n\nColor of missing values."
  },
  {
    "objectID": "reference/scale_color_desaturate.html",
    "href": "reference/scale_color_desaturate.html",
    "title": "scale_color_desaturate",
    "section": "",
    "text": "scales.scale_color_desaturate(self, color='red', prop=0, reverse=False, **kwargs)\n\n\nCreate a desaturated color gradient\n\n\n\n\ncolor: str = “red”\n\nColor to desaturate\n\nprop: float = 0\n\nSaturation channel of color will be multiplied by this value.\n\nreverse: bool = False\n\nWhether to go from color to desaturated color or desaturated color to color.\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\nna_value: str = “#7F7F7F”\n\nColor of missing values."
  },
  {
    "objectID": "reference/scale_color_desaturate.html#parameters",
    "href": "reference/scale_color_desaturate.html#parameters",
    "title": "scale_color_desaturate",
    "section": "",
    "text": "color: str = “red”\n\nColor to desaturate\n\nprop: float = 0\n\nSaturation channel of color will be multiplied by this value.\n\nreverse: bool = False\n\nWhether to go from color to desaturated color or desaturated color to color.\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\nna_value: str = “#7F7F7F”\n\nColor of missing values."
  },
  {
    "objectID": "reference/scale_color_continuous.html",
    "href": "reference/scale_color_continuous.html",
    "title": "scale_color_continuous",
    "section": "",
    "text": "scales.scale_color_continuous\n\nCreate color scales using Matplotlib colormaps\n\n\n\ncmap_name : str, default=“viridis” A standard Matplotlib colormap name. The default is viridis. For the list of names checkout the output of matplotlib.cm.cmap_d.keys() or see the documentation &lt;http://matplotlib.org/users/colormaps.html&gt;_. breaks : bool | list | callable, default=True List of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks. expand : tuple, default=None Multiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n```\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\n```\n\nFor example,\n\n- `(0, 0)` - Do not expand.\n- `(0, 1)` - Expand lower and upper limits by 1 unit.\n- `(1, 0)` - Expand lower and upper limits by 100%.\n- `(0, 0, 0, 0)` - Do not expand, as `(0, 0)`.\n- `(0, 0, 0, 1)` - Expand upper limit by 1 unit.\n- `(0, 1, 0.1, 0)` - Expand lower limit by 1 unit and\n  upper limit by 10%.\n- `(0, 0, 0.1, 2)` - Expand upper limit by 10% plus\n  2 units.\n\nIf not specified, suitable defaults are chosen.\nname : str, default=None Name used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale. labels : bool | list | callable, default=True List of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings. limits : array_like, default=None Limits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories. palette : callable, default=None Function to map data points onto the scale. Most scales define their own palettes. aesthetics : list | str, default=None list of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun. trans : str | callable Name of a trans function or a trans function. See :mod:mizani.transforms for possible options. oob : callable, default=mizani.bounds.censor Function to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped. minor_breaks : list | int | callable, default=None If a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them. rescaler : callable, default=mizani.bounds.rescale Function to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default. na_value : str, default=“#7F7F7F” Color of missing values.\n\n\n\n\nmatplotlib.cm\n\n\n\nmatplotlib.colors"
  },
  {
    "objectID": "reference/scale_color_continuous.html#parameters",
    "href": "reference/scale_color_continuous.html#parameters",
    "title": "scale_color_continuous",
    "section": "",
    "text": "cmap_name : str, default=“viridis” A standard Matplotlib colormap name. The default is viridis. For the list of names checkout the output of matplotlib.cm.cmap_d.keys() or see the documentation &lt;http://matplotlib.org/users/colormaps.html&gt;_. breaks : bool | list | callable, default=True List of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks. expand : tuple, default=None Multiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n```\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\n```\n\nFor example,\n\n- `(0, 0)` - Do not expand.\n- `(0, 1)` - Expand lower and upper limits by 1 unit.\n- `(1, 0)` - Expand lower and upper limits by 100%.\n- `(0, 0, 0, 0)` - Do not expand, as `(0, 0)`.\n- `(0, 0, 0, 1)` - Expand upper limit by 1 unit.\n- `(0, 1, 0.1, 0)` - Expand lower limit by 1 unit and\n  upper limit by 10%.\n- `(0, 0, 0.1, 2)` - Expand upper limit by 10% plus\n  2 units.\n\nIf not specified, suitable defaults are chosen.\nname : str, default=None Name used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale. labels : bool | list | callable, default=True List of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings. limits : array_like, default=None Limits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories. palette : callable, default=None Function to map data points onto the scale. Most scales define their own palettes. aesthetics : list | str, default=None list of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun. trans : str | callable Name of a trans function or a trans function. See :mod:mizani.transforms for possible options. oob : callable, default=mizani.bounds.censor Function to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped. minor_breaks : list | int | callable, default=None If a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them. rescaler : callable, default=mizani.bounds.rescale Function to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default. na_value : str, default=“#7F7F7F” Color of missing values."
  },
  {
    "objectID": "reference/scale_color_continuous.html#see-also",
    "href": "reference/scale_color_continuous.html#see-also",
    "title": "scale_color_continuous",
    "section": "",
    "text": "matplotlib.cm\n\n\n\nmatplotlib.colors"
  },
  {
    "objectID": "reference/scale_color_brewer.html",
    "href": "reference/scale_color_brewer.html",
    "title": "scale_color_brewer",
    "section": "",
    "text": "scales.scale_color_brewer(self, type='seq', palette=1, direction=1, **kwargs)\n\n\nSequential, diverging and qualitative discrete color scales\nSee colorbrewer.org &lt;http://colorbrewer2.org/&gt;_\n\n\n\n\ntype: ‘seq’ | ‘div’ | ‘qual’ = “seq”\n\nType of data. Sequential, diverging or qualitative\n\npalette: int | str = 1\n\nIf a string, will use that named palette. If a number, will index into the list of palettes of appropriate type.\n\ndirection: Literal[1, -1] = 1\n\nSets the order of colors in the scale. If 1, colors are as output by brewer_pal. If -1, the order of colors is reversed.\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nlimits: array_like = None\n\nLimits of the scale. For scales that deal with categoricals, these may be a subset or superset of the categories. Data values that are not in the limits will be treated as missing data and represented with the na_value.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values. Default value is True\n\nna_value: str = “#7F7F7F”\n\nColor of missing values."
  },
  {
    "objectID": "reference/scale_color_brewer.html#parameters",
    "href": "reference/scale_color_brewer.html#parameters",
    "title": "scale_color_brewer",
    "section": "",
    "text": "type: ‘seq’ | ‘div’ | ‘qual’ = “seq”\n\nType of data. Sequential, diverging or qualitative\n\npalette: int | str = 1\n\nIf a string, will use that named palette. If a number, will index into the list of palettes of appropriate type.\n\ndirection: Literal[1, -1] = 1\n\nSets the order of colors in the scale. If 1, colors are as output by brewer_pal. If -1, the order of colors is reversed.\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nlimits: array_like = None\n\nLimits of the scale. For scales that deal with categoricals, these may be a subset or superset of the categories. Data values that are not in the limits will be treated as missing data and represented with the na_value.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values. Default value is True\n\nna_value: str = “#7F7F7F”\n\nColor of missing values."
  },
  {
    "objectID": "reference/scale_alpha_identity.html",
    "href": "reference/scale_alpha_identity.html",
    "title": "scale_alpha_identity",
    "section": "",
    "text": "scales.scale_identity.scale_alpha_identity()\n\n\nNo alpha scaling\n\n\n\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\nna_value: scalar = float(“nan”)\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\nguide: None | ‘legend’ = None\n\nWhether to include a legend."
  },
  {
    "objectID": "reference/scale_alpha_identity.html#parameters",
    "href": "reference/scale_alpha_identity.html#parameters",
    "title": "scale_alpha_identity",
    "section": "",
    "text": "breaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\nna_value: scalar = float(“nan”)\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\nguide: None | ‘legend’ = None\n\nWhether to include a legend."
  },
  {
    "objectID": "reference/scale_alpha_datetime.html",
    "href": "reference/scale_alpha_datetime.html",
    "title": "scale_alpha_datetime",
    "section": "",
    "text": "scales.scale_alpha.scale_alpha_datetime(self, range=(0.1, 1), **kwargs)\n\n\nDatetime Alpha Scale\n\n\n\n\nrange: tuple = (0.1, 1)\n\nRange ([Minimum, Maximum]) of output alpha values. Should be between 0 and 1.\n\ndate_breaks: str = None\n\nA string giving the distance between major breaks. For example '2 weeks', '5 years'. If specified, date_breaks takes precedence over breaks.\n\ndate_labels: str = None\n\nFormat string for the labels. See :ref:strftime &lt;strftime-strptime-behavior&gt;. If specified, date_labels takes precedence over labels.\n\ndate_minor_breaks: str = None\n\nA string giving the distance between minor breaks. For example '2 weeks', '5 years'. If specified, date_minor_breaks takes precedence over minor_breaks.\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\nna_value: scalar = float(“nan”)\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default."
  },
  {
    "objectID": "reference/scale_alpha_datetime.html#parameters",
    "href": "reference/scale_alpha_datetime.html#parameters",
    "title": "scale_alpha_datetime",
    "section": "",
    "text": "range: tuple = (0.1, 1)\n\nRange ([Minimum, Maximum]) of output alpha values. Should be between 0 and 1.\n\ndate_breaks: str = None\n\nA string giving the distance between major breaks. For example '2 weeks', '5 years'. If specified, date_breaks takes precedence over breaks.\n\ndate_labels: str = None\n\nFormat string for the labels. See :ref:strftime &lt;strftime-strptime-behavior&gt;. If specified, date_labels takes precedence over labels.\n\ndate_minor_breaks: str = None\n\nA string giving the distance between minor breaks. For example '2 weeks', '5 years'. If specified, date_minor_breaks takes precedence over minor_breaks.\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\nna_value: scalar = float(“nan”)\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default."
  },
  {
    "objectID": "reference/scale_alpha.html",
    "href": "reference/scale_alpha.html",
    "title": "scale_alpha",
    "section": "",
    "text": "scales.scale_alpha.scale_alpha(self, range=(0.1, 1), **kwargs)\n\n\nContinuous Alpha Scale\n\n\n\n\nrange: tuple = (0.1, 1)\n\nRange ([Minimum, Maximum]) of output alpha values. Should be between 0 and 1.\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\nna_value: scalar = float(“nan”)\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default."
  },
  {
    "objectID": "reference/scale_alpha.html#parameters",
    "href": "reference/scale_alpha.html#parameters",
    "title": "scale_alpha",
    "section": "",
    "text": "range: tuple = (0.1, 1)\n\nRange ([Minimum, Maximum]) of output alpha values. Should be between 0 and 1.\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\nna_value: scalar = float(“nan”)\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default."
  },
  {
    "objectID": "reference/save_as_pdf_pages.html",
    "href": "reference/save_as_pdf_pages.html",
    "title": "save_as_pdf_pages",
    "section": "",
    "text": "save_as_pdf_pages(plots, filename=None, path=None, verbose=True, **kwargs)\n\n\nSave multiple ggplot objects to a PDF file, one per page.\n\n\n\n\nplots: Iterable[ggplot]\n\nPlot objects to write to file. plots may be either a collection such as a :py:class:list or :py:class:set:\nbase_plot = ggplot(…)\nplots = [base_plot + ggtitle('%d of 3' % i) for i in range(1, 3)]\nsave_as_pdf_pages(plots)\nor, a generator that yields ggplot objects:\ndef myplots():\n    for i in range(1, 3):\n        yield ggplot(…) + ggtitle('%d of 3' % i)\nsave_as_pdf_pages(myplots())\n\nfilename: str = None\n\nFile name to write the plot to. If not specified, a name like “plotnine-save-.pdf” is used.\n\npath: str = None\n\nPath to save plot to (if you just want to set path and not filename).\n\nverbose: bool = True\n\nIf True, print the saving information.\n\nkwargs: dict = {}\n\nAdditional arguments to pass to :py:meth:matplotlib.figure.Figure.savefig.\n\n\n\n\n\nUsing pandas :meth:~pandas.DataFrame.groupby methods, tidy data can be “faceted” across pages:\nfrom plotnine.data import mtcars\n\ndef facet_pages(column)\n    base_plot = [\n        aes(x='wt', y='mpg', label='name'),\n        geom_text(),\n        ]\n    for label, group_data in mtcars.groupby(column):\n        yield ggplot(group_data) + base_plot + ggtitle(label)\n\nsave_as_pdf_pages(facet_pages('cyl'))\nUnlike :meth:ggplot.save, :meth:save_as_pdf_pages does not process arguments for height or width. To set the figure size, add figure_size to the theme for some or all of the objects in plots:\nplot = ggplot(…)\n# The following are equivalent\nplot.save('filename.pdf', height=6, width=8)\nsave_as_pdf_pages([plot + theme(figure_size=(8, 6))])"
  },
  {
    "objectID": "reference/save_as_pdf_pages.html#parameters",
    "href": "reference/save_as_pdf_pages.html#parameters",
    "title": "save_as_pdf_pages",
    "section": "",
    "text": "plots: Iterable[ggplot]\n\nPlot objects to write to file. plots may be either a collection such as a :py:class:list or :py:class:set:\nbase_plot = ggplot(…)\nplots = [base_plot + ggtitle('%d of 3' % i) for i in range(1, 3)]\nsave_as_pdf_pages(plots)\nor, a generator that yields ggplot objects:\ndef myplots():\n    for i in range(1, 3):\n        yield ggplot(…) + ggtitle('%d of 3' % i)\nsave_as_pdf_pages(myplots())\n\nfilename: str = None\n\nFile name to write the plot to. If not specified, a name like “plotnine-save-.pdf” is used.\n\npath: str = None\n\nPath to save plot to (if you just want to set path and not filename).\n\nverbose: bool = True\n\nIf True, print the saving information.\n\nkwargs: dict = {}\n\nAdditional arguments to pass to :py:meth:matplotlib.figure.Figure.savefig."
  },
  {
    "objectID": "reference/save_as_pdf_pages.html#notes",
    "href": "reference/save_as_pdf_pages.html#notes",
    "title": "save_as_pdf_pages",
    "section": "",
    "text": "Using pandas :meth:~pandas.DataFrame.groupby methods, tidy data can be “faceted” across pages:\nfrom plotnine.data import mtcars\n\ndef facet_pages(column)\n    base_plot = [\n        aes(x='wt', y='mpg', label='name'),\n        geom_text(),\n        ]\n    for label, group_data in mtcars.groupby(column):\n        yield ggplot(group_data) + base_plot + ggtitle(label)\n\nsave_as_pdf_pages(facet_pages('cyl'))\nUnlike :meth:ggplot.save, :meth:save_as_pdf_pages does not process arguments for height or width. To set the figure size, add figure_size to the theme for some or all of the objects in plots:\nplot = ggplot(…)\n# The following are equivalent\nplot.save('filename.pdf', height=6, width=8)\nsave_as_pdf_pages([plot + theme(figure_size=(8, 6))])"
  },
  {
    "objectID": "reference/qplot.html",
    "href": "reference/qplot.html",
    "title": "qplot",
    "section": "",
    "text": "qplot(x=None, y=None, data=None, facets='', margins=False, geom='auto', xlim=None, ylim=None, log=None, main=None, xlab=None, ylab=None, asp=None, **kwargs)\n\n\nQuick plot\n\n\n\n\nx: str | array_like = None\n\nx aesthetic\n\ny: str | array_like = None\n\ny aesthetic\n\ndata: dataframe = None\n\nData frame to use (optional). If not specified, will create one, extracting arrays from the current environment.\n\ngeom: str | list = ‘auto’\n\ngeom(s) to do the drawing. If auto, defaults to ‘point’ if x and y are specified or ‘histogram’ if only x is specified.\n\nfacets: str = ’’\n\nFacets\n\nmargins: bool | list[str] = False\n\nvariable names to compute margins for. True will compute all possible margins. Depends on the facetting.\n\nxlim: tuple = None\n\nx-axis limits\n\nylim: tuple = None\n\ny-axis limits\n\nlog: ‘x’ | ‘y’ | ‘xy’ = None\n\nWhich (if any) variables to log transform.\n\nmain: str = None\n\nPlot title\n\nxlab: str = None\n\nx-axis label\n\nylab: str = None\n\ny-axis label\n\nasp: str | float = None\n\nThe y/x aspect ratio.\n\n**kwargs: dict = {}\n\nArguments passed on to the geom.\n\n\n\n\n\n\np: ggplot\n\nggplot object"
  },
  {
    "objectID": "reference/qplot.html#parameters",
    "href": "reference/qplot.html#parameters",
    "title": "qplot",
    "section": "",
    "text": "x: str | array_like = None\n\nx aesthetic\n\ny: str | array_like = None\n\ny aesthetic\n\ndata: dataframe = None\n\nData frame to use (optional). If not specified, will create one, extracting arrays from the current environment.\n\ngeom: str | list = ‘auto’\n\ngeom(s) to do the drawing. If auto, defaults to ‘point’ if x and y are specified or ‘histogram’ if only x is specified.\n\nfacets: str = ’’\n\nFacets\n\nmargins: bool | list[str] = False\n\nvariable names to compute margins for. True will compute all possible margins. Depends on the facetting.\n\nxlim: tuple = None\n\nx-axis limits\n\nylim: tuple = None\n\ny-axis limits\n\nlog: ‘x’ | ‘y’ | ‘xy’ = None\n\nWhich (if any) variables to log transform.\n\nmain: str = None\n\nPlot title\n\nxlab: str = None\n\nx-axis label\n\nylab: str = None\n\ny-axis label\n\nasp: str | float = None\n\nThe y/x aspect ratio.\n\n**kwargs: dict = {}\n\nArguments passed on to the geom."
  },
  {
    "objectID": "reference/qplot.html#returns",
    "href": "reference/qplot.html#returns",
    "title": "qplot",
    "section": "",
    "text": "p: ggplot\n\nggplot object"
  },
  {
    "objectID": "reference/position_stack.html",
    "href": "reference/position_stack.html",
    "title": "position_stack",
    "section": "",
    "text": "positions.position_stack(self, vjust=1, reverse=False)\n\n\nStack plotted objects on top of each other\nThe objects to stack are those that have an overlapping x range.\n\n\n\n\nvjust=1\n\nBy what fraction to avoid overlapping the lower object, where 0 gives a complete overlap and 1 gives no overlap."
  },
  {
    "objectID": "reference/position_stack.html#parameters",
    "href": "reference/position_stack.html#parameters",
    "title": "position_stack",
    "section": "",
    "text": "vjust=1\n\nBy what fraction to avoid overlapping the lower object, where 0 gives a complete overlap and 1 gives no overlap."
  },
  {
    "objectID": "reference/position_jitterdodge.html",
    "href": "reference/position_jitterdodge.html",
    "title": "position_jitterdodge",
    "section": "",
    "text": "positions.position_jitterdodge(self, jitter_width=None, jitter_height=0, dodge_width=0.75, random_state=None)\n\n\nDodge and jitter to minimise overlap\nUseful when aligning points generated through geom_point with dodged a geom_boxplot.\n\n\n\n\njitter_width: float = None\n\nProportion to jitter in horizontal direction. If None, 0.4 of the resolution of the data.\n\njitter_height: float = 0\n\nProportion to jitter in vertical direction.\n\ndodge_width: float = 0.75\n\nAmount to dodge in horizontal direction.\n\nrandom_state: int | ~numpy.random.RandomState = None\n\nSeed or Random number generator to use. If None, then numpy global generator :class:numpy.random is used."
  },
  {
    "objectID": "reference/position_jitterdodge.html#parameters",
    "href": "reference/position_jitterdodge.html#parameters",
    "title": "position_jitterdodge",
    "section": "",
    "text": "jitter_width: float = None\n\nProportion to jitter in horizontal direction. If None, 0.4 of the resolution of the data.\n\njitter_height: float = 0\n\nProportion to jitter in vertical direction.\n\ndodge_width: float = 0.75\n\nAmount to dodge in horizontal direction.\n\nrandom_state: int | ~numpy.random.RandomState = None\n\nSeed or Random number generator to use. If None, then numpy global generator :class:numpy.random is used."
  },
  {
    "objectID": "reference/position_identity.html",
    "href": "reference/position_identity.html",
    "title": "position_identity",
    "section": "",
    "text": "position_identity\n\npositions.position_identity()\n\n\nDo not adjust the position"
  },
  {
    "objectID": "reference/position_dodge2.html",
    "href": "reference/position_dodge2.html",
    "title": "position_dodge2",
    "section": "",
    "text": "positions.position_dodge2(self, width=None, preserve='total', padding=0.1, reverse=False)\n\n\nDodge overlaps and place objects side-by-side\nThis is an enhanced version of position_dodge that can deal with rectangular overlaps that do not share a lower x border.\n\n\n\n\nwidth=None\n\nDodging width, when different to the width of the individual elements. This is useful when you want to align narrow geoms with wider geoms\n\npreserve=‘total’\n\nShould dodging preserve the total width of all elements at a position, or the width of a single element?\n\npadding: float = 0.1\n\nPadding between elements at the same position. Elements are shrunk by this proportion to allow space between them.\n\nreverse: bool = False\n\nReverse the default ordering of the groups. This is useful if you’re rotating both the plot and legend."
  },
  {
    "objectID": "reference/position_dodge2.html#parameters",
    "href": "reference/position_dodge2.html#parameters",
    "title": "position_dodge2",
    "section": "",
    "text": "width=None\n\nDodging width, when different to the width of the individual elements. This is useful when you want to align narrow geoms with wider geoms\n\npreserve=‘total’\n\nShould dodging preserve the total width of all elements at a position, or the width of a single element?\n\npadding: float = 0.1\n\nPadding between elements at the same position. Elements are shrunk by this proportion to allow space between them.\n\nreverse: bool = False\n\nReverse the default ordering of the groups. This is useful if you’re rotating both the plot and legend."
  },
  {
    "objectID": "reference/plot_title.html",
    "href": "reference/plot_title.html",
    "title": "plot_title",
    "section": "",
    "text": "themes.themeable.plot_title()\n\n\nPlot title\n\n\n\n\ntheme_element: element_text"
  },
  {
    "objectID": "reference/plot_title.html#parameters",
    "href": "reference/plot_title.html#parameters",
    "title": "plot_title",
    "section": "",
    "text": "theme_element: element_text"
  },
  {
    "objectID": "reference/plot_background.html",
    "href": "reference/plot_background.html",
    "title": "plot_background",
    "section": "",
    "text": "themes.themeable.plot_background()\n\n\nPlot background\n\n\n\n\ntheme_element: element_rect"
  },
  {
    "objectID": "reference/plot_background.html#parameters",
    "href": "reference/plot_background.html#parameters",
    "title": "plot_background",
    "section": "",
    "text": "theme_element: element_rect"
  },
  {
    "objectID": "reference/panel_spacing_x.html",
    "href": "reference/panel_spacing_x.html",
    "title": "panel_spacing_x",
    "section": "",
    "text": "themes.themeable.panel_spacing_x()\n\n\nHorizontal spacing between the facet panels\n\n\n\n\ntheme_element: float\n\nSize as a fraction of the figure width."
  },
  {
    "objectID": "reference/panel_spacing_x.html#parameters",
    "href": "reference/panel_spacing_x.html#parameters",
    "title": "panel_spacing_x",
    "section": "",
    "text": "theme_element: float\n\nSize as a fraction of the figure width."
  },
  {
    "objectID": "reference/panel_ontop.html",
    "href": "reference/panel_ontop.html",
    "title": "panel_ontop",
    "section": "",
    "text": "themes.themeable.panel_ontop()\n\n\nPlace panel background & gridlines over/under the data layers\n\n\n\n\ntheme_element: bool\n\nDefault is False."
  },
  {
    "objectID": "reference/panel_ontop.html#parameters",
    "href": "reference/panel_ontop.html#parameters",
    "title": "panel_ontop",
    "section": "",
    "text": "theme_element: bool\n\nDefault is False."
  },
  {
    "objectID": "reference/panel_grid_minor_x.html",
    "href": "reference/panel_grid_minor_x.html",
    "title": "panel_grid_minor_x",
    "section": "",
    "text": "themes.themeable.panel_grid_minor_x()\n\n\nVertical minor grid lines\n\n\n\n\ntheme_element: element_line"
  },
  {
    "objectID": "reference/panel_grid_minor_x.html#parameters",
    "href": "reference/panel_grid_minor_x.html#parameters",
    "title": "panel_grid_minor_x",
    "section": "",
    "text": "theme_element: element_line"
  },
  {
    "objectID": "reference/panel_grid_major_y.html",
    "href": "reference/panel_grid_major_y.html",
    "title": "panel_grid_major_y",
    "section": "",
    "text": "themes.themeable.panel_grid_major_y()\n\n\nHorizontal major grid lines\n\n\n\n\ntheme_element: element_line"
  },
  {
    "objectID": "reference/panel_grid_major_y.html#parameters",
    "href": "reference/panel_grid_major_y.html#parameters",
    "title": "panel_grid_major_y",
    "section": "",
    "text": "theme_element: element_line"
  },
  {
    "objectID": "reference/panel_grid_major.html",
    "href": "reference/panel_grid_major.html",
    "title": "panel_grid_major",
    "section": "",
    "text": "themes.themeable.panel_grid_major()\n\n\nMajor grid lines\n\n\n\n\ntheme_element: element_line"
  },
  {
    "objectID": "reference/panel_grid_major.html#parameters",
    "href": "reference/panel_grid_major.html#parameters",
    "title": "panel_grid_major",
    "section": "",
    "text": "theme_element: element_line"
  },
  {
    "objectID": "reference/panel_border.html",
    "href": "reference/panel_border.html",
    "title": "panel_border",
    "section": "",
    "text": "themes.themeable.panel_border()\n\n\nPanel border\n\n\n\n\ntheme_element: element_rect"
  },
  {
    "objectID": "reference/panel_border.html#parameters",
    "href": "reference/panel_border.html#parameters",
    "title": "panel_border",
    "section": "",
    "text": "theme_element: element_rect"
  },
  {
    "objectID": "reference/pageviews.html",
    "href": "reference/pageviews.html",
    "title": "pageviews",
    "section": "",
    "text": "pageviews\ndata.pageviews"
  },
  {
    "objectID": "reference/msleep.html",
    "href": "reference/msleep.html",
    "title": "msleep",
    "section": "",
    "text": "msleep\ndata.msleep\n\nAn updated and expanded version of the mammals sleep dataset.\nDescription\nThis is an updated and expanded version of the mammals sleep dataset. Updated sleep times and weights were taken from V. M. Savage and G. B. West. A quantitative, theoretical framework for understanding mammalian sleep. Proceedings of the National Academy of Sciences, 104 (3):1051-1056, 2007.\nFormat\nA data frame with 83 rows and 11 variables\n\n\n\nColumn\nDescription\n\n\n\n\nname genus\ncommon name\n\n\nvore order\ncarnivore, omnivore or herbivore?\n\n\nconservation\nthe conservation status of the animal\n\n\nsleep_total\ntotal amount of sleep, in hours\n\n\nsleep_rem\nrem sleep, in hours\n\n\nsleep_cycle\nlength of sleep cycle, in hours\n\n\nawake\namount of time spent awake, in hours\n\n\nbrainwt\nbrain weight in kilograms\n\n\nbodywt\nbody weight in kilograms\n\n\n\nDetails\nAdditional variables order, conservation status and vore were added from wikipedia."
  },
  {
    "objectID": "reference/midwest.html",
    "href": "reference/midwest.html",
    "title": "midwest",
    "section": "",
    "text": "midwest\ndata.midwest\n\nMidwest demographics.\nDescription\nDemographic information of midwest counties\nFormat\nA data frame with 437 rows and 28 variables\n\n\n\nColumn\nDescription\n\n\n\n\nPID\n\n\n\ncounty\n\n\n\nstate\n\n\n\narea\n\n\n\npoptotal\nTotal population\n\n\npopdensity\nPopulation density\n\n\npopwhite\nNumber of whites\n\n\npopblack\nNumber of blacks\n\n\npopamerindian\nNumber of American Indians\n\n\npopasian\nNumber of Asians\n\n\npopother\nNumber of other races\n\n\npercwhite\nPercent white\n\n\npercblack\nPercent black\n\n\npercamerindan\nPercent American Indian\n\n\npercasian\nPercent Asian\n\n\npercother\nPercent other races\n\n\npopadults\nNumber of adults\n\n\nperchsd\n\n\n\npercollege\nPercent college educated\n\n\npercprof\nPercent profession\n\n\npoppovertyknown\n\n\n\npercpovertyknown\n\n\n\npercbelowpoverty\n\n\n\npercchildbelowpovert\n\n\n\npercadultpoverty\n\n\n\npercelderlypoverty\n\n\n\ninmetro\nIn a metro area\n\n\ncategory"
  },
  {
    "objectID": "reference/luv_colours.html",
    "href": "reference/luv_colours.html",
    "title": "luv_colours",
    "section": "",
    "text": "luv_colours\ndata.luv_colours\n\ncolors in Luv space.\nDescription\nNamed colors translated into Luv colour space.\nFormat\nA data frame with 657 observations and 4 variables:\n\n\n\nColumn\nDescription\n\n\n\n\nL\nL position in Luv colour space\n\n\nu\nu position in Luv colour space\n\n\nv\nv position in Luv colour space\n\n\ncol\nColour name"
  },
  {
    "objectID": "reference/lims.html",
    "href": "reference/lims.html",
    "title": "lims",
    "section": "",
    "text": "scales.lims(self, **kwargs)\n\n\nSet aesthetic limits\n\n\n\n\nkwargs: dict = {}\n\nAesthetic and the values of the limits. e.g x=(40, 100)\n\n\n\n\n\nIf the 2nd value of limits is less than the first, a reversed scale will be created."
  },
  {
    "objectID": "reference/lims.html#parameters",
    "href": "reference/lims.html#parameters",
    "title": "lims",
    "section": "",
    "text": "kwargs: dict = {}\n\nAesthetic and the values of the limits. e.g x=(40, 100)"
  },
  {
    "objectID": "reference/lims.html#notes",
    "href": "reference/lims.html#notes",
    "title": "lims",
    "section": "",
    "text": "If the 2nd value of limits is less than the first, a reversed scale will be created."
  },
  {
    "objectID": "reference/legend_title.html",
    "href": "reference/legend_title.html",
    "title": "legend_title",
    "section": "",
    "text": "themes.themeable.legend_title()\n\n\nLegend title\n\n\n\n\ntheme_element: element_text"
  },
  {
    "objectID": "reference/legend_title.html#parameters",
    "href": "reference/legend_title.html#parameters",
    "title": "legend_title",
    "section": "",
    "text": "theme_element: element_text"
  },
  {
    "objectID": "reference/legend_text_colorbar.html",
    "href": "reference/legend_text_colorbar.html",
    "title": "legend_text_colorbar",
    "section": "",
    "text": "themes.themeable.legend_text_colorbar()\n\n\nColorbar text\n\n\n\n\ntheme_element: element_text\n\n\n\n\n\n\n\nThis themeable exists mainly to cater for differences in how the text is aligned compared to the entry based legend. Unless you experience those alignment issues (i.e when using parameters va or ha), you should use :class:legend_text."
  },
  {
    "objectID": "reference/legend_text_colorbar.html#parameters",
    "href": "reference/legend_text_colorbar.html#parameters",
    "title": "legend_text_colorbar",
    "section": "",
    "text": "theme_element: element_text"
  },
  {
    "objectID": "reference/legend_text_colorbar.html#notes",
    "href": "reference/legend_text_colorbar.html#notes",
    "title": "legend_text_colorbar",
    "section": "",
    "text": "This themeable exists mainly to cater for differences in how the text is aligned compared to the entry based legend. Unless you experience those alignment issues (i.e when using parameters va or ha), you should use :class:legend_text."
  },
  {
    "objectID": "reference/legend_spacing.html",
    "href": "reference/legend_spacing.html",
    "title": "legend_spacing",
    "section": "",
    "text": "themes.themeable.legend_spacing()\n\n\nSpacing between two adjacent legends\n\n\n\n\ntheme_element: float\n\nValue in points."
  },
  {
    "objectID": "reference/legend_spacing.html#parameters",
    "href": "reference/legend_spacing.html#parameters",
    "title": "legend_spacing",
    "section": "",
    "text": "theme_element: float\n\nValue in points."
  },
  {
    "objectID": "reference/legend_margin.html",
    "href": "reference/legend_margin.html",
    "title": "legend_margin",
    "section": "",
    "text": "themes.themeable.legend_margin()\n\n\nPadding between the legend and the inner box\n\n\n\n\ntheme_element: float\n\nValue in points"
  },
  {
    "objectID": "reference/legend_margin.html#parameters",
    "href": "reference/legend_margin.html#parameters",
    "title": "legend_margin",
    "section": "",
    "text": "theme_element: float\n\nValue in points"
  },
  {
    "objectID": "reference/legend_key_size.html",
    "href": "reference/legend_key_size.html",
    "title": "legend_key_size",
    "section": "",
    "text": "themes.themeable.legend_key_size()\n\n\nLegend key background width and height\n\n\n\n\ntheme_element: float\n\nValue in points."
  },
  {
    "objectID": "reference/legend_key_size.html#parameters",
    "href": "reference/legend_key_size.html#parameters",
    "title": "legend_key_size",
    "section": "",
    "text": "theme_element: float\n\nValue in points."
  },
  {
    "objectID": "reference/legend_key.html",
    "href": "reference/legend_key.html",
    "title": "legend_key",
    "section": "",
    "text": "themes.themeable.legend_key()\n\n\nLegend key background\n\n\n\n\ntheme_element: element_rect"
  },
  {
    "objectID": "reference/legend_key.html#parameters",
    "href": "reference/legend_key.html#parameters",
    "title": "legend_key",
    "section": "",
    "text": "theme_element: element_rect"
  },
  {
    "objectID": "reference/legend_entry_spacing_x.html",
    "href": "reference/legend_entry_spacing_x.html",
    "title": "legend_entry_spacing_x",
    "section": "",
    "text": "themes.themeable.legend_entry_spacing_x()\n\n\nHorizontal spacing between two entries in a legend\n\n\n\n\ntheme_element: float\n\nSize in points"
  },
  {
    "objectID": "reference/legend_entry_spacing_x.html#parameters",
    "href": "reference/legend_entry_spacing_x.html#parameters",
    "title": "legend_entry_spacing_x",
    "section": "",
    "text": "theme_element: float\n\nSize in points"
  },
  {
    "objectID": "reference/legend_direction.html",
    "href": "reference/legend_direction.html",
    "title": "legend_direction",
    "section": "",
    "text": "themes.themeable.legend_direction()\n\n\nLayout items in the legend\n\n\n\n\ntheme_element: ‘vertical’ | ‘horizontal’\n\nVertically or horizontally"
  },
  {
    "objectID": "reference/legend_direction.html#parameters",
    "href": "reference/legend_direction.html#parameters",
    "title": "legend_direction",
    "section": "",
    "text": "theme_element: ‘vertical’ | ‘horizontal’\n\nVertically or horizontally"
  },
  {
    "objectID": "reference/legend_box_margin.html",
    "href": "reference/legend_box_margin.html",
    "title": "legend_box_margin",
    "section": "",
    "text": "themes.themeable.legend_box_margin()\n\n\nPadding between the legends and the box\n\n\n\n\ntheme_element: int\n\nValue in points."
  },
  {
    "objectID": "reference/legend_box_margin.html#parameters",
    "href": "reference/legend_box_margin.html#parameters",
    "title": "legend_box_margin",
    "section": "",
    "text": "theme_element: int\n\nValue in points."
  },
  {
    "objectID": "reference/legend_box_background.html",
    "href": "reference/legend_box_background.html",
    "title": "legend_box_background",
    "section": "",
    "text": "themes.themeable.legend_box_background()\n\n\nLegend box background\n\n\n\n\ntheme_element: element_rect\n\n\n\n\n\n\n\nNot Implemented. We would have to place the outermost VPacker/HPacker boxes that hold the individual legends onto an object that has a patch."
  },
  {
    "objectID": "reference/legend_box_background.html#parameters",
    "href": "reference/legend_box_background.html#parameters",
    "title": "legend_box_background",
    "section": "",
    "text": "theme_element: element_rect"
  },
  {
    "objectID": "reference/legend_box_background.html#notes",
    "href": "reference/legend_box_background.html#notes",
    "title": "legend_box_background",
    "section": "",
    "text": "Not Implemented. We would have to place the outermost VPacker/HPacker boxes that hold the individual legends onto an object that has a patch."
  },
  {
    "objectID": "reference/legend_background.html",
    "href": "reference/legend_background.html",
    "title": "legend_background",
    "section": "",
    "text": "themes.themeable.legend_background()\n\n\nLegend background\n\n\n\n\ntheme_element: element_rect"
  },
  {
    "objectID": "reference/legend_background.html#parameters",
    "href": "reference/legend_background.html#parameters",
    "title": "legend_background",
    "section": "",
    "text": "theme_element: element_rect"
  },
  {
    "objectID": "reference/labs.html",
    "href": "reference/labs.html",
    "title": "labs",
    "section": "",
    "text": "labels.labs(self, **kwargs)\n\n\nAdd labels for aesthetics and/or title\n\n\n\n\nkwargs: dict = {}\n\nAesthetics (with scales) to be renamed. You can also set the title and caption."
  },
  {
    "objectID": "reference/labs.html#parameters",
    "href": "reference/labs.html#parameters",
    "title": "labs",
    "section": "",
    "text": "kwargs: dict = {}\n\nAesthetics (with scales) to be renamed. You can also set the title and caption."
  },
  {
    "objectID": "reference/labelling.label_value.html",
    "href": "reference/labelling.label_value.html",
    "title": "labelling.label_value",
    "section": "",
    "text": "facets.labelling.label_value(label_info, multi_line=True)\n\n\nKeep value as the label\n\n\n\n\nlabel_info: strip_label_details\n\nLabel information whose values will be returned\n\nmulti_line: bool = True\n\nWhether to place each variable on a separate line\n\n\n\n\n\n\nout: strip_label_details\n\nLabel text strings"
  },
  {
    "objectID": "reference/labelling.label_value.html#parameters",
    "href": "reference/labelling.label_value.html#parameters",
    "title": "labelling.label_value",
    "section": "",
    "text": "label_info: strip_label_details\n\nLabel information whose values will be returned\n\nmulti_line: bool = True\n\nWhether to place each variable on a separate line"
  },
  {
    "objectID": "reference/labelling.label_value.html#returns",
    "href": "reference/labelling.label_value.html#returns",
    "title": "labelling.label_value",
    "section": "",
    "text": "out: strip_label_details\n\nLabel text strings"
  },
  {
    "objectID": "reference/labelling.label_both.html",
    "href": "reference/labelling.label_both.html",
    "title": "labelling.label_both",
    "section": "",
    "text": "facets.labelling.label_both(label_info, multi_line=True, sep=': ')\n\n\nConcatenate the facet variable with the value\n\n\n\n\nlabel_info: strip_label_details\n\nLabel information to be modified.\n\nmulti_line: bool = True\n\nWhether to place each variable on a separate line\n\nsep: str = ‘:’\n\nSeparation between variable name and value\n\n\n\n\n\n\nout: strip_label_details\n\nLabel information"
  },
  {
    "objectID": "reference/labelling.label_both.html#parameters",
    "href": "reference/labelling.label_both.html#parameters",
    "title": "labelling.label_both",
    "section": "",
    "text": "label_info: strip_label_details\n\nLabel information to be modified.\n\nmulti_line: bool = True\n\nWhether to place each variable on a separate line\n\nsep: str = ‘:’\n\nSeparation between variable name and value"
  },
  {
    "objectID": "reference/labelling.label_both.html#returns",
    "href": "reference/labelling.label_both.html#returns",
    "title": "labelling.label_both",
    "section": "",
    "text": "out: strip_label_details\n\nLabel information"
  },
  {
    "objectID": "reference/index.html",
    "href": "reference/index.html",
    "title": "Function reference",
    "section": "",
    "text": "ggplot\nCreate a new ggplot object\n\n\nqplot\nQuick plot\n\n\nwatermark\nAdd watermark to plot\n\n\nlayer\n\n\n\nPlotnineAnimation\nAnimation using ggplot objects\n\n\nsave_as_pdf_pages\nSave multiple ggplot objects to a PDF file, one per page.\n\n\n\n\n\n\nAesthetics are the visual properties of a plot. The following functions control how the data (and calculations based on the data) is mapped to the aesthetics.\n\n\n\naes\nCreate aesthetic mappings\n\n\nafter_stat\nEvaluate mapping after statistic has been calculated\n\n\nafter_scale\nEvaluate mapping after variable has been mapped to the scale\n\n\nstage\nStage allows you evaluating mapping at more than one stage\n\n\n\n\n\n\nGeometric objects (geoms) are responsible for the visual representation of data points. geom_* classes determine the kind of geometric objects and every plot must have at least one geom added to it. The distinct visual aspects of the representation are controlled by the aes mapping.\n\n\n\ngeom\nBase class of all Geoms\n\n\n\n\n\n\ngeom_abline\nLines specified by slope and intercept\n\n\ngeom_area\nArea plot\n\n\ngeom_bar\nBar plot\n\n\ngeom_blank\nAn empty plot\n\n\ngeom_boxplot\nBox and whiskers plot\n\n\ngeom_col\nBar plot with base on the x-axis\n\n\ngeom_count\nPlot overlapping points\n\n\ngeom_crossbar\nVertical interval represented by a crossbar\n\n\ngeom_density\nSmooth density estimate\n\n\ngeom_density_2d\n2D density estimate\n\n\ngeom_dotplot\nDot plot\n\n\ngeom_errorbar\nVertical interval represented as an errorbar\n\n\ngeom_errorbarh\nHorizontal interval represented as an errorbar\n\n\ngeom_freqpoly\nFrequency polygon\n\n\ngeom_bin_2d\nHeatmap of 2d bin counts\n\n\ngeom_histogram\nHistogram\n\n\ngeom_hline\nHorizontal line\n\n\ngeom_jitter\nScatter plot with points jittered to reduce overplotting\n\n\ngeom_label\nTextual annotations with a background\n\n\ngeom_line\nConnected points\n\n\ngeom_linerange\nVertical interval represented by lines\n\n\ngeom_map\nDraw map feature\n\n\ngeom_path\nConnected points\n\n\ngeom_point\nPlot points (Scatter plot)\n\n\ngeom_pointdensity\nScatterplot with density estimation at each point\n\n\ngeom_pointrange\nVertical interval represented by a line with a point\n\n\ngeom_polygon\nPolygon, a filled path\n\n\ngeom_quantile\nQuantile lines from a quantile regression\n\n\ngeom_qq\nQuantile-Quantile plot\n\n\ngeom_qq_line\nQuantile-Quantile Line plot\n\n\ngeom_raster\nRasterized Rectangles specified using center points\n\n\ngeom_rect\nRectangles\n\n\ngeom_ribbon\nRibbon plot\n\n\ngeom_rug\nMarginal rug plot\n\n\ngeom_segment\nLine segments\n\n\ngeom_sina\nDraw a sina plot\n\n\ngeom_smooth\nA smoothed conditional mean\n\n\ngeom_spoke\nLine segment parameterised by location, direction and distance\n\n\ngeom_step\nStepped connected points\n\n\ngeom_text\nTextual annotations\n\n\ngeom_tile\nRectangles specified using a center points\n\n\ngeom_violin\nViolin Plot\n\n\ngeom_vline\nVertical line\n\n\n\n\n\n\n\n\nannotate\nCreate an annotation layer\n\n\nannotation_logticks\nMarginal log ticks.\n\n\nannotation_stripes\nAlternating stripes, centered around each label.\n\n\ngeom_path:arrow\nDefine arrow (actually an arrowhead)\n\n\n\n\n\n\n\n\n\nlabs\nAdd labels for aesthetics and/or title\n\n\nxlab\nCreate x-axis label\n\n\nylab\nCreate y-axis label\n\n\nggtitle\nCreate plot title\n\n\n\n\n\n\n\nStatistical transformations (stats) do aggregations and other computations on data before it is drawn out. stat_* determine the type of computation done on the data. Different types of computations yield varied results, so a stat must be paired with a geom that can represent all or some of the computations.\n\n\n\nstat\n\n\n\n\n\n\n\nstat_bin\nCount cases in each interval\n\n\nstat_bin_2d\n2 Dimensional bin counts\n\n\nstat_bindot\nBinning for a dot plot\n\n\nstat_boxplot\nCompute boxplot statistics\n\n\nstat_count\nCounts the number of cases at each x position\n\n\nstat_density\nCompute density estimate\n\n\nstat_density_2d\nCompute 2D kernel density estimation\n\n\nstat_ecdf\nEmperical Cumulative Density Function\n\n\nstat_ellipse\nCalculate normal confidence interval ellipse\n\n\nstat_function\nSuperimpose a function onto a plot\n\n\nstat_hull\n2 Dimensional Convex Hull\n\n\nstat_identity\nIdentity (do nothing) statistic\n\n\nstat_qq\nCalculation for quantile-quantile plot\n\n\nstat_qq_line\nCalculate line through quantile-quantile plot\n\n\nstat_quantile\nCompute quantile regression lines\n\n\nstat_sina\nCompute Sina plot values\n\n\nstat_smooth\nCalculate a smoothed conditional mean\n\n\nstat_sum\nSum unique values\n\n\nstat_summary\nCalculate summary statistics depending on x\n\n\nstat_summary_bin\nSummarise y values at x intervals\n\n\nstat_unique\nRemove duplicates\n\n\nstat_ydensity\nDensity estimate\n\n\n\n\n\n\nFaceting is a way to subset data and plot it on different panels.\n\n\n\nfacet\n\n\n\n\n\n\n\nfacet_grid\nWrap 1D Panels onto 2D surface\n\n\nfacet_null\nA single Panel\n\n\nfacet_wrap\nWrap 1D Panels onto 2D surface\n\n\nlabelling.labeller\nFacet Strip Labelling\n\n\nlabelling.as_labeller\nCoerse to labeller\n\n\nlabelling.label_value\nKeep value as the label\n\n\nlabelling.label_both\nConcatenate the facet variable with the value\n\n\nlabelling.label_context\nCreate an unabiguous label string\n\n\n\n\n\n\nScales control the mapping from data to aesthetics. They take data and adjust it to fit the different aspects of the visual sense i.e. length, colour, size and shape.\n\n\n\n\n\nscale\nBase class for all scales\n\n\nscale_discrete\nBase class for all discrete scales\n\n\nscale_continuous\nBase class for all continuous scales\n\n\nscale_datetime\nBase class for all date/datetime scales\n\n\n\n\n\n\n\n\n\nscale_alpha\nContinuous Alpha Scale\n\n\nscale_alpha_discrete\nDiscrete Alpha Scale\n\n\nscale_alpha_continuous\nContinuous Alpha Scale\n\n\nscale_alpha_datetime\nDatetime Alpha Scale\n\n\n\n\n\n\n\n\n\nscale_alpha_identity\nNo alpha scaling\n\n\nscale_color_identity\nNo color scaling\n\n\nscale_colour_identity\nNo color scaling\n\n\nscale_fill_identity\nNo color scaling\n\n\nscale_linetype_identity\nNo linetype scaling\n\n\nscale_shape_identity\nNo shape scaling\n\n\nscale_size_identity\nNo size scaling\n\n\n\n\n\n\n\n\n\nscale_color_brewer\nSequential, diverging and qualitative discrete color scales\n\n\nscale_color_continuous\nCreate color scales using Matplotlib colormaps\n\n\nscale_color_cmap\nCreate color scales using Matplotlib colormaps\n\n\nscale_color_desaturate\nCreate a desaturated color gradient\n\n\nscale_color_datetime\nDatetime color scale\n\n\nscale_color_discrete\nQualitative color scale with evenly spaced hues\n\n\nscale_color_distiller\nSequential and diverging continuous color scales\n\n\nscale_color_gradient\nCreate a 2 point color gradient\n\n\nscale_color_gradient2\nCreate a 3 point diverging color gradient\n\n\nscale_color_gradientn\nCreate a n color gradient\n\n\nscale_color_gray\nSequential grey color scale.\n\n\nscale_color_grey\nSequential grey color scale.\n\n\nscale_color_hue\nQualitative color scale with evenly spaced hues\n\n\nscale_fill_brewer\nSequential, diverging and qualitative color scales\n\n\nscale_fill_cmap\nCreate color scales using Matplotlib colormaps\n\n\nscale_fill_continuous\nCreate color scales using Matplotlib colormaps\n\n\nscale_fill_datetime\nDatetime fill scale\n\n\nscale_fill_desaturate\nCreate a desaturated color gradient\n\n\nscale_fill_discrete\nQualitative color scale with evenly spaced hues\n\n\nscale_fill_distiller\nSequential, diverging continuous color scales\n\n\nscale_fill_gradient\nCreate a 2 point color gradient\n\n\nscale_fill_gradient2\nCreate a 3 point diverging color gradient\n\n\nscale_fill_gradientn\nCreate a n color gradient\n\n\nscale_fill_gray\nSequential grey color scale.\n\n\nscale_fill_grey\nSequential grey color scale.\n\n\nscale_fill_hue\nQualitative color scale with evenly spaced hues\n\n\n\n\n\n\n\n\n\nscale_alpha_manual\nCustom discrete alpha scale\n\n\nscale_color_manual\nCustom discrete color scale\n\n\nscale_colour_manual\nCustom discrete color scale\n\n\nscale_fill_manual\nCustom discrete fill scale\n\n\nscale_linetype_manual\nCustom discrete linetype scale\n\n\nscale_shape_manual\nCustom discrete shape scale\n\n\nscale_size_manual\nCustom discrete size scale\n\n\n\n\n\n\n\n\n\nscale_linetype\nScale for line patterns\n\n\nscale_linetype_discrete\nScale for line patterns\n\n\n\n\n\n\n\n\n\nscale_shape\nScale for shapes\n\n\nscale_shape_discrete\nScale for shapes\n\n\n\n\n\n\n\n\n\nscale_size\nContinuous area size scale\n\n\nscale_size_area\nContinuous area size scale\n\n\nscale_size_continuous\nContinuous area size scale\n\n\nscale_size_discrete\nDiscrete area size scale\n\n\nscale_size_radius\nContinuous radius size scale\n\n\nscale_size_datetime\nDatetime area-size scale\n\n\n\n\n\n\n\n\n\nscale_x_continuous\nContinuous x position\n\n\nscale_x_date\nContinuous x position for datetime data points\n\n\nscale_x_datetime\nContinuous x position for datetime data points\n\n\nscale_x_discrete\nDiscrete x position\n\n\nscale_x_log10\nContinuous x position log10 transformed scale\n\n\nscale_x_reverse\nContinuous x position reverse transformed scale\n\n\nscale_x_sqrt\nContinuous x position sqrt transformed scale\n\n\nscale_x_timedelta\nContinuous x position for timedelta data points\n\n\nscale_y_continuous\nContinuous y position\n\n\nscale_y_date\nContinuous y position for datetime data points\n\n\nscale_y_datetime\nContinuous y position for datetime data points\n\n\nscale_y_discrete\nDiscrete y position\n\n\nscale_y_log10\nContinuous y position log10 transformed scale\n\n\nscale_y_reverse\nContinuous y position reverse transformed scale\n\n\nscale_y_sqrt\nContinuous y position sqrt transformed scale\n\n\nscale_y_timedelta\nContinuous y position for timedelta data points\n\n\n\n\n\n\n\n\n\nlims\nSet aesthetic limits\n\n\nxlim\nSet x-axis limits\n\n\nylim\nSet y-axis limits\n\n\nexpand_limits\nExpand the limits any aesthetic using data\n\n\n\n\n\n\n\n\n\nguides\nGuides for each scale\n\n\nguide\n\n\n\nguide_legend\nLegend guide\n\n\nguide_colorbar\nGuide colorbar\n\n\n\n\n\n\n\nOverlapping objects can be visualized better if their positions are adjusted. That is what the position_* class do. Each geom is associated with one position adjustment class.\n\n\n\nposition_dodge\nDodge overlaps and place objects side-by-side\n\n\nposition_dodge2\nDodge overlaps and place objects side-by-side\n\n\nposition_fill\nNormalise stacked objects to unit height\n\n\nposition_identity\nDo not adjust the position\n\n\nposition_jitter\nJitter points to avoid overplotting\n\n\nposition_jitterdodge\nDodge and jitter to minimise overlap\n\n\nposition_nudge\nNudge points\n\n\nposition_stack\nStack plotted objects on top of each other\n\n\n\n\n\n\nThemes control the visual appearance of the non-data elements the plot.\n\n\n\ntheme\nBase class for themes\n\n\ntheme_538\nTheme in the likeness of fivethirtyeight.com plots\n\n\ntheme_bw\nWhite background with black gridlines\n\n\ntheme_classic\nA classic-looking theme, with x & y axis lines and no gridlines\n\n\ntheme_dark\nThe dark cousin of theme_light\n\n\ntheme_gray\nA gray background with white gridlines.\n\n\ntheme_grey\nA gray background with white gridlines.\n\n\ntheme_light\nA theme similar to theme_linedraw\n\n\ntheme_linedraw\nA theme with only black lines of various widths on white backgrounds\n\n\ntheme_matplotlib\nThe default matplotlib look and feel.\n\n\ntheme_minimal\nA minimalistic theme with no background annotations\n\n\ntheme_seaborn\nTheme for seaborn.\n\n\ntheme_tufte\nTufte Maximal Data, Minimal Ink Theme\n\n\ntheme_void\nA classic-looking theme, with x & y axis lines and\n\n\ntheme_xkcd\nxkcd theme\n\n\n\n\n\nThese define aspects of a plot that can be themed. They can be used to create a new theme or modify an existing theme. They define the keyword arguments to theme. Users should never create instances of themeable.\n\n\n\naspect_ratio\nAspect ratio of the panel(s)\n\n\naxis_line\nx & y axis lines\n\n\naxis_line_x\nx-axis line\n\n\naxis_line_y\ny-axis line\n\n\naxis_text\nAxis tick labels\n\n\naxis_text_x\nx-axis tick labels\n\n\naxis_text_y\ny-axis tick labels\n\n\naxis_ticks\nx & y major and minor axis tick lines\n\n\naxis_ticks_direction\naxis tick direction\n\n\naxis_ticks_direction_x\nx-axis tick direction\n\n\naxis_ticks_direction_y\ny-axis tick direction\n\n\naxis_ticks_length\nAxis tick length\n\n\naxis_ticks_length_major\nAxis major-tick length\n\n\naxis_ticks_length_minor\nAxis minor-tick length\n\n\naxis_ticks_major\nx & y axis major tick lines\n\n\naxis_line\nx & y axis lines\n\n\naxis_line_x\nx-axis line\n\n\naxis_line_y\ny-axis line\n\n\naxis_text\nAxis tick labels\n\n\naxis_text_x\nx-axis tick labels\n\n\naxis_text_y\ny-axis tick labels\n\n\naxis_ticks\nx & y major and minor axis tick lines\n\n\naxis_ticks_direction\naxis tick direction\n\n\naxis_ticks_direction_x\nx-axis tick direction\n\n\naxis_ticks_direction_y\ny-axis tick direction\n\n\naxis_ticks_length\nAxis tick length\n\n\naxis_ticks_length_major\nAxis major-tick length\n\n\naxis_ticks_length_minor\nAxis minor-tick length\n\n\naxis_ticks_major\nx & y axis major tick lines\n\n\naxis_ticks_major_x\nx-axis major tick lines\n\n\naxis_ticks_major_y\ny-axis major tick lines\n\n\naxis_ticks_minor\nx & y axis minor tick lines\n\n\naxis_ticks_minor_x\nx-axis tick lines\n\n\naxis_ticks_minor_y\ny-axis minor tick lines\n\n\naxis_ticks_pad\nAxis tick padding\n\n\naxis_ticks_pad_major\nAxis major-tick padding\n\n\naxis_ticks_pad_minor\nAxis minor-tick padding\n\n\naxis_title\nAxis labels\n\n\naxis_title_x\nx axis label\n\n\naxis_title_y\ny axis label\n\n\ndpi\nDPI with which to draw/save the figure\n\n\nfigure_size\nFigure size in inches\n\n\nlegend_background\nLegend background\n\n\nlegend_box\nHow to box up multiple legends\n\n\nlegend_box_background\nLegend box background\n\n\nlegend_box_just\nJustification of legend boxes\n\n\nlegend_box_margin\nPadding between the legends and the box\n\n\nlegend_box_spacing\nSpacing between the legend and the plotting area\n\n\nlegend_direction\nLayout items in the legend\n\n\nlegend_entry_spacing\nSpacing between two entries in a legend\n\n\nlegend_entry_spacing_x\nHorizontal spacing between two entries in a legend\n\n\nlegend_entry_spacing_y\nVertical spacing between two entries in a legend\n\n\nlegend_key\nLegend key background\n\n\nlegend_key_height\nLegend key background height\n\n\nlegend_key_size\nLegend key background width and height\n\n\nlegend_key_width\nLegend key background width\n\n\nlegend_margin\nPadding between the legend and the inner box\n\n\nlegend_position\nLocation of legend\n\n\nlegend_spacing\nSpacing between two adjacent legends\n\n\nlegend_text\nLegend text\n\n\nlegend_text_colorbar\nColorbar text\n\n\nlegend_text_legend\nLegend text for the common legend\n\n\nlegend_title\nLegend title\n\n\nlegend_title_align\nAlignment of legend title\n\n\nline\nAll line elements\n\n\npanel_background\nPanel background\n\n\npanel_border\nPanel border\n\n\npanel_grid\nGrid lines\n\n\npanel_grid_major\nMajor grid lines\n\n\npanel_grid_major_x\nVertical major grid lines\n\n\npanel_grid_major_y\nHorizontal major grid lines\n\n\npanel_grid_minor\nMinor grid lines\n\n\npanel_grid_minor_x\nVertical minor grid lines\n\n\npanel_grid_minor_y\nHorizontal minor grid lines\n\n\npanel_ontop\nPlace panel background & gridlines over/under the data layers\n\n\npanel_spacing\nSpacing between the facet panels\n\n\npanel_spacing_x\nHorizontal spacing between the facet panels\n\n\npanel_spacing_y\nVertical spacing between the facet panels\n\n\nplot_background\nPlot background\n\n\nplot_margin\nPlot Margin\n\n\nplot_title\nPlot title\n\n\nrect\nAll rectangle elements\n\n\nstrip_background\nFacet label background\n\n\nstrip_background_x\nHorizontal facet label background\n\n\nstrip_background_y\nVertical facet label background\n\n\nstrip_align\nAlignment of the strip & its background w.r.t the panel border\n\n\nstrip_align_x\nVertical alignment of the strip & its background w.r.t the panel border\n\n\nstrip_align_y\nHorizontal alignment of the strip & its background w.r.t the panel border\n\n\nstrip_text\nFacet labels along both axes\n\n\nstrip_text_x\nFacet labels along the horizontal axis\n\n\nstrip_text_y\nFacet labels along the vertical axis\n\n\ntext\nAll text elements in the plot\n\n\ntitle\nAll titles on the plot\n\n\nthemeable\nAbstract class of things that can be themed.\n\n\n\n\n\n\n\n\n\ntheme_set\nChange the current(default) theme\n\n\ntheme_get\nReturn the default theme\n\n\ntheme_update\nModify elements of the current theme\n\n\nelement_line\ntheme element: line\n\n\nelement_rect\nTheme element: Rectangle\n\n\nelement_text\nTheme element: Text\n\n\n\n\n\n\n\nCoordinate systems put together the two position scales to produce a 2d location.\n\n\n\ncoord_cartesian\nCartesian coordinate system\n\n\ncoord_equal\nCartesian coordinates with fixed relationship between x and y scales\n\n\ncoord_fixed\nCartesian coordinates with fixed relationship between x and y scales\n\n\ncoord_flip\nFlipped cartesian coordinates\n\n\ncoord_trans\nTransformed cartesian coordinate system\n\n\n\n\n\n\nWhen working interactively, some of the options make it convenient to create plots that have a common look and feel. Another way to do it, to set a default theme using theme_set().\n\n\n\naspect_ratio\n\n\n\nbase_family\n\n\n\nbase_margin\n\n\n\nclose_all_figures\n\n\n\ncurrent_theme\n\n\n\ndpi\n\n\n\nfigure_size\n\n\n\nget_option\nGet package option\n\n\nset_option\nSet package option\n\n\n\n\n\n\nThese datasets ship with the plotnine and you can import them with from the plotnine.data sub-package.\n\n\n\ndiamonds\nPrices of 50,000 round cut diamonds\n\n\neconomics\nUS economic time series.\n\n\neconomics_long\nUS economic time series.\n\n\nfaithful\nOld Faithful Geyser Data\n\n\nfaithfuld\nOld Faithful Geyser Data\n\n\nhuron\nLevel of Lake Huron 1875–1972\n\n\nluv_colours\ncolors in Luv space.\n\n\nmeat\n\n\n\nmidwest\nMidwest demographics.\n\n\nmpg\nFuel economy data from 1999 and 2008 for 38 popular models of car\n\n\nmsleep\nAn updated and expanded version of the mammals sleep dataset.\n\n\nmtcars\nMotor Trend Car Road Tests\n\n\npageviews\n\n\n\npresidential\nTerms of 11 presidents from Eisenhower to Obama.\n\n\nseals\nVector field of seal movements.\n\n\ntxhousing\nHousing sales in TX."
  },
  {
    "objectID": "reference/index.html#plot-creation",
    "href": "reference/index.html#plot-creation",
    "title": "Function reference",
    "section": "",
    "text": "ggplot\nCreate a new ggplot object\n\n\nqplot\nQuick plot\n\n\nwatermark\nAdd watermark to plot\n\n\nlayer\n\n\n\nPlotnineAnimation\nAnimation using ggplot objects\n\n\nsave_as_pdf_pages\nSave multiple ggplot objects to a PDF file, one per page."
  },
  {
    "objectID": "reference/index.html#mapping-aesthetics",
    "href": "reference/index.html#mapping-aesthetics",
    "title": "Function reference",
    "section": "",
    "text": "Aesthetics are the visual properties of a plot. The following functions control how the data (and calculations based on the data) is mapped to the aesthetics.\n\n\n\naes\nCreate aesthetic mappings\n\n\nafter_stat\nEvaluate mapping after statistic has been calculated\n\n\nafter_scale\nEvaluate mapping after variable has been mapped to the scale\n\n\nstage\nStage allows you evaluating mapping at more than one stage"
  },
  {
    "objectID": "reference/index.html#geoms",
    "href": "reference/index.html#geoms",
    "title": "Function reference",
    "section": "",
    "text": "Geometric objects (geoms) are responsible for the visual representation of data points. geom_* classes determine the kind of geometric objects and every plot must have at least one geom added to it. The distinct visual aspects of the representation are controlled by the aes mapping.\n\n\n\ngeom\nBase class of all Geoms\n\n\n\n\n\n\ngeom_abline\nLines specified by slope and intercept\n\n\ngeom_area\nArea plot\n\n\ngeom_bar\nBar plot\n\n\ngeom_blank\nAn empty plot\n\n\ngeom_boxplot\nBox and whiskers plot\n\n\ngeom_col\nBar plot with base on the x-axis\n\n\ngeom_count\nPlot overlapping points\n\n\ngeom_crossbar\nVertical interval represented by a crossbar\n\n\ngeom_density\nSmooth density estimate\n\n\ngeom_density_2d\n2D density estimate\n\n\ngeom_dotplot\nDot plot\n\n\ngeom_errorbar\nVertical interval represented as an errorbar\n\n\ngeom_errorbarh\nHorizontal interval represented as an errorbar\n\n\ngeom_freqpoly\nFrequency polygon\n\n\ngeom_bin_2d\nHeatmap of 2d bin counts\n\n\ngeom_histogram\nHistogram\n\n\ngeom_hline\nHorizontal line\n\n\ngeom_jitter\nScatter plot with points jittered to reduce overplotting\n\n\ngeom_label\nTextual annotations with a background\n\n\ngeom_line\nConnected points\n\n\ngeom_linerange\nVertical interval represented by lines\n\n\ngeom_map\nDraw map feature\n\n\ngeom_path\nConnected points\n\n\ngeom_point\nPlot points (Scatter plot)\n\n\ngeom_pointdensity\nScatterplot with density estimation at each point\n\n\ngeom_pointrange\nVertical interval represented by a line with a point\n\n\ngeom_polygon\nPolygon, a filled path\n\n\ngeom_quantile\nQuantile lines from a quantile regression\n\n\ngeom_qq\nQuantile-Quantile plot\n\n\ngeom_qq_line\nQuantile-Quantile Line plot\n\n\ngeom_raster\nRasterized Rectangles specified using center points\n\n\ngeom_rect\nRectangles\n\n\ngeom_ribbon\nRibbon plot\n\n\ngeom_rug\nMarginal rug plot\n\n\ngeom_segment\nLine segments\n\n\ngeom_sina\nDraw a sina plot\n\n\ngeom_smooth\nA smoothed conditional mean\n\n\ngeom_spoke\nLine segment parameterised by location, direction and distance\n\n\ngeom_step\nStepped connected points\n\n\ngeom_text\nTextual annotations\n\n\ngeom_tile\nRectangles specified using a center points\n\n\ngeom_violin\nViolin Plot\n\n\ngeom_vline\nVertical line\n\n\n\n\n\n\n\n\nannotate\nCreate an annotation layer\n\n\nannotation_logticks\nMarginal log ticks.\n\n\nannotation_stripes\nAlternating stripes, centered around each label.\n\n\ngeom_path:arrow\nDefine arrow (actually an arrowhead)\n\n\n\n\n\n\n\n\n\nlabs\nAdd labels for aesthetics and/or title\n\n\nxlab\nCreate x-axis label\n\n\nylab\nCreate y-axis label\n\n\nggtitle\nCreate plot title"
  },
  {
    "objectID": "reference/index.html#stats",
    "href": "reference/index.html#stats",
    "title": "Function reference",
    "section": "",
    "text": "Statistical transformations (stats) do aggregations and other computations on data before it is drawn out. stat_* determine the type of computation done on the data. Different types of computations yield varied results, so a stat must be paired with a geom that can represent all or some of the computations.\n\n\n\nstat\n\n\n\n\n\n\n\nstat_bin\nCount cases in each interval\n\n\nstat_bin_2d\n2 Dimensional bin counts\n\n\nstat_bindot\nBinning for a dot plot\n\n\nstat_boxplot\nCompute boxplot statistics\n\n\nstat_count\nCounts the number of cases at each x position\n\n\nstat_density\nCompute density estimate\n\n\nstat_density_2d\nCompute 2D kernel density estimation\n\n\nstat_ecdf\nEmperical Cumulative Density Function\n\n\nstat_ellipse\nCalculate normal confidence interval ellipse\n\n\nstat_function\nSuperimpose a function onto a plot\n\n\nstat_hull\n2 Dimensional Convex Hull\n\n\nstat_identity\nIdentity (do nothing) statistic\n\n\nstat_qq\nCalculation for quantile-quantile plot\n\n\nstat_qq_line\nCalculate line through quantile-quantile plot\n\n\nstat_quantile\nCompute quantile regression lines\n\n\nstat_sina\nCompute Sina plot values\n\n\nstat_smooth\nCalculate a smoothed conditional mean\n\n\nstat_sum\nSum unique values\n\n\nstat_summary\nCalculate summary statistics depending on x\n\n\nstat_summary_bin\nSummarise y values at x intervals\n\n\nstat_unique\nRemove duplicates\n\n\nstat_ydensity\nDensity estimate"
  },
  {
    "objectID": "reference/index.html#facets",
    "href": "reference/index.html#facets",
    "title": "Function reference",
    "section": "",
    "text": "Faceting is a way to subset data and plot it on different panels.\n\n\n\nfacet\n\n\n\n\n\n\n\nfacet_grid\nWrap 1D Panels onto 2D surface\n\n\nfacet_null\nA single Panel\n\n\nfacet_wrap\nWrap 1D Panels onto 2D surface\n\n\nlabelling.labeller\nFacet Strip Labelling\n\n\nlabelling.as_labeller\nCoerse to labeller\n\n\nlabelling.label_value\nKeep value as the label\n\n\nlabelling.label_both\nConcatenate the facet variable with the value\n\n\nlabelling.label_context\nCreate an unabiguous label string"
  },
  {
    "objectID": "reference/index.html#scales",
    "href": "reference/index.html#scales",
    "title": "Function reference",
    "section": "",
    "text": "Scales control the mapping from data to aesthetics. They take data and adjust it to fit the different aspects of the visual sense i.e. length, colour, size and shape.\n\n\n\n\n\nscale\nBase class for all scales\n\n\nscale_discrete\nBase class for all discrete scales\n\n\nscale_continuous\nBase class for all continuous scales\n\n\nscale_datetime\nBase class for all date/datetime scales\n\n\n\n\n\n\n\n\n\nscale_alpha\nContinuous Alpha Scale\n\n\nscale_alpha_discrete\nDiscrete Alpha Scale\n\n\nscale_alpha_continuous\nContinuous Alpha Scale\n\n\nscale_alpha_datetime\nDatetime Alpha Scale\n\n\n\n\n\n\n\n\n\nscale_alpha_identity\nNo alpha scaling\n\n\nscale_color_identity\nNo color scaling\n\n\nscale_colour_identity\nNo color scaling\n\n\nscale_fill_identity\nNo color scaling\n\n\nscale_linetype_identity\nNo linetype scaling\n\n\nscale_shape_identity\nNo shape scaling\n\n\nscale_size_identity\nNo size scaling\n\n\n\n\n\n\n\n\n\nscale_color_brewer\nSequential, diverging and qualitative discrete color scales\n\n\nscale_color_continuous\nCreate color scales using Matplotlib colormaps\n\n\nscale_color_cmap\nCreate color scales using Matplotlib colormaps\n\n\nscale_color_desaturate\nCreate a desaturated color gradient\n\n\nscale_color_datetime\nDatetime color scale\n\n\nscale_color_discrete\nQualitative color scale with evenly spaced hues\n\n\nscale_color_distiller\nSequential and diverging continuous color scales\n\n\nscale_color_gradient\nCreate a 2 point color gradient\n\n\nscale_color_gradient2\nCreate a 3 point diverging color gradient\n\n\nscale_color_gradientn\nCreate a n color gradient\n\n\nscale_color_gray\nSequential grey color scale.\n\n\nscale_color_grey\nSequential grey color scale.\n\n\nscale_color_hue\nQualitative color scale with evenly spaced hues\n\n\nscale_fill_brewer\nSequential, diverging and qualitative color scales\n\n\nscale_fill_cmap\nCreate color scales using Matplotlib colormaps\n\n\nscale_fill_continuous\nCreate color scales using Matplotlib colormaps\n\n\nscale_fill_datetime\nDatetime fill scale\n\n\nscale_fill_desaturate\nCreate a desaturated color gradient\n\n\nscale_fill_discrete\nQualitative color scale with evenly spaced hues\n\n\nscale_fill_distiller\nSequential, diverging continuous color scales\n\n\nscale_fill_gradient\nCreate a 2 point color gradient\n\n\nscale_fill_gradient2\nCreate a 3 point diverging color gradient\n\n\nscale_fill_gradientn\nCreate a n color gradient\n\n\nscale_fill_gray\nSequential grey color scale.\n\n\nscale_fill_grey\nSequential grey color scale.\n\n\nscale_fill_hue\nQualitative color scale with evenly spaced hues\n\n\n\n\n\n\n\n\n\nscale_alpha_manual\nCustom discrete alpha scale\n\n\nscale_color_manual\nCustom discrete color scale\n\n\nscale_colour_manual\nCustom discrete color scale\n\n\nscale_fill_manual\nCustom discrete fill scale\n\n\nscale_linetype_manual\nCustom discrete linetype scale\n\n\nscale_shape_manual\nCustom discrete shape scale\n\n\nscale_size_manual\nCustom discrete size scale\n\n\n\n\n\n\n\n\n\nscale_linetype\nScale for line patterns\n\n\nscale_linetype_discrete\nScale for line patterns\n\n\n\n\n\n\n\n\n\nscale_shape\nScale for shapes\n\n\nscale_shape_discrete\nScale for shapes\n\n\n\n\n\n\n\n\n\nscale_size\nContinuous area size scale\n\n\nscale_size_area\nContinuous area size scale\n\n\nscale_size_continuous\nContinuous area size scale\n\n\nscale_size_discrete\nDiscrete area size scale\n\n\nscale_size_radius\nContinuous radius size scale\n\n\nscale_size_datetime\nDatetime area-size scale\n\n\n\n\n\n\n\n\n\nscale_x_continuous\nContinuous x position\n\n\nscale_x_date\nContinuous x position for datetime data points\n\n\nscale_x_datetime\nContinuous x position for datetime data points\n\n\nscale_x_discrete\nDiscrete x position\n\n\nscale_x_log10\nContinuous x position log10 transformed scale\n\n\nscale_x_reverse\nContinuous x position reverse transformed scale\n\n\nscale_x_sqrt\nContinuous x position sqrt transformed scale\n\n\nscale_x_timedelta\nContinuous x position for timedelta data points\n\n\nscale_y_continuous\nContinuous y position\n\n\nscale_y_date\nContinuous y position for datetime data points\n\n\nscale_y_datetime\nContinuous y position for datetime data points\n\n\nscale_y_discrete\nDiscrete y position\n\n\nscale_y_log10\nContinuous y position log10 transformed scale\n\n\nscale_y_reverse\nContinuous y position reverse transformed scale\n\n\nscale_y_sqrt\nContinuous y position sqrt transformed scale\n\n\nscale_y_timedelta\nContinuous y position for timedelta data points\n\n\n\n\n\n\n\n\n\nlims\nSet aesthetic limits\n\n\nxlim\nSet x-axis limits\n\n\nylim\nSet y-axis limits\n\n\nexpand_limits\nExpand the limits any aesthetic using data\n\n\n\n\n\n\n\n\n\nguides\nGuides for each scale\n\n\nguide\n\n\n\nguide_legend\nLegend guide\n\n\nguide_colorbar\nGuide colorbar"
  },
  {
    "objectID": "reference/index.html#positions",
    "href": "reference/index.html#positions",
    "title": "Function reference",
    "section": "",
    "text": "Overlapping objects can be visualized better if their positions are adjusted. That is what the position_* class do. Each geom is associated with one position adjustment class.\n\n\n\nposition_dodge\nDodge overlaps and place objects side-by-side\n\n\nposition_dodge2\nDodge overlaps and place objects side-by-side\n\n\nposition_fill\nNormalise stacked objects to unit height\n\n\nposition_identity\nDo not adjust the position\n\n\nposition_jitter\nJitter points to avoid overplotting\n\n\nposition_jitterdodge\nDodge and jitter to minimise overlap\n\n\nposition_nudge\nNudge points\n\n\nposition_stack\nStack plotted objects on top of each other"
  },
  {
    "objectID": "reference/index.html#themes",
    "href": "reference/index.html#themes",
    "title": "Function reference",
    "section": "",
    "text": "Themes control the visual appearance of the non-data elements the plot.\n\n\n\ntheme\nBase class for themes\n\n\ntheme_538\nTheme in the likeness of fivethirtyeight.com plots\n\n\ntheme_bw\nWhite background with black gridlines\n\n\ntheme_classic\nA classic-looking theme, with x & y axis lines and no gridlines\n\n\ntheme_dark\nThe dark cousin of theme_light\n\n\ntheme_gray\nA gray background with white gridlines.\n\n\ntheme_grey\nA gray background with white gridlines.\n\n\ntheme_light\nA theme similar to theme_linedraw\n\n\ntheme_linedraw\nA theme with only black lines of various widths on white backgrounds\n\n\ntheme_matplotlib\nThe default matplotlib look and feel.\n\n\ntheme_minimal\nA minimalistic theme with no background annotations\n\n\ntheme_seaborn\nTheme for seaborn.\n\n\ntheme_tufte\nTufte Maximal Data, Minimal Ink Theme\n\n\ntheme_void\nA classic-looking theme, with x & y axis lines and\n\n\ntheme_xkcd\nxkcd theme\n\n\n\n\n\nThese define aspects of a plot that can be themed. They can be used to create a new theme or modify an existing theme. They define the keyword arguments to theme. Users should never create instances of themeable.\n\n\n\naspect_ratio\nAspect ratio of the panel(s)\n\n\naxis_line\nx & y axis lines\n\n\naxis_line_x\nx-axis line\n\n\naxis_line_y\ny-axis line\n\n\naxis_text\nAxis tick labels\n\n\naxis_text_x\nx-axis tick labels\n\n\naxis_text_y\ny-axis tick labels\n\n\naxis_ticks\nx & y major and minor axis tick lines\n\n\naxis_ticks_direction\naxis tick direction\n\n\naxis_ticks_direction_x\nx-axis tick direction\n\n\naxis_ticks_direction_y\ny-axis tick direction\n\n\naxis_ticks_length\nAxis tick length\n\n\naxis_ticks_length_major\nAxis major-tick length\n\n\naxis_ticks_length_minor\nAxis minor-tick length\n\n\naxis_ticks_major\nx & y axis major tick lines\n\n\naxis_line\nx & y axis lines\n\n\naxis_line_x\nx-axis line\n\n\naxis_line_y\ny-axis line\n\n\naxis_text\nAxis tick labels\n\n\naxis_text_x\nx-axis tick labels\n\n\naxis_text_y\ny-axis tick labels\n\n\naxis_ticks\nx & y major and minor axis tick lines\n\n\naxis_ticks_direction\naxis tick direction\n\n\naxis_ticks_direction_x\nx-axis tick direction\n\n\naxis_ticks_direction_y\ny-axis tick direction\n\n\naxis_ticks_length\nAxis tick length\n\n\naxis_ticks_length_major\nAxis major-tick length\n\n\naxis_ticks_length_minor\nAxis minor-tick length\n\n\naxis_ticks_major\nx & y axis major tick lines\n\n\naxis_ticks_major_x\nx-axis major tick lines\n\n\naxis_ticks_major_y\ny-axis major tick lines\n\n\naxis_ticks_minor\nx & y axis minor tick lines\n\n\naxis_ticks_minor_x\nx-axis tick lines\n\n\naxis_ticks_minor_y\ny-axis minor tick lines\n\n\naxis_ticks_pad\nAxis tick padding\n\n\naxis_ticks_pad_major\nAxis major-tick padding\n\n\naxis_ticks_pad_minor\nAxis minor-tick padding\n\n\naxis_title\nAxis labels\n\n\naxis_title_x\nx axis label\n\n\naxis_title_y\ny axis label\n\n\ndpi\nDPI with which to draw/save the figure\n\n\nfigure_size\nFigure size in inches\n\n\nlegend_background\nLegend background\n\n\nlegend_box\nHow to box up multiple legends\n\n\nlegend_box_background\nLegend box background\n\n\nlegend_box_just\nJustification of legend boxes\n\n\nlegend_box_margin\nPadding between the legends and the box\n\n\nlegend_box_spacing\nSpacing between the legend and the plotting area\n\n\nlegend_direction\nLayout items in the legend\n\n\nlegend_entry_spacing\nSpacing between two entries in a legend\n\n\nlegend_entry_spacing_x\nHorizontal spacing between two entries in a legend\n\n\nlegend_entry_spacing_y\nVertical spacing between two entries in a legend\n\n\nlegend_key\nLegend key background\n\n\nlegend_key_height\nLegend key background height\n\n\nlegend_key_size\nLegend key background width and height\n\n\nlegend_key_width\nLegend key background width\n\n\nlegend_margin\nPadding between the legend and the inner box\n\n\nlegend_position\nLocation of legend\n\n\nlegend_spacing\nSpacing between two adjacent legends\n\n\nlegend_text\nLegend text\n\n\nlegend_text_colorbar\nColorbar text\n\n\nlegend_text_legend\nLegend text for the common legend\n\n\nlegend_title\nLegend title\n\n\nlegend_title_align\nAlignment of legend title\n\n\nline\nAll line elements\n\n\npanel_background\nPanel background\n\n\npanel_border\nPanel border\n\n\npanel_grid\nGrid lines\n\n\npanel_grid_major\nMajor grid lines\n\n\npanel_grid_major_x\nVertical major grid lines\n\n\npanel_grid_major_y\nHorizontal major grid lines\n\n\npanel_grid_minor\nMinor grid lines\n\n\npanel_grid_minor_x\nVertical minor grid lines\n\n\npanel_grid_minor_y\nHorizontal minor grid lines\n\n\npanel_ontop\nPlace panel background & gridlines over/under the data layers\n\n\npanel_spacing\nSpacing between the facet panels\n\n\npanel_spacing_x\nHorizontal spacing between the facet panels\n\n\npanel_spacing_y\nVertical spacing between the facet panels\n\n\nplot_background\nPlot background\n\n\nplot_margin\nPlot Margin\n\n\nplot_title\nPlot title\n\n\nrect\nAll rectangle elements\n\n\nstrip_background\nFacet label background\n\n\nstrip_background_x\nHorizontal facet label background\n\n\nstrip_background_y\nVertical facet label background\n\n\nstrip_align\nAlignment of the strip & its background w.r.t the panel border\n\n\nstrip_align_x\nVertical alignment of the strip & its background w.r.t the panel border\n\n\nstrip_align_y\nHorizontal alignment of the strip & its background w.r.t the panel border\n\n\nstrip_text\nFacet labels along both axes\n\n\nstrip_text_x\nFacet labels along the horizontal axis\n\n\nstrip_text_y\nFacet labels along the vertical axis\n\n\ntext\nAll text elements in the plot\n\n\ntitle\nAll titles on the plot\n\n\nthemeable\nAbstract class of things that can be themed.\n\n\n\n\n\n\n\n\n\ntheme_set\nChange the current(default) theme\n\n\ntheme_get\nReturn the default theme\n\n\ntheme_update\nModify elements of the current theme\n\n\nelement_line\ntheme element: line\n\n\nelement_rect\nTheme element: Rectangle\n\n\nelement_text\nTheme element: Text"
  },
  {
    "objectID": "reference/index.html#coordinates",
    "href": "reference/index.html#coordinates",
    "title": "Function reference",
    "section": "",
    "text": "Coordinate systems put together the two position scales to produce a 2d location.\n\n\n\ncoord_cartesian\nCartesian coordinate system\n\n\ncoord_equal\nCartesian coordinates with fixed relationship between x and y scales\n\n\ncoord_fixed\nCartesian coordinates with fixed relationship between x and y scales\n\n\ncoord_flip\nFlipped cartesian coordinates\n\n\ncoord_trans\nTransformed cartesian coordinate system"
  },
  {
    "objectID": "reference/index.html#options",
    "href": "reference/index.html#options",
    "title": "Function reference",
    "section": "",
    "text": "When working interactively, some of the options make it convenient to create plots that have a common look and feel. Another way to do it, to set a default theme using theme_set().\n\n\n\naspect_ratio\n\n\n\nbase_family\n\n\n\nbase_margin\n\n\n\nclose_all_figures\n\n\n\ncurrent_theme\n\n\n\ndpi\n\n\n\nfigure_size\n\n\n\nget_option\nGet package option\n\n\nset_option\nSet package option"
  },
  {
    "objectID": "reference/index.html#datasets",
    "href": "reference/index.html#datasets",
    "title": "Function reference",
    "section": "",
    "text": "These datasets ship with the plotnine and you can import them with from the plotnine.data sub-package.\n\n\n\ndiamonds\nPrices of 50,000 round cut diamonds\n\n\neconomics\nUS economic time series.\n\n\neconomics_long\nUS economic time series.\n\n\nfaithful\nOld Faithful Geyser Data\n\n\nfaithfuld\nOld Faithful Geyser Data\n\n\nhuron\nLevel of Lake Huron 1875–1972\n\n\nluv_colours\ncolors in Luv space.\n\n\nmeat\n\n\n\nmidwest\nMidwest demographics.\n\n\nmpg\nFuel economy data from 1999 and 2008 for 38 popular models of car\n\n\nmsleep\nAn updated and expanded version of the mammals sleep dataset.\n\n\nmtcars\nMotor Trend Car Road Tests\n\n\npageviews\n\n\n\npresidential\nTerms of 11 presidents from Eisenhower to Obama.\n\n\nseals\nVector field of seal movements.\n\n\ntxhousing\nHousing sales in TX."
  },
  {
    "objectID": "reference/guides.html",
    "href": "reference/guides.html",
    "title": "guides",
    "section": "",
    "text": "guides.guides(self, **kwargs)\n\n\nGuides for each scale\nUsed to assign a particular guide to an aesthetic(s).\n\n\n\n\nkwargs: dict = {}\n\naesthetic - guide pairings. e.g\nguides(color=guide_colorbar())"
  },
  {
    "objectID": "reference/guides.html#parameters",
    "href": "reference/guides.html#parameters",
    "title": "guides",
    "section": "",
    "text": "kwargs: dict = {}\n\naesthetic - guide pairings. e.g\nguides(color=guide_colorbar())"
  },
  {
    "objectID": "reference/guide_colorbar.html",
    "href": "reference/guide_colorbar.html",
    "title": "guide_colorbar",
    "section": "",
    "text": "guides.guide_colorbar()\n\n\nGuide colorbar\n\n\n\n\nbarwidth: float = None\n\nWidth (in pixels) of the colorbar. If None, the legend_key_width is used. The value is multiplied by 1.45.\n\nbarheight: float = None\n\nHeight (in pixels) of the colorbar. legend_key_height is used. The value is multiplied by 5 * 1.45.\n\nnbin: int = 20\n\nNumber of bins for drawing a colorbar. A larger value yields a smoother colorbar\n\nraster: bool = False\n\nWhether to render the colorbar as a raster object.\n\nticks: bool = True\n\nWhether tick marks on colorbar should be visible.\n\ndraw_ulim: bool = True\n\nWhether to show the upper limit tick marks.\n\ndraw_llim: bool = TRue\n\nWhether to show the lower limit tick marks.\n\ndirection: ‘horizontal’ | ‘vertical’ = “horizontal”\n\nDirection of the guide.\n\nkwargs: dict\n\nParameters passed on to :class:.guide"
  },
  {
    "objectID": "reference/guide_colorbar.html#parameters",
    "href": "reference/guide_colorbar.html#parameters",
    "title": "guide_colorbar",
    "section": "",
    "text": "barwidth: float = None\n\nWidth (in pixels) of the colorbar. If None, the legend_key_width is used. The value is multiplied by 1.45.\n\nbarheight: float = None\n\nHeight (in pixels) of the colorbar. legend_key_height is used. The value is multiplied by 5 * 1.45.\n\nnbin: int = 20\n\nNumber of bins for drawing a colorbar. A larger value yields a smoother colorbar\n\nraster: bool = False\n\nWhether to render the colorbar as a raster object.\n\nticks: bool = True\n\nWhether tick marks on colorbar should be visible.\n\ndraw_ulim: bool = True\n\nWhether to show the upper limit tick marks.\n\ndraw_llim: bool = TRue\n\nWhether to show the lower limit tick marks.\n\ndirection: ‘horizontal’ | ‘vertical’ = “horizontal”\n\nDirection of the guide.\n\nkwargs: dict\n\nParameters passed on to :class:.guide"
  },
  {
    "objectID": "reference/ggtitle.html",
    "href": "reference/ggtitle.html",
    "title": "ggtitle",
    "section": "",
    "text": "labels.ggtitle(self, title)\n\n\nCreate plot title\n\n\n\n\ntitle: str\n\nPlot title"
  },
  {
    "objectID": "reference/ggtitle.html#parameters",
    "href": "reference/ggtitle.html#parameters",
    "title": "ggtitle",
    "section": "",
    "text": "title: str\n\nPlot title"
  },
  {
    "objectID": "reference/get_option.html",
    "href": "reference/get_option.html",
    "title": "get_option",
    "section": "",
    "text": "options.get_option(name)\n\n\nGet package option\n\n\n\n\nname: str\n\nName of the option"
  },
  {
    "objectID": "reference/get_option.html#parameters",
    "href": "reference/get_option.html#parameters",
    "title": "get_option",
    "section": "",
    "text": "name: str\n\nName of the option"
  },
  {
    "objectID": "reference/geom_violin.html",
    "href": "reference/geom_violin.html",
    "title": "geom_violin",
    "section": "",
    "text": "geoms.geom_violin(self, mapping=None, data=None, **kwargs)\n\n\nViolin Plot\nUsage\ngeom_violin(mapping=None, data=None, stat='ydensity', position='dodge',\n            na_rm=False, inherit_aes=True, show_legend=None, raster=False,\n            draw_quantiles=None, width=None, scale='area', trim=True,\n            style='full', **kwargs)\nOnly the data and mapping can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the stat.\n\n\n\n\nmapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\n'#333333'\n\n\n\n\nfill\n\n\n'white'\n\n\n\n\ngroup\n\n\n\n\n\n\nlinetype\n\n\n'solid'\n\n\n\n\nsize\n\n\n0.5\n\n\n\n\nweight\n\n\n1\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “ydensity”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “dodge”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\ndraw_quantiles: float | list[float] = None\n\ndraw horizontal lines at the given quantiles (0..1) of the density estimate.\n\nstyle: str = “full”\n\nThe type of violin plot to draw. The options are:\n'full'        # Regular (2 sided violins)\n'left'        # Left-sided half violins\n'right'       # Right-sided half violins\n'left-right'  # Alternate (left first) half violins by the group\n'right-left'  # Alternate (right first) half violins by the group"
  },
  {
    "objectID": "reference/geom_violin.html#parameters",
    "href": "reference/geom_violin.html#parameters",
    "title": "geom_violin",
    "section": "",
    "text": "mapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\n'#333333'\n\n\n\n\nfill\n\n\n'white'\n\n\n\n\ngroup\n\n\n\n\n\n\nlinetype\n\n\n'solid'\n\n\n\n\nsize\n\n\n0.5\n\n\n\n\nweight\n\n\n1\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “ydensity”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “dodge”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\ndraw_quantiles: float | list[float] = None\n\ndraw horizontal lines at the given quantiles (0..1) of the density estimate.\n\nstyle: str = “full”\n\nThe type of violin plot to draw. The options are:\n'full'        # Regular (2 sided violins)\n'left'        # Left-sided half violins\n'right'       # Right-sided half violins\n'left-right'  # Alternate (left first) half violins by the group\n'right-left'  # Alternate (right first) half violins by the group"
  },
  {
    "objectID": "reference/geom_text.html",
    "href": "reference/geom_text.html",
    "title": "geom_text",
    "section": "",
    "text": "geoms.geom_text(self, mapping=None, data=None, **kwargs)\n\n\nTextual annotations\nUsage\ngeom_text(mapping=None, data=None, stat='identity', position='identity',\n          na_rm=False, inherit_aes=True, show_legend=None, raster=False,\n          fontweight='normal', nudge_y=0, adjust_text=None, parse=False,\n          fontstyle='normal', family=None, format_string=None,\n          path_effects=None, nudge_x=0, **kwargs)\nOnly the data and mapping can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the stat.\n\n\n\n\nmapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nlabel\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\nangle\n\n\n0\n\n\n\n\ncolor\n\n\n'black'\n\n\n\n\ngroup\n\n\n\n\n\n\nha\n\n\n'center'\n\n\n\n\nlineheight\n\n\n1.2\n\n\n\n\nsize\n\n\n11\n\n\n\n\nva\n\n\n'center'\n\n\n\n\nThe bold aesthetics are required.\nAesthetics Descriptions\n\nha\n\nHorizontal alignment. One of left, center or right.\n\nva\n\nVertical alignment. One of top, center, bottom, baseline.\n\n\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “identity”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\nparse: bool = False\n\nIf True, the labels will be rendered with latex.\n\nfamily: str = None\n\nFont family.\n\nfontweight: int | str = “normal”\n\nFont weight.\n\nfontstyle: ‘normal’ | ‘italic’ | ‘oblique’ = “normal”\n\nFont style.\n\nnudge_x: float = 0\n\nHorizontal adjustment to apply to the text\n\nnudge_y: float = 0\n\nVertical adjustment to apply to the text\n\nadjust_text\n\nParameters to :class:adjustText.adjust_text will repel overlapping texts. This parameter takes priority of over nudge_x and nudge_y. adjust_text does not work well when it is used in the first layer of the plot, or if it is the only layer. For more see the documentation at https://github.com/Phlya/adjustText/wiki .\n\nformat_string: str = None\n\nIf not None, then the text is formatted with this string using :meth:str.format e.g:\n# 2.348 -&gt; \"2.35%\"\ngeom_text(format_string=\"{:.2f}%\")\n\npath_effects: list = None\n\nIf not None, then the text will use these effects. See  documentation for more details.\n\n\n\n\n\n\nplotnine.geoms.geom_label\n\n\n\nmatplotlib.text.Text\n\n\n\nmatplotlib.patheffects"
  },
  {
    "objectID": "reference/geom_text.html#parameters",
    "href": "reference/geom_text.html#parameters",
    "title": "geom_text",
    "section": "",
    "text": "mapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nlabel\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\nangle\n\n\n0\n\n\n\n\ncolor\n\n\n'black'\n\n\n\n\ngroup\n\n\n\n\n\n\nha\n\n\n'center'\n\n\n\n\nlineheight\n\n\n1.2\n\n\n\n\nsize\n\n\n11\n\n\n\n\nva\n\n\n'center'\n\n\n\n\nThe bold aesthetics are required.\nAesthetics Descriptions\n\nha\n\nHorizontal alignment. One of left, center or right.\n\nva\n\nVertical alignment. One of top, center, bottom, baseline.\n\n\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “identity”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\nparse: bool = False\n\nIf True, the labels will be rendered with latex.\n\nfamily: str = None\n\nFont family.\n\nfontweight: int | str = “normal”\n\nFont weight.\n\nfontstyle: ‘normal’ | ‘italic’ | ‘oblique’ = “normal”\n\nFont style.\n\nnudge_x: float = 0\n\nHorizontal adjustment to apply to the text\n\nnudge_y: float = 0\n\nVertical adjustment to apply to the text\n\nadjust_text\n\nParameters to :class:adjustText.adjust_text will repel overlapping texts. This parameter takes priority of over nudge_x and nudge_y. adjust_text does not work well when it is used in the first layer of the plot, or if it is the only layer. For more see the documentation at https://github.com/Phlya/adjustText/wiki .\n\nformat_string: str = None\n\nIf not None, then the text is formatted with this string using :meth:str.format e.g:\n# 2.348 -&gt; \"2.35%\"\ngeom_text(format_string=\"{:.2f}%\")\n\npath_effects: list = None\n\nIf not None, then the text will use these effects. See  documentation for more details."
  },
  {
    "objectID": "reference/geom_text.html#see-also",
    "href": "reference/geom_text.html#see-also",
    "title": "geom_text",
    "section": "",
    "text": "plotnine.geoms.geom_label\n\n\n\nmatplotlib.text.Text\n\n\n\nmatplotlib.patheffects"
  },
  {
    "objectID": "reference/geom_spoke.html",
    "href": "reference/geom_spoke.html",
    "title": "geom_spoke",
    "section": "",
    "text": "geoms.geom_spoke()\n\n\nLine segment parameterised by location, direction and distance\nUsage\ngeom_spoke(mapping=None, data=None, stat='identity', position='identity',\n           na_rm=False, inherit_aes=True, show_legend=None, raster=False,\n           lineend='butt', arrow=None, **kwargs)\nOnly the data and mapping can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the stat.\n\n\n\n\nmapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nangle\n\n\n\n\n\n\nradius\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\n'black'\n\n\n\n\ngroup\n\n\n\n\n\n\nlinetype\n\n\n'solid'\n\n\n\n\nsize\n\n\n0.5\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “identity”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\n\n\n\n\n\nplotnine.geoms.geom_segment\n\nFor documentation of extra parameters."
  },
  {
    "objectID": "reference/geom_spoke.html#parameters",
    "href": "reference/geom_spoke.html#parameters",
    "title": "geom_spoke",
    "section": "",
    "text": "mapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nangle\n\n\n\n\n\n\nradius\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\n'black'\n\n\n\n\ngroup\n\n\n\n\n\n\nlinetype\n\n\n'solid'\n\n\n\n\nsize\n\n\n0.5\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “identity”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format."
  },
  {
    "objectID": "reference/geom_spoke.html#see-also",
    "href": "reference/geom_spoke.html#see-also",
    "title": "geom_spoke",
    "section": "",
    "text": "plotnine.geoms.geom_segment\n\nFor documentation of extra parameters."
  },
  {
    "objectID": "reference/geom_sina.html",
    "href": "reference/geom_sina.html",
    "title": "geom_sina",
    "section": "",
    "text": "geoms.geom_sina()\n\n\nDraw a sina plot\nA sina plot is a data visualization chart suitable for plotting any single variable in a multiclass dataset. It is an enhanced jitter strip chart, where the width of the jitter is controlled by the density distribution of the data within each class.\nUsage\ngeom_sina(mapping=None, data=None, stat='sina', position='dodge', na_rm=False,\n          inherit_aes=True, show_legend=None, raster=False, **kwargs)\nOnly the data and mapping can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the stat.\n\n\n\n\nmapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\n'black'\n\n\n\n\nfill\n\n\nNone\n\n\n\n\ngroup\n\n\n\n\n\n\nshape\n\n\n'o'\n\n\n\n\nsize\n\n\n1.5\n\n\n\n\nstroke\n\n\n0.5\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “sina”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “dodge”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\n\n\n\n\n\nplotnine.stats.stat_sina\n\n\n\n\n\n\n\nSidiropoulos, N., S. H. Sohi, T. L. Pedersen, B. T. Porse, O. Winther, N. Rapin, and F. O. Bagger. 2018. “SinaPlot: An Enhanced Chart for Simple and Truthful Representation of Single Observations over Multiple Classes.” J. Comp. Graph. Stat 27: 673–76."
  },
  {
    "objectID": "reference/geom_sina.html#parameters",
    "href": "reference/geom_sina.html#parameters",
    "title": "geom_sina",
    "section": "",
    "text": "mapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\n'black'\n\n\n\n\nfill\n\n\nNone\n\n\n\n\ngroup\n\n\n\n\n\n\nshape\n\n\n'o'\n\n\n\n\nsize\n\n\n1.5\n\n\n\n\nstroke\n\n\n0.5\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “sina”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “dodge”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format."
  },
  {
    "objectID": "reference/geom_sina.html#see-also",
    "href": "reference/geom_sina.html#see-also",
    "title": "geom_sina",
    "section": "",
    "text": "plotnine.stats.stat_sina"
  },
  {
    "objectID": "reference/geom_sina.html#references",
    "href": "reference/geom_sina.html#references",
    "title": "geom_sina",
    "section": "",
    "text": "Sidiropoulos, N., S. H. Sohi, T. L. Pedersen, B. T. Porse, O. Winther, N. Rapin, and F. O. Bagger. 2018. “SinaPlot: An Enhanced Chart for Simple and Truthful Representation of Single Observations over Multiple Classes.” J. Comp. Graph. Stat 27: 673–76."
  },
  {
    "objectID": "reference/geom_rug.html",
    "href": "reference/geom_rug.html",
    "title": "geom_rug",
    "section": "",
    "text": "geoms.geom_rug()\n\n\nMarginal rug plot\nUsage\ngeom_rug(mapping=None, data=None, stat='identity', position='identity',\n         na_rm=False, inherit_aes=True, show_legend=None, raster=False,\n         sides='bl', length=0.03, **kwargs)\nOnly the data and mapping can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the stat.\n\n\n\n\nmapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\n'black'\n\n\n\n\ngroup\n\n\n\n\n\n\nlinetype\n\n\n'solid'\n\n\n\n\nsize\n\n\n0.5\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “identity”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\nsides: str = “bl”\n\nSides onto which to draw the marks. Any combination chosen from the characters \"btlr\", for bottom, top, left or right side marks.\n\nlength\n\nlength of marks in fractions of horizontal/vertical panel size."
  },
  {
    "objectID": "reference/geom_rug.html#parameters",
    "href": "reference/geom_rug.html#parameters",
    "title": "geom_rug",
    "section": "",
    "text": "mapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\n'black'\n\n\n\n\ngroup\n\n\n\n\n\n\nlinetype\n\n\n'solid'\n\n\n\n\nsize\n\n\n0.5\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “identity”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\nsides: str = “bl”\n\nSides onto which to draw the marks. Any combination chosen from the characters \"btlr\", for bottom, top, left or right side marks.\n\nlength\n\nlength of marks in fractions of horizontal/vertical panel size."
  },
  {
    "objectID": "reference/geom_rect.html",
    "href": "reference/geom_rect.html",
    "title": "geom_rect",
    "section": "",
    "text": "geoms.geom_rect()\n\n\nRectangles\nUsage\ngeom_rect(mapping=None, data=None, stat='identity', position='identity',\n          na_rm=False, inherit_aes=True, show_legend=None, raster=False,\n          **kwargs)\nOnly the data and mapping can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the stat.\n\n\n\n\nmapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nxmax\n\n\n\n\n\n\nxmin\n\n\n\n\n\n\nymax\n\n\n\n\n\n\nymin\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\nNone\n\n\n\n\nfill\n\n\n'#595959'\n\n\n\n\ngroup\n\n\n\n\n\n\nlinetype\n\n\n'solid'\n\n\n\n\nsize\n\n\n0.5\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “identity”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format."
  },
  {
    "objectID": "reference/geom_rect.html#parameters",
    "href": "reference/geom_rect.html#parameters",
    "title": "geom_rect",
    "section": "",
    "text": "mapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nxmax\n\n\n\n\n\n\nxmin\n\n\n\n\n\n\nymax\n\n\n\n\n\n\nymin\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\nNone\n\n\n\n\nfill\n\n\n'#595959'\n\n\n\n\ngroup\n\n\n\n\n\n\nlinetype\n\n\n'solid'\n\n\n\n\nsize\n\n\n0.5\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “identity”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format."
  },
  {
    "objectID": "reference/geom_quantile.html",
    "href": "reference/geom_quantile.html",
    "title": "geom_quantile",
    "section": "",
    "text": "geoms.geom_quantile()\n\n\nQuantile lines from a quantile regression\nUsage\ngeom_quantile(mapping=None, data=None, stat='quantile', position='identity',\n              na_rm=False, inherit_aes=True, show_legend=None, raster=False,\n              lineend='butt', linejoin='round', **kwargs)\nOnly the data and mapping can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the stat.\n\n\n\n\nmapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\n'#3366FF'\n\n\n\n\ngroup\n\n\n\n\n\n\nlinetype\n\n\n'solid'\n\n\n\n\nsize\n\n\n0.5\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “quantile”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\nlineend: butt | round | projecting = “butt”\n\nLine end style. This option is applied for solid linetypes.\n\nlinejoin: round | miter | bevel = “round”\n\nLine join style. This option is applied for solid linetypes."
  },
  {
    "objectID": "reference/geom_quantile.html#parameters",
    "href": "reference/geom_quantile.html#parameters",
    "title": "geom_quantile",
    "section": "",
    "text": "mapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\n'#3366FF'\n\n\n\n\ngroup\n\n\n\n\n\n\nlinetype\n\n\n'solid'\n\n\n\n\nsize\n\n\n0.5\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “quantile”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\nlineend: butt | round | projecting = “butt”\n\nLine end style. This option is applied for solid linetypes.\n\nlinejoin: round | miter | bevel = “round”\n\nLine join style. This option is applied for solid linetypes."
  },
  {
    "objectID": "reference/geom_qq.html",
    "href": "reference/geom_qq.html",
    "title": "geom_qq",
    "section": "",
    "text": "geoms.geom_qq()\n\n\nQuantile-Quantile plot\nUsage\ngeom_qq(mapping=None, data=None, stat='qq', position='identity', na_rm=False,\n        inherit_aes=True, show_legend=None, raster=False, **kwargs)\nOnly the data and mapping can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the stat.\n\n\n\n\nmapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\n'black'\n\n\n\n\nfill\n\n\nNone\n\n\n\n\ngroup\n\n\n\n\n\n\nshape\n\n\n'o'\n\n\n\n\nsize\n\n\n1.5\n\n\n\n\nstroke\n\n\n0.5\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “qq”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format."
  },
  {
    "objectID": "reference/geom_qq.html#parameters",
    "href": "reference/geom_qq.html#parameters",
    "title": "geom_qq",
    "section": "",
    "text": "mapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\n'black'\n\n\n\n\nfill\n\n\nNone\n\n\n\n\ngroup\n\n\n\n\n\n\nshape\n\n\n'o'\n\n\n\n\nsize\n\n\n1.5\n\n\n\n\nstroke\n\n\n0.5\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “qq”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format."
  },
  {
    "objectID": "reference/geom_pointrange.html",
    "href": "reference/geom_pointrange.html",
    "title": "geom_pointrange",
    "section": "",
    "text": "geoms.geom_pointrange()\n\n\nVertical interval represented by a line with a point\nUsage\ngeom_pointrange(mapping=None, data=None, stat='identity', position='identity',\n                na_rm=False, inherit_aes=True, show_legend=None, raster=False,\n                fatten=4, **kwargs)\nOnly the data and mapping can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the stat.\n\n\n\n\nmapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nymax\n\n\n\n\n\n\nymin\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\n'black'\n\n\n\n\nfill\n\n\nNone\n\n\n\n\ngroup\n\n\n\n\n\n\nlinetype\n\n\n'solid'\n\n\n\n\nshape\n\n\n'o'\n\n\n\n\nsize\n\n\n0.5\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “identity”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\nfatten: float = 2\n\nA multiplicative factor used to increase the size of the point along the line-range."
  },
  {
    "objectID": "reference/geom_pointrange.html#parameters",
    "href": "reference/geom_pointrange.html#parameters",
    "title": "geom_pointrange",
    "section": "",
    "text": "mapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nymax\n\n\n\n\n\n\nymin\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\n'black'\n\n\n\n\nfill\n\n\nNone\n\n\n\n\ngroup\n\n\n\n\n\n\nlinetype\n\n\n'solid'\n\n\n\n\nshape\n\n\n'o'\n\n\n\n\nsize\n\n\n0.5\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “identity”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\nfatten: float = 2\n\nA multiplicative factor used to increase the size of the point along the line-range."
  },
  {
    "objectID": "reference/geom_point.html",
    "href": "reference/geom_point.html",
    "title": "geom_point",
    "section": "",
    "text": "geoms.geom_point()\n\n\nPlot points (Scatter plot)\nUsage\ngeom_point(mapping=None, data=None, stat='identity', position='identity',\n           na_rm=False, inherit_aes=True, show_legend=None, raster=False,\n           **kwargs)\nOnly the data and mapping can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the stat.\n\n\n\n\nmapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\n'black'\n\n\n\n\nfill\n\n\nNone\n\n\n\n\ngroup\n\n\n\n\n\n\nshape\n\n\n'o'\n\n\n\n\nsize\n\n\n1.5\n\n\n\n\nstroke\n\n\n0.5\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “identity”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format."
  },
  {
    "objectID": "reference/geom_point.html#parameters",
    "href": "reference/geom_point.html#parameters",
    "title": "geom_point",
    "section": "",
    "text": "mapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\n'black'\n\n\n\n\nfill\n\n\nNone\n\n\n\n\ngroup\n\n\n\n\n\n\nshape\n\n\n'o'\n\n\n\n\nsize\n\n\n1.5\n\n\n\n\nstroke\n\n\n0.5\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “identity”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format."
  },
  {
    "objectID": "reference/geom_path.html",
    "href": "reference/geom_path.html",
    "title": "geom_path",
    "section": "",
    "text": "geoms.geom_path()\n\n\nConnected points\nUsage\ngeom_path(mapping=None, data=None, stat='identity', position='identity',\n          na_rm=False, inherit_aes=True, show_legend=None, raster=False,\n          lineend='butt', arrow=None, linejoin='round', **kwargs)\nOnly the data and mapping can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the stat.\n\n\n\n\nmapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\n'black'\n\n\n\n\ngroup\n\n\n\n\n\n\nlinetype\n\n\n'solid'\n\n\n\n\nsize\n\n\n0.5\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “identity”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\nlineend: ‘butt’ | ‘round’ | ‘projecting’ = “butt”\n\nLine end style. This option is applied for solid linetypes.\n\nlinejoin: ‘round’ | ‘miter’ | ‘bevel’ = “round”\n\nLine join style. This option is applied for solid linetypes.\n\narrow: ~plotnine.geoms.geom_path.arrow = None\n\nArrow specification. Default is no arrow.\n\n\n\n\n\n\nplotnine.geoms.arrow\n\nfor adding arrowhead(s) to paths."
  },
  {
    "objectID": "reference/geom_path.html#parameters",
    "href": "reference/geom_path.html#parameters",
    "title": "geom_path",
    "section": "",
    "text": "mapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\n'black'\n\n\n\n\ngroup\n\n\n\n\n\n\nlinetype\n\n\n'solid'\n\n\n\n\nsize\n\n\n0.5\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “identity”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\nlineend: ‘butt’ | ‘round’ | ‘projecting’ = “butt”\n\nLine end style. This option is applied for solid linetypes.\n\nlinejoin: ‘round’ | ‘miter’ | ‘bevel’ = “round”\n\nLine join style. This option is applied for solid linetypes.\n\narrow: ~plotnine.geoms.geom_path.arrow = None\n\nArrow specification. Default is no arrow."
  },
  {
    "objectID": "reference/geom_path.html#see-also",
    "href": "reference/geom_path.html#see-also",
    "title": "geom_path",
    "section": "",
    "text": "plotnine.geoms.arrow\n\nfor adding arrowhead(s) to paths."
  },
  {
    "objectID": "reference/geom_linerange.html",
    "href": "reference/geom_linerange.html",
    "title": "geom_linerange",
    "section": "",
    "text": "geoms.geom_linerange()\n\n\nVertical interval represented by lines\nUsage\ngeom_linerange(mapping=None, data=None, stat='identity', position='identity',\n               na_rm=False, inherit_aes=True, show_legend=None, raster=False,\n               **kwargs)\nOnly the data and mapping can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the stat.\n\n\n\n\nmapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\nymax\n\n\n\n\n\n\nymin\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\n'black'\n\n\n\n\ngroup\n\n\n\n\n\n\nlinetype\n\n\n'solid'\n\n\n\n\nsize\n\n\n0.5\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “identity”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format."
  },
  {
    "objectID": "reference/geom_linerange.html#parameters",
    "href": "reference/geom_linerange.html#parameters",
    "title": "geom_linerange",
    "section": "",
    "text": "mapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\nymax\n\n\n\n\n\n\nymin\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\n'black'\n\n\n\n\ngroup\n\n\n\n\n\n\nlinetype\n\n\n'solid'\n\n\n\n\nsize\n\n\n0.5\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “identity”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format."
  },
  {
    "objectID": "reference/geom_label.html",
    "href": "reference/geom_label.html",
    "title": "geom_label",
    "section": "",
    "text": "geoms.geom_label()\n\n\nTextual annotations with a background\nUsage\ngeom_label(mapping=None, data=None, stat='identity', position='identity',\n           na_rm=False, inherit_aes=True, show_legend=None, raster=False,\n           fontweight='normal', nudge_y=0, label_size=0.7, adjust_text=None,\n           parse=False, label_padding=0.25, fontstyle='normal', family=None,\n           boxcolor=None, format_string=None, path_effects=None,\n           tooth_size=None, label_r=0.25, boxstyle='round', nudge_x=0,\n           **kwargs)\nOnly the data and mapping can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the stat.\n\n\n\n\nmapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nlabel\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\nangle\n\n\n0\n\n\n\n\ncolor\n\n\n'black'\n\n\n\n\nfill\n\n\n'white'\n\n\n\n\ngroup\n\n\n\n\n\n\nha\n\n\n'center'\n\n\n\n\nlineheight\n\n\n1.2\n\n\n\n\nsize\n\n\n11\n\n\n\n\nva\n\n\n'center'\n\n\n\n\nThe bold aesthetics are required.\nAesthetics Descriptions\n\nha\n\nHorizontal alignment. One of left, center or right.\n\nva\n\nVertical alignment. One of top, center, bottom, baseline.\n\n\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “identity”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\nboxstyle: str = “round”\n\nOptions are:\n'circle'\n'darrow'\n'larrow'\n'rarrow'\n'round '\n'round4'\n'roundtooth'\n'sawtooth'\n'square'\n\nboxcolor\n\nColor of box around the text. If None, the color is the same as the text.\n\nlabel_padding: float = 0.25\n\nAmount of padding\n\nlabel_r: float = 0.25\n\nRounding radius of corners.\n\nlabel_size: float = 0.7\n\nLinewidth of the label boundary.\n\ntooth_size: float = None\n\nSize of the roundtooth or sawtooth if they are the chosen boxstyle. The default depends on Matplotlib\n\n\n\n\n\n\nplotnine.geoms.geom_text\n\nFor documentation of the parameters. :class:matplotlib.patches.BoxStyle for the parameters that affect the boxstyle."
  },
  {
    "objectID": "reference/geom_label.html#parameters",
    "href": "reference/geom_label.html#parameters",
    "title": "geom_label",
    "section": "",
    "text": "mapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nlabel\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\nangle\n\n\n0\n\n\n\n\ncolor\n\n\n'black'\n\n\n\n\nfill\n\n\n'white'\n\n\n\n\ngroup\n\n\n\n\n\n\nha\n\n\n'center'\n\n\n\n\nlineheight\n\n\n1.2\n\n\n\n\nsize\n\n\n11\n\n\n\n\nva\n\n\n'center'\n\n\n\n\nThe bold aesthetics are required.\nAesthetics Descriptions\n\nha\n\nHorizontal alignment. One of left, center or right.\n\nva\n\nVertical alignment. One of top, center, bottom, baseline.\n\n\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “identity”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\nboxstyle: str = “round”\n\nOptions are:\n'circle'\n'darrow'\n'larrow'\n'rarrow'\n'round '\n'round4'\n'roundtooth'\n'sawtooth'\n'square'\n\nboxcolor\n\nColor of box around the text. If None, the color is the same as the text.\n\nlabel_padding: float = 0.25\n\nAmount of padding\n\nlabel_r: float = 0.25\n\nRounding radius of corners.\n\nlabel_size: float = 0.7\n\nLinewidth of the label boundary.\n\ntooth_size: float = None\n\nSize of the roundtooth or sawtooth if they are the chosen boxstyle. The default depends on Matplotlib"
  },
  {
    "objectID": "reference/geom_label.html#see-also",
    "href": "reference/geom_label.html#see-also",
    "title": "geom_label",
    "section": "",
    "text": "plotnine.geoms.geom_text\n\nFor documentation of the parameters. :class:matplotlib.patches.BoxStyle for the parameters that affect the boxstyle."
  },
  {
    "objectID": "reference/geom_hline.html",
    "href": "reference/geom_hline.html",
    "title": "geom_hline",
    "section": "",
    "text": "geoms.geom_hline(self, mapping=None, data=None, **kwargs)\n\n\nHorizontal line\nUsage\ngeom_hline(mapping=None, data=None, stat='identity', position='identity',\n           na_rm=False, inherit_aes=False, show_legend=None, raster=False,\n           **kwargs)\nOnly the data and mapping can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the stat.\n\n\n\n\nmapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nyintercept\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\n'black'\n\n\n\n\ngroup\n\n\n\n\n\n\nlinetype\n\n\n'solid'\n\n\n\n\nsize\n\n\n0.5\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “identity”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = False\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format."
  },
  {
    "objectID": "reference/geom_hline.html#parameters",
    "href": "reference/geom_hline.html#parameters",
    "title": "geom_hline",
    "section": "",
    "text": "mapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nyintercept\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\n'black'\n\n\n\n\ngroup\n\n\n\n\n\n\nlinetype\n\n\n'solid'\n\n\n\n\nsize\n\n\n0.5\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “identity”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = False\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format."
  },
  {
    "objectID": "reference/geom_freqpoly.html",
    "href": "reference/geom_freqpoly.html",
    "title": "geom_freqpoly",
    "section": "",
    "text": "geom_freqpoly\n\ngeoms.geom_freqpoly()\n\n\nFrequency polygon\nUsage\ngeom_freqpoly(mapping=None, data=None, stat='bin', position='identity',\n              na_rm=False, inherit_aes=True, show_legend=None, raster=False,\n              lineend='butt', arrow=None, linejoin='round', **kwargs)\nOnly the data and mapping can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the stat.\nSee geom_path for documentation of the parameters."
  },
  {
    "objectID": "reference/geom_errorbar.html",
    "href": "reference/geom_errorbar.html",
    "title": "geom_errorbar",
    "section": "",
    "text": "geoms.geom_errorbar()\n\n\nVertical interval represented as an errorbar\nUsage\ngeom_errorbar(mapping=None, data=None, stat='identity', position='identity',\n              na_rm=False, inherit_aes=True, show_legend=None, raster=False,\n              width=0.5, **kwargs)\nOnly the data and mapping can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the stat.\n\n\n\n\nmapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\nymax\n\n\n\n\n\n\nymin\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\n'black'\n\n\n\n\ngroup\n\n\n\n\n\n\nlinetype\n\n\n'solid'\n\n\n\n\nsize\n\n\n0.5\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “identity”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\nwidth: float = 0.5\n\nBar width as a fraction of the resolution of the data."
  },
  {
    "objectID": "reference/geom_errorbar.html#parameters",
    "href": "reference/geom_errorbar.html#parameters",
    "title": "geom_errorbar",
    "section": "",
    "text": "mapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\nymax\n\n\n\n\n\n\nymin\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\n'black'\n\n\n\n\ngroup\n\n\n\n\n\n\nlinetype\n\n\n'solid'\n\n\n\n\nsize\n\n\n0.5\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “identity”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\nwidth: float = 0.5\n\nBar width as a fraction of the resolution of the data."
  },
  {
    "objectID": "reference/geom_density_2d.html",
    "href": "reference/geom_density_2d.html",
    "title": "geom_density_2d",
    "section": "",
    "text": "geoms.geom_density_2d()\n\n\n2D density estimate\nThis is a 2d version of geom_density.\nUsage\ngeom_density_2d(mapping=None, data=None, stat='density_2d',\n                position='identity', na_rm=False, inherit_aes=True,\n                show_legend=None, raster=False, **kwargs)\nOnly the data and mapping can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the stat.\n\n\n\n\nmapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\n'black'\n\n\n\n\ngroup\n\n\n\n\n\n\nlinetype\n\n\n'solid'\n\n\n\n\nsize\n\n\n0.5\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “density_2d”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format."
  },
  {
    "objectID": "reference/geom_density_2d.html#parameters",
    "href": "reference/geom_density_2d.html#parameters",
    "title": "geom_density_2d",
    "section": "",
    "text": "mapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\n'black'\n\n\n\n\ngroup\n\n\n\n\n\n\nlinetype\n\n\n'solid'\n\n\n\n\nsize\n\n\n0.5\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “density_2d”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format."
  },
  {
    "objectID": "reference/geom_crossbar.html",
    "href": "reference/geom_crossbar.html",
    "title": "geom_crossbar",
    "section": "",
    "text": "geoms.geom_crossbar()\n\n\nVertical interval represented by a crossbar\nUsage\ngeom_crossbar(mapping=None, data=None, stat='identity', position='identity',\n              na_rm=False, inherit_aes=True, show_legend=None, raster=False,\n              width=0.5, fatten=2, **kwargs)\nOnly the data and mapping can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the stat.\n\n\n\n\nmapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nymax\n\n\n\n\n\n\nymin\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\n'black'\n\n\n\n\nfill\n\n\nNone\n\n\n\n\ngroup\n\n\n\n\n\n\nlinetype\n\n\n'solid'\n\n\n\n\nsize\n\n\n0.5\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “identity”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\nwidth: float = 0.5\n\nBox width as a fraction of the resolution of the data.\n\nfatten: float = 2\n\nA multiplicative factor used to increase the size of the middle bar across the box."
  },
  {
    "objectID": "reference/geom_crossbar.html#parameters",
    "href": "reference/geom_crossbar.html#parameters",
    "title": "geom_crossbar",
    "section": "",
    "text": "mapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nymax\n\n\n\n\n\n\nymin\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\n'black'\n\n\n\n\nfill\n\n\nNone\n\n\n\n\ngroup\n\n\n\n\n\n\nlinetype\n\n\n'solid'\n\n\n\n\nsize\n\n\n0.5\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “identity”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\nwidth: float = 0.5\n\nBox width as a fraction of the resolution of the data.\n\nfatten: float = 2\n\nA multiplicative factor used to increase the size of the middle bar across the box."
  },
  {
    "objectID": "reference/geom_col.html",
    "href": "reference/geom_col.html",
    "title": "geom_col",
    "section": "",
    "text": "geoms.geom_col()\n\n\nBar plot with base on the x-axis\nThis is an alternate version of geom_bar that maps the height of bars to an existing variable in your data. If you want the height of the bar to represent a count of cases, use geom_bar.\nUsage\ngeom_col(mapping=None, data=None, stat='identity', position='stack',\n         na_rm=False, inherit_aes=True, show_legend=None, raster=False,\n         width=None, **kwargs)\nOnly the data and mapping can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the stat.\n\n\n\n\nmapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\nNone\n\n\n\n\nfill\n\n\n'#595959'\n\n\n\n\ngroup\n\n\n\n\n\n\nlinetype\n\n\n'solid'\n\n\n\n\nsize\n\n\n0.5\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “identity”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “stack”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\nwidth: float = None\n\nBar width. If None, the width is set to 90% of the resolution of the data.\n\n\n\n\n\n\nplotnine.geoms.geom_bar"
  },
  {
    "objectID": "reference/geom_col.html#parameters",
    "href": "reference/geom_col.html#parameters",
    "title": "geom_col",
    "section": "",
    "text": "mapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\nNone\n\n\n\n\nfill\n\n\n'#595959'\n\n\n\n\ngroup\n\n\n\n\n\n\nlinetype\n\n\n'solid'\n\n\n\n\nsize\n\n\n0.5\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “identity”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “stack”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\nwidth: float = None\n\nBar width. If None, the width is set to 90% of the resolution of the data."
  },
  {
    "objectID": "reference/geom_col.html#see-also",
    "href": "reference/geom_col.html#see-also",
    "title": "geom_col",
    "section": "",
    "text": "plotnine.geoms.geom_bar"
  },
  {
    "objectID": "reference/geom_blank.html",
    "href": "reference/geom_blank.html",
    "title": "geom_blank",
    "section": "",
    "text": "geoms.geom_blank()\n\n\nAn empty plot\nUsage\ngeom_blank(mapping=None, data=None, stat='identity', position='identity',\n           na_rm=False, inherit_aes=True, show_legend=None, raster=False,\n           **kwargs)\nOnly the data and mapping can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the stat.\n\n\n\n\nmapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “identity”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format."
  },
  {
    "objectID": "reference/geom_blank.html#parameters",
    "href": "reference/geom_blank.html#parameters",
    "title": "geom_blank",
    "section": "",
    "text": "mapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “identity”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format."
  },
  {
    "objectID": "reference/geom_bar.html",
    "href": "reference/geom_bar.html",
    "title": "geom_bar",
    "section": "",
    "text": "geoms.geom_bar()\n\n\nBar plot\nUsage\ngeom_bar(mapping=None, data=None, stat='count', position='stack', na_rm=False,\n         inherit_aes=True, show_legend=None, raster=False, width=None,\n         **kwargs)\nOnly the data and mapping can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the stat.\n\n\n\n\nmapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\nNone\n\n\n\n\nfill\n\n\n'#595959'\n\n\n\n\ngroup\n\n\n\n\n\n\nlinetype\n\n\n'solid'\n\n\n\n\nsize\n\n\n0.5\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “count”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “stack”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\nwidth: float = None\n\nBar width. If None, the width is set to 90% of the resolution of the data.\n\n\n\n\n\n\nplotnine.geoms.geom_histogram"
  },
  {
    "objectID": "reference/geom_bar.html#parameters",
    "href": "reference/geom_bar.html#parameters",
    "title": "geom_bar",
    "section": "",
    "text": "mapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\nNone\n\n\n\n\nfill\n\n\n'#595959'\n\n\n\n\ngroup\n\n\n\n\n\n\nlinetype\n\n\n'solid'\n\n\n\n\nsize\n\n\n0.5\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “count”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “stack”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\nwidth: float = None\n\nBar width. If None, the width is set to 90% of the resolution of the data."
  },
  {
    "objectID": "reference/geom_bar.html#see-also",
    "href": "reference/geom_bar.html#see-also",
    "title": "geom_bar",
    "section": "",
    "text": "plotnine.geoms.geom_histogram"
  },
  {
    "objectID": "reference/geom_abline.html",
    "href": "reference/geom_abline.html",
    "title": "geom_abline",
    "section": "",
    "text": "geoms.geom_abline(self, mapping=None, data=None, **kwargs)\n\n\nLines specified by slope and intercept\nUsage\ngeom_abline(mapping=None, data=None, stat='identity', position='identity',\n            na_rm=False, inherit_aes=False, show_legend=None, raster=False,\n            **kwargs)\nOnly the data and mapping can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the stat.\n\n\n\n\nmapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nintercept\n\n\n\n\n\n\nslope\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\n'black'\n\n\n\n\ngroup\n\n\n\n\n\n\nlinetype\n\n\n'solid'\n\n\n\n\nsize\n\n\n0.5\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “identity”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = False\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format."
  },
  {
    "objectID": "reference/geom_abline.html#parameters",
    "href": "reference/geom_abline.html#parameters",
    "title": "geom_abline",
    "section": "",
    "text": "mapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nintercept\n\n\n\n\n\n\nslope\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\n'black'\n\n\n\n\ngroup\n\n\n\n\n\n\nlinetype\n\n\n'solid'\n\n\n\n\nsize\n\n\n0.5\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “identity”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = False\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format."
  },
  {
    "objectID": "reference/figure_size.html",
    "href": "reference/figure_size.html",
    "title": "figure_size",
    "section": "",
    "text": "figure_size\noptions.figure_size"
  },
  {
    "objectID": "reference/faithful.html",
    "href": "reference/faithful.html",
    "title": "faithful",
    "section": "",
    "text": "faithful\ndata.faithful\n\nOld Faithful Geyser Data\nDescription\nWaiting time between eruptions and the duration of the eruption for the Old Faithful geyser in Yellowstone National Park, Wyoming, USA.\nFormat\nA data frame with 272 observations on 2 variables.\n\n\n\nColumn\nDescription\n\n\n\n\neruptions\nEruption time in mins\n\n\nwaiting W\naiting time to next eruption (in mins)\n\n\n\nDetails\nA closer look at faithful.eruptions reveals that these are heavily rounded times originally in seconds, where multiples of 5 are more frequent than expected under non-human measurement. For a better version of the eruption times, see the example below.\nThere are many versions of this dataset around: Azzalini and Bowman (1990) use a more complete version.\nSource\nW. Härdle.\nReferences\nHärdle, W. (1991) Smoothing Techniques with Implementation in S. New York: Springer.\nAzzalini, A. and Bowman, A. W. (1990). A look at some data on the Old Faithful geyser. Applied Statistics 39, 357–365."
  },
  {
    "objectID": "reference/facet_null.html",
    "href": "reference/facet_null.html",
    "title": "facet_null",
    "section": "",
    "text": "facets.facet_null(self, shrink=True)\n\n\nA single Panel\n\n\n\n\nshrink: bool = True\n\nWhether to shrink the scales to the output of the statistics instead of the raw data."
  },
  {
    "objectID": "reference/facet_null.html#parameters",
    "href": "reference/facet_null.html#parameters",
    "title": "facet_null",
    "section": "",
    "text": "shrink: bool = True\n\nWhether to shrink the scales to the output of the statistics instead of the raw data."
  },
  {
    "objectID": "reference/facet.html",
    "href": "reference/facet.html",
    "title": "facet",
    "section": "",
    "text": "facets.facet\n\n\n\n\n\nName\nDescription\n\n\n\n\nfacet\nBase class for all facets\n\n\n\n\n\n\nfacets.facet.facet(self, scales='fixed', shrink=True, labeller='label_value', as_table=True, drop=True, dir='h')\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nas_table\nbool(x) -&gt; bool\n\n\ndrop\nbool(x) -&gt; bool\n\n\nnum_vars_x\nint([x]) -&gt; integer\n\n\nnum_vars_y\nint([x]) -&gt; integer\n\n\nshrink\nbool(x) -&gt; bool\n\n\nspace\nstr(object=’’) -&gt; str\n\n\n\n\nBase class for all facets\n\n\n\n\n\nscales: ‘fixed’ | ‘free’ | ‘free_x’ | ‘free_y’ = “fixed”\n\nWhether x or y scales should be allowed (free) to vary according to the data on each of the panel.\n\nshrink: bool = True\n\nWhether to shrink the scales to the output of the statistics instead of the raw data. Default is True.\n\nshrink: bool = True\n\nWhether to shrink the scales to the output of the statistics instead of the raw data.\n\nlabeller: str | callable = “label_value”\n\nHow to label the facets. A string value if it should be one of [\"label_value\", \"label_both\", \"label_context\"].\n\nas_table: bool = True\n\nIf True, the facets are laid out like a table with the highest values at the bottom-right. If False the facets are laid out like a plot with the highest value a the top-right\n\ndrop: bool = True\n\nIf True, all factor levels not used in the data will automatically be dropped. If False, all factor levels will be shown, regardless of whether or not they appear in the data.\n\ndir: ‘h’ | ‘v’ = “h”\n\nDirection in which to layout the panels. h for horizontal and v for vertical.\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncompute_layout\nCompute layout\n\n\nfinish_data\nModify data before it is drawn out by the geom\n\n\nmake_ax_strips\nCreate strips for the facet\n\n\nmake_axes\nCreate and return Matplotlib axes\n\n\nmap\nAssign a data points to panels\n\n\nset_limits_breaks_and_labels\nAdd limits, breaks and labels to the axes\n\n\nset_properties\nCopy required properties from ggplot object\n\n\nsetup_data\nAllow the facet to manipulate the data\n\n\nsetup_params\nCreate facet parameters\n\n\ntrain_position_scales\nCompute ranges for the x and y scales\n\n\n\n\n\n\nfacets.facet.facet.compute_layout(data)\n\n\nCompute layout\n\n\n\n\ndata: Dataframes\n\nDataframe for a each layer\n\n\n\n\n\n\n\nfacets.facet.facet.finish_data(data, layout)\n\n\nModify data before it is drawn out by the geom\nThe default is to return the data without modification. Subclasses should override this method as the require.\n\n\n\n\ndata: DataFrame\n\nA single layer’s data.\n\nlayout: Layout\n\nLayout\n\n\n\n\n\n\ndata: DataFrame\n\nModified layer data\n\n\n\n\n\n\n\nfacets.facet.facet.make_ax_strips(layout_info, ax)\n\n\nCreate strips for the facet\n\n\n\n\nlayout_info: dict - like\n\nLayout information. Row from the layout table\n\nax: axes\n\nAxes to label\n\n\n\n\n\n\n\nfacets.facet.facet.make_axes(figure, layout, coordinates)\n\n\nCreate and return Matplotlib axes\n\n\n\n\n\nfacets.facet.facet.map(data, layout)\n\n\nAssign a data points to panels\n\n\n\n\ndata: DataFrame\n\nData for a layer\n\nlayout: DataFrame\n\nAs returned by self.compute_layout\n\n\n\n\n\n\ndata: DataFrame\n\nData with all points mapped to the panels on which they will be plotted.\n\n\n\n\n\n\n\nfacets.facet.facet.set_limits_breaks_and_labels(panel_params, ax)\n\n\nAdd limits, breaks and labels to the axes\n\n\n\n\nranges: dict - like\n\nrange information for the axes\n\nax: Axes\n\nAxes\n\n\n\n\n\n\n\nfacets.facet.facet.set_properties(gg)\n\n\nCopy required properties from ggplot object\n\n\n\n\n\nfacets.facet.facet.setup_data(data)\n\n\nAllow the facet to manipulate the data\n\n\n\n\ndata: list of dataframes\n\nData for each of the layers\n\n\n\n\n\n\ndata: list of dataframes\n\nData for each of the layers\n\n\n\n\n\nThis method will be called after :meth:setup_params, therefore the params property will be set.\n\n\n\n\n\nfacets.facet.facet.setup_params(data)\n\n\nCreate facet parameters\n\n\n\n\ndata: list of dataframes\n\nPlot data and data for the layers\n\n\n\n\n\n\n\nfacets.facet.facet.train_position_scales(layout, layers)\n\n\nCompute ranges for the x and y scales\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nadd_missing_facets\nAdd missing facets\n\n\ncombine_vars\nGenerate all combinations of data needed for facetting\n\n\neval_facet_vars\nEvaluate facet variables\n\n\nlayout_null\nLayout Null\n\n\nunique_combs\nGenerate all possible combinations of the values in the columns\n\n\n\n\n\n\nfacets.facet.add_missing_facets(data, layout, vars, facet_vals)\n\n\nAdd missing facets\n\n\n\n\n\nfacets.facet.combine_vars(data, environment, vars, drop=True)\n\n\nGenerate all combinations of data needed for facetting\nThe first data frame in the list should be the default data for the plot. Other data frames in the list are ones that are added to the layers.\n\n\n\n\n\nfacets.facet.eval_facet_vars(data, vars, env)\n\n\nEvaluate facet variables\n\n\n\n\ndata: DataFrame\n\nFactet dataframe\n\nvars: list\n\nFacet variables\n\nenv: environment\n\nPlot environment\n\n\n\n\n\n\nfacet_vals: DataFrame\n\nFacet values that correspond to the specified variables.\n\n\n\n\n\n\n\nfacets.facet.layout_null()\n\n\nLayout Null\n\n\n\n\n\nfacets.facet.unique_combs(df)\n\n\nGenerate all possible combinations of the values in the columns"
  },
  {
    "objectID": "reference/facet.html#classes",
    "href": "reference/facet.html#classes",
    "title": "facet",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nfacet\nBase class for all facets\n\n\n\n\n\n\nfacets.facet.facet(self, scales='fixed', shrink=True, labeller='label_value', as_table=True, drop=True, dir='h')\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nas_table\nbool(x) -&gt; bool\n\n\ndrop\nbool(x) -&gt; bool\n\n\nnum_vars_x\nint([x]) -&gt; integer\n\n\nnum_vars_y\nint([x]) -&gt; integer\n\n\nshrink\nbool(x) -&gt; bool\n\n\nspace\nstr(object=’’) -&gt; str\n\n\n\n\nBase class for all facets\n\n\n\n\n\nscales: ‘fixed’ | ‘free’ | ‘free_x’ | ‘free_y’ = “fixed”\n\nWhether x or y scales should be allowed (free) to vary according to the data on each of the panel.\n\nshrink: bool = True\n\nWhether to shrink the scales to the output of the statistics instead of the raw data. Default is True.\n\nshrink: bool = True\n\nWhether to shrink the scales to the output of the statistics instead of the raw data.\n\nlabeller: str | callable = “label_value”\n\nHow to label the facets. A string value if it should be one of [\"label_value\", \"label_both\", \"label_context\"].\n\nas_table: bool = True\n\nIf True, the facets are laid out like a table with the highest values at the bottom-right. If False the facets are laid out like a plot with the highest value a the top-right\n\ndrop: bool = True\n\nIf True, all factor levels not used in the data will automatically be dropped. If False, all factor levels will be shown, regardless of whether or not they appear in the data.\n\ndir: ‘h’ | ‘v’ = “h”\n\nDirection in which to layout the panels. h for horizontal and v for vertical.\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncompute_layout\nCompute layout\n\n\nfinish_data\nModify data before it is drawn out by the geom\n\n\nmake_ax_strips\nCreate strips for the facet\n\n\nmake_axes\nCreate and return Matplotlib axes\n\n\nmap\nAssign a data points to panels\n\n\nset_limits_breaks_and_labels\nAdd limits, breaks and labels to the axes\n\n\nset_properties\nCopy required properties from ggplot object\n\n\nsetup_data\nAllow the facet to manipulate the data\n\n\nsetup_params\nCreate facet parameters\n\n\ntrain_position_scales\nCompute ranges for the x and y scales\n\n\n\n\n\n\nfacets.facet.facet.compute_layout(data)\n\n\nCompute layout\n\n\n\n\ndata: Dataframes\n\nDataframe for a each layer\n\n\n\n\n\n\n\nfacets.facet.facet.finish_data(data, layout)\n\n\nModify data before it is drawn out by the geom\nThe default is to return the data without modification. Subclasses should override this method as the require.\n\n\n\n\ndata: DataFrame\n\nA single layer’s data.\n\nlayout: Layout\n\nLayout\n\n\n\n\n\n\ndata: DataFrame\n\nModified layer data\n\n\n\n\n\n\n\nfacets.facet.facet.make_ax_strips(layout_info, ax)\n\n\nCreate strips for the facet\n\n\n\n\nlayout_info: dict - like\n\nLayout information. Row from the layout table\n\nax: axes\n\nAxes to label\n\n\n\n\n\n\n\nfacets.facet.facet.make_axes(figure, layout, coordinates)\n\n\nCreate and return Matplotlib axes\n\n\n\n\n\nfacets.facet.facet.map(data, layout)\n\n\nAssign a data points to panels\n\n\n\n\ndata: DataFrame\n\nData for a layer\n\nlayout: DataFrame\n\nAs returned by self.compute_layout\n\n\n\n\n\n\ndata: DataFrame\n\nData with all points mapped to the panels on which they will be plotted.\n\n\n\n\n\n\n\nfacets.facet.facet.set_limits_breaks_and_labels(panel_params, ax)\n\n\nAdd limits, breaks and labels to the axes\n\n\n\n\nranges: dict - like\n\nrange information for the axes\n\nax: Axes\n\nAxes\n\n\n\n\n\n\n\nfacets.facet.facet.set_properties(gg)\n\n\nCopy required properties from ggplot object\n\n\n\n\n\nfacets.facet.facet.setup_data(data)\n\n\nAllow the facet to manipulate the data\n\n\n\n\ndata: list of dataframes\n\nData for each of the layers\n\n\n\n\n\n\ndata: list of dataframes\n\nData for each of the layers\n\n\n\n\n\nThis method will be called after :meth:setup_params, therefore the params property will be set.\n\n\n\n\n\nfacets.facet.facet.setup_params(data)\n\n\nCreate facet parameters\n\n\n\n\ndata: list of dataframes\n\nPlot data and data for the layers\n\n\n\n\n\n\n\nfacets.facet.facet.train_position_scales(layout, layers)\n\n\nCompute ranges for the x and y scales"
  },
  {
    "objectID": "reference/facet.html#functions",
    "href": "reference/facet.html#functions",
    "title": "facet",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nadd_missing_facets\nAdd missing facets\n\n\ncombine_vars\nGenerate all combinations of data needed for facetting\n\n\neval_facet_vars\nEvaluate facet variables\n\n\nlayout_null\nLayout Null\n\n\nunique_combs\nGenerate all possible combinations of the values in the columns\n\n\n\n\n\n\nfacets.facet.add_missing_facets(data, layout, vars, facet_vals)\n\n\nAdd missing facets\n\n\n\n\n\nfacets.facet.combine_vars(data, environment, vars, drop=True)\n\n\nGenerate all combinations of data needed for facetting\nThe first data frame in the list should be the default data for the plot. Other data frames in the list are ones that are added to the layers.\n\n\n\n\n\nfacets.facet.eval_facet_vars(data, vars, env)\n\n\nEvaluate facet variables\n\n\n\n\ndata: DataFrame\n\nFactet dataframe\n\nvars: list\n\nFacet variables\n\nenv: environment\n\nPlot environment\n\n\n\n\n\n\nfacet_vals: DataFrame\n\nFacet values that correspond to the specified variables.\n\n\n\n\n\n\n\nfacets.facet.layout_null()\n\n\nLayout Null\n\n\n\n\n\nfacets.facet.unique_combs(df)\n\n\nGenerate all possible combinations of the values in the columns"
  },
  {
    "objectID": "reference/element_text.html",
    "href": "reference/element_text.html",
    "title": "element_text",
    "section": "",
    "text": "themes.element_text(self, family=None, style=None, weight=None, color=None, size=None, ha=None, va=None, rotation=None, linespacing=None, backgroundcolor=None, margin=None, **kwargs)\n\n\nTheme element: Text\n\n\n\n\nfamily: str = None\n\nFont family. See :meth:matplotlib.text.Text.set_family for supported values.\n\nstyle: “normal” | “italic” | “oblique”` = None\n\nFont style\n\ncolor: str | tuple = None\n\nText color\n\nweight: str = None\n\nShould be one of normal, bold, heavy, light, ultrabold or ultralight.\n\nsize: float = None\n\ntext size\n\nha: ‘center’ | ‘left’ | ‘right’ = None\n\nHorizontal Alignment.\n\nva: ‘center’ | ‘top’ | ‘bottom’ | ‘baseline’ = None\n\nVertical alignment.\n\nrotation: float = None\n\nRotation angle in the range [0, 360]\n\nlinespacing: float = None\n\nLine spacing\n\nbackgroundcolor: str | tuple = None\n\nBackground color\n\nmargin: dict = {“t”: 0, “b”: 0, “l”: 0, “r”: 0, “units”: “pt”}\n\nMargin around the text. The keys are t, b, l, r and units. The tblr keys are floats. The units is one of pt, lines or in. Not all text themeables support margin parameters and other than the units, only some of the other keys may apply.\n\nkwargs: dict = {}\n\nParameters recognised by :class:matplotlib.text.Text\n\n\n\n\n\nelement_text will accept parameters that conform to the ggplot2 element_text API, but it is preferable the Matplotlib based API described above."
  },
  {
    "objectID": "reference/element_text.html#parameters",
    "href": "reference/element_text.html#parameters",
    "title": "element_text",
    "section": "",
    "text": "family: str = None\n\nFont family. See :meth:matplotlib.text.Text.set_family for supported values.\n\nstyle: “normal” | “italic” | “oblique”` = None\n\nFont style\n\ncolor: str | tuple = None\n\nText color\n\nweight: str = None\n\nShould be one of normal, bold, heavy, light, ultrabold or ultralight.\n\nsize: float = None\n\ntext size\n\nha: ‘center’ | ‘left’ | ‘right’ = None\n\nHorizontal Alignment.\n\nva: ‘center’ | ‘top’ | ‘bottom’ | ‘baseline’ = None\n\nVertical alignment.\n\nrotation: float = None\n\nRotation angle in the range [0, 360]\n\nlinespacing: float = None\n\nLine spacing\n\nbackgroundcolor: str | tuple = None\n\nBackground color\n\nmargin: dict = {“t”: 0, “b”: 0, “l”: 0, “r”: 0, “units”: “pt”}\n\nMargin around the text. The keys are t, b, l, r and units. The tblr keys are floats. The units is one of pt, lines or in. Not all text themeables support margin parameters and other than the units, only some of the other keys may apply.\n\nkwargs: dict = {}\n\nParameters recognised by :class:matplotlib.text.Text"
  },
  {
    "objectID": "reference/element_text.html#notes",
    "href": "reference/element_text.html#notes",
    "title": "element_text",
    "section": "",
    "text": "element_text will accept parameters that conform to the ggplot2 element_text API, but it is preferable the Matplotlib based API described above."
  },
  {
    "objectID": "reference/element_line.html",
    "href": "reference/element_line.html",
    "title": "element_line",
    "section": "",
    "text": "themes.element_line(self, *, color=None, size=None, linetype=None, lineend=None, colour=None, **kwargs)\n\n\ntheme element: line\nused for backgrounds and borders\n\n\n\n\ncolor: str | tuple = None\n\nline color\n\ncolour: str | tuple = None\n\nalias of color\n\nlinetype: str | tuple = None\n\nline style. if a string, it should be one of solid, dashed, dashdot or dotted. you can create interesting dashed patterns using tuples, see :meth:matplotlib.lines.line2D.set_linestyle.\n\nsize: float = None\n\nline thickness\n\nkwargs: dict = {}\n\nparameters recognised by :class:matplotlib.lines.line2d."
  },
  {
    "objectID": "reference/element_line.html#parameters",
    "href": "reference/element_line.html#parameters",
    "title": "element_line",
    "section": "",
    "text": "color: str | tuple = None\n\nline color\n\ncolour: str | tuple = None\n\nalias of color\n\nlinetype: str | tuple = None\n\nline style. if a string, it should be one of solid, dashed, dashdot or dotted. you can create interesting dashed patterns using tuples, see :meth:matplotlib.lines.line2D.set_linestyle.\n\nsize: float = None\n\nline thickness\n\nkwargs: dict = {}\n\nparameters recognised by :class:matplotlib.lines.line2d."
  },
  {
    "objectID": "reference/economics.html",
    "href": "reference/economics.html",
    "title": "economics",
    "section": "",
    "text": "economics\ndata.economics\n::: {.description} US economic time series.\nDescription\nThis dataset was produced from US economic time series data available from http://research.stlouisfed.org/fred2. economics is in “wide” format, economics_long is in “long” format.\nFormat\nA data frame with 478 rows and 6 variables\n\n\n\nColumn\nDescription\n\n\n\n\ndate\nMonth of data collection\n\n\npsavert\npersonal savings rate 1\n\n\npce\npersonal consumption expenditures, in billions of dollars 2\n\n\nunemploy\nnumber of unemployed in thousands 3\n\n\nuempmed\nmedian duration of unemployment, in week 4\n\n\npop\ntotal population, in thousands 5\n\n\n\n\n\n\n\n\nFootnotes\n\n\n↩︎\n↩︎\n↩︎\n↩︎\n :::↩︎"
  },
  {
    "objectID": "reference/diamonds.html",
    "href": "reference/diamonds.html",
    "title": "diamonds",
    "section": "",
    "text": "diamonds\ndata.diamonds\n\nPrices of 50,000 round cut diamonds\nDescription\nA dataset containing the prices and other attributes of almost 54,000 diamonds. The variables are as follows:\nFormat\nA data frame with 53940 rows and 10 variables:\n\n\n\n\n\n\n\nColumn\nDescription\n\n\n\n\nprice\nprice in US dollars ($326–$18,823)\n\n\ncarat\nweight of the diamond (0.2–5.01)\n\n\ncut\nquality of the cut (Fair, Good, Very Good, Premium, Ideal)\n\n\ncolor\ndiamond colour, from J (worst) to D (best)\n\n\nclarity\na measurement of how clear the diamond is (I1 (worst), SI1, SI2, VS1, VS2, VVS1, VVS2, IF (best))\n\n\nx\nlength in mm (0–10.74)\n\n\ny\nwidth in mm (0–58.9)\n\n\nz\ndepth in mm (0–31.8)\n\n\ndepth\ntotal depth percentage = z / mean(x, y) = 2 * z / (x + y) (43–79)\n\n\ntable\nwidth of top of diamond relative to widest point (43–95)"
  },
  {
    "objectID": "reference/coord_trans.html",
    "href": "reference/coord_trans.html",
    "title": "coord_trans",
    "section": "",
    "text": "coords.coord_trans(self, x='identity', y='identity', xlim=None, ylim=None, expand=True)\n\n\nTransformed cartesian coordinate system\n\n\n\n\nx: str | trans = ‘identity’\n\nName of transform or trans class to transform the x axis\n\ny: str | trans = ‘identity’\n\nName of transform or trans class to transform the y axis\n\nxlim: tuple[float, float] = None\n\nLimits for x axis. If None, then they are automatically computed.\n\nylim: tuple[float, float] = None\n\nLimits for y axis. If None, then they are automatically computed.\n\nexpand: bool = True\n\nIf True, expand the coordinate axes by some factor. If False, use the limits from the data."
  },
  {
    "objectID": "reference/coord_trans.html#parameters",
    "href": "reference/coord_trans.html#parameters",
    "title": "coord_trans",
    "section": "",
    "text": "x: str | trans = ‘identity’\n\nName of transform or trans class to transform the x axis\n\ny: str | trans = ‘identity’\n\nName of transform or trans class to transform the y axis\n\nxlim: tuple[float, float] = None\n\nLimits for x axis. If None, then they are automatically computed.\n\nylim: tuple[float, float] = None\n\nLimits for y axis. If None, then they are automatically computed.\n\nexpand: bool = True\n\nIf True, expand the coordinate axes by some factor. If False, use the limits from the data."
  },
  {
    "objectID": "reference/coord_fixed.html",
    "href": "reference/coord_fixed.html",
    "title": "coord_fixed",
    "section": "",
    "text": "coords.coord_fixed(self, ratio=1, xlim=None, ylim=None, expand=True)\n\n\nCartesian coordinates with fixed relationship between x and y scales\n\n\n\n\nratio: float = 1\n\nDesired aspect_ratio (:math:y/x) of the panel(s).\n\nxlim: tuple[float, float] = None\n\nLimits for x axis. If None, then they are automatically computed.\n\nylim: tuple[float, float] = None\n\nLimits for y axis. If None, then they are automatically computed.\n\nexpand: bool = True\n\nIf True, expand the coordinate axes by some factor. If False, use the limits from the data.\n\n\n\n\n\nTo specify aspect ratio of the visual size for the axes use the aspect_ratio themeable.\nggplot(data, aes('x', 'y')) + theme(aspect_ratio=0.5)\nWhen changing the aspect_ratio in either way, the width of the panel remains constant (as derived from the :class:plotnine.themes.themeable.figure_size themeable) and the height is altered to achieve desired ratio."
  },
  {
    "objectID": "reference/coord_fixed.html#parameters",
    "href": "reference/coord_fixed.html#parameters",
    "title": "coord_fixed",
    "section": "",
    "text": "ratio: float = 1\n\nDesired aspect_ratio (:math:y/x) of the panel(s).\n\nxlim: tuple[float, float] = None\n\nLimits for x axis. If None, then they are automatically computed.\n\nylim: tuple[float, float] = None\n\nLimits for y axis. If None, then they are automatically computed.\n\nexpand: bool = True\n\nIf True, expand the coordinate axes by some factor. If False, use the limits from the data."
  },
  {
    "objectID": "reference/coord_fixed.html#notes",
    "href": "reference/coord_fixed.html#notes",
    "title": "coord_fixed",
    "section": "",
    "text": "To specify aspect ratio of the visual size for the axes use the aspect_ratio themeable.\nggplot(data, aes('x', 'y')) + theme(aspect_ratio=0.5)\nWhen changing the aspect_ratio in either way, the width of the panel remains constant (as derived from the :class:plotnine.themes.themeable.figure_size themeable) and the height is altered to achieve desired ratio."
  },
  {
    "objectID": "reference/coord_cartesian.html",
    "href": "reference/coord_cartesian.html",
    "title": "coord_cartesian",
    "section": "",
    "text": "coords.coord_cartesian(self, xlim=None, ylim=None, expand=True)\n\n\nCartesian coordinate system\n\n\n\n\nxlim: tuple[float, float] = None\n\nLimits for x axis. If None, then they are automatically computed.\n\nylim: tuple[float, float] = None\n\nLimits for y axis. If None, then they are automatically computed.\n\nexpand: bool = True\n\nIf True, expand the coordinate axes by some factor. If False, use the limits from the data."
  },
  {
    "objectID": "reference/coord_cartesian.html#parameters",
    "href": "reference/coord_cartesian.html#parameters",
    "title": "coord_cartesian",
    "section": "",
    "text": "xlim: tuple[float, float] = None\n\nLimits for x axis. If None, then they are automatically computed.\n\nylim: tuple[float, float] = None\n\nLimits for y axis. If None, then they are automatically computed.\n\nexpand: bool = True\n\nIf True, expand the coordinate axes by some factor. If False, use the limits from the data."
  },
  {
    "objectID": "reference/base_margin.html",
    "href": "reference/base_margin.html",
    "title": "base_margin",
    "section": "",
    "text": "base_margin\noptions.base_margin"
  },
  {
    "objectID": "reference/axis_title_y.html",
    "href": "reference/axis_title_y.html",
    "title": "axis_title_y",
    "section": "",
    "text": "themes.themeable.axis_title_y()\n\n\ny axis label\n\n\n\n\ntheme_element: element_text"
  },
  {
    "objectID": "reference/axis_title_y.html#parameters",
    "href": "reference/axis_title_y.html#parameters",
    "title": "axis_title_y",
    "section": "",
    "text": "theme_element: element_text"
  },
  {
    "objectID": "reference/axis_title.html",
    "href": "reference/axis_title.html",
    "title": "axis_title",
    "section": "",
    "text": "themes.themeable.axis_title()\n\n\nAxis labels\n\n\n\n\ntheme_element: element_text"
  },
  {
    "objectID": "reference/axis_title.html#parameters",
    "href": "reference/axis_title.html#parameters",
    "title": "axis_title",
    "section": "",
    "text": "theme_element: element_text"
  },
  {
    "objectID": "reference/axis_ticks_pad_major.html",
    "href": "reference/axis_ticks_pad_major.html",
    "title": "axis_ticks_pad_major",
    "section": "",
    "text": "themes.themeable.axis_ticks_pad_major()\n\n\nAxis major-tick padding\n\n\n\n\ntheme_element: float\n\nValue in points.\n\n\n\n\n\nPadding is not applied when the :class:axis_ticks_major are blank, but it does apply when the :class:axis_ticks_length_major is zero."
  },
  {
    "objectID": "reference/axis_ticks_pad_major.html#parameters",
    "href": "reference/axis_ticks_pad_major.html#parameters",
    "title": "axis_ticks_pad_major",
    "section": "",
    "text": "theme_element: float\n\nValue in points."
  },
  {
    "objectID": "reference/axis_ticks_pad_major.html#note",
    "href": "reference/axis_ticks_pad_major.html#note",
    "title": "axis_ticks_pad_major",
    "section": "",
    "text": "Padding is not applied when the :class:axis_ticks_major are blank, but it does apply when the :class:axis_ticks_length_major is zero."
  },
  {
    "objectID": "reference/axis_ticks_minor_y.html",
    "href": "reference/axis_ticks_minor_y.html",
    "title": "axis_ticks_minor_y",
    "section": "",
    "text": "themes.themeable.axis_ticks_minor_y()\n\n\ny-axis minor tick lines\n\n\n\n\ntheme_element: element_line"
  },
  {
    "objectID": "reference/axis_ticks_minor_y.html#parameters",
    "href": "reference/axis_ticks_minor_y.html#parameters",
    "title": "axis_ticks_minor_y",
    "section": "",
    "text": "theme_element: element_line"
  },
  {
    "objectID": "reference/axis_ticks_minor.html",
    "href": "reference/axis_ticks_minor.html",
    "title": "axis_ticks_minor",
    "section": "",
    "text": "themes.themeable.axis_ticks_minor()\n\n\nx & y axis minor tick lines\n\n\n\n\ntheme_element: element_line"
  },
  {
    "objectID": "reference/axis_ticks_minor.html#parameters",
    "href": "reference/axis_ticks_minor.html#parameters",
    "title": "axis_ticks_minor",
    "section": "",
    "text": "theme_element: element_line"
  },
  {
    "objectID": "reference/axis_ticks_major_x.html",
    "href": "reference/axis_ticks_major_x.html",
    "title": "axis_ticks_major_x",
    "section": "",
    "text": "themes.themeable.axis_ticks_major_x()\n\n\nx-axis major tick lines\n\n\n\n\ntheme_element: element_line"
  },
  {
    "objectID": "reference/axis_ticks_major_x.html#parameters",
    "href": "reference/axis_ticks_major_x.html#parameters",
    "title": "axis_ticks_major_x",
    "section": "",
    "text": "theme_element: element_line"
  },
  {
    "objectID": "reference/axis_ticks_length_minor.html",
    "href": "reference/axis_ticks_length_minor.html",
    "title": "axis_ticks_length_minor",
    "section": "",
    "text": "themes.themeable.axis_ticks_length_minor()\n\n\nAxis minor-tick length\n\n\n\n\ntheme_element: float\n\nValue in points."
  },
  {
    "objectID": "reference/axis_ticks_length_minor.html#parameters",
    "href": "reference/axis_ticks_length_minor.html#parameters",
    "title": "axis_ticks_length_minor",
    "section": "",
    "text": "theme_element: float\n\nValue in points."
  },
  {
    "objectID": "reference/axis_ticks_length.html",
    "href": "reference/axis_ticks_length.html",
    "title": "axis_ticks_length",
    "section": "",
    "text": "themes.themeable.axis_ticks_length()\n\n\nAxis tick length\n\n\n\n\ntheme_element: float\n\nValue in points."
  },
  {
    "objectID": "reference/axis_ticks_length.html#parameters",
    "href": "reference/axis_ticks_length.html#parameters",
    "title": "axis_ticks_length",
    "section": "",
    "text": "theme_element: float\n\nValue in points."
  },
  {
    "objectID": "reference/axis_ticks_direction_x.html",
    "href": "reference/axis_ticks_direction_x.html",
    "title": "axis_ticks_direction_x",
    "section": "",
    "text": "themes.themeable.axis_ticks_direction_x()\n\n\nx-axis tick direction\n\n\n\n\ntheme_element: ‘in’ | ‘out’ | ‘inout’\n\nin for ticks inside the panel. out for ticks outside the panel. inout for ticks inside and outside the panel."
  },
  {
    "objectID": "reference/axis_ticks_direction_x.html#parameters",
    "href": "reference/axis_ticks_direction_x.html#parameters",
    "title": "axis_ticks_direction_x",
    "section": "",
    "text": "theme_element: ‘in’ | ‘out’ | ‘inout’\n\nin for ticks inside the panel. out for ticks outside the panel. inout for ticks inside and outside the panel."
  },
  {
    "objectID": "reference/axis_ticks.html",
    "href": "reference/axis_ticks.html",
    "title": "axis_ticks",
    "section": "",
    "text": "themes.themeable.axis_ticks()\n\n\nx & y major and minor axis tick lines\n\n\n\n\ntheme_element: element_line"
  },
  {
    "objectID": "reference/axis_ticks.html#parameters",
    "href": "reference/axis_ticks.html#parameters",
    "title": "axis_ticks",
    "section": "",
    "text": "theme_element: element_line"
  },
  {
    "objectID": "reference/axis_text_x.html",
    "href": "reference/axis_text_x.html",
    "title": "axis_text_x",
    "section": "",
    "text": "themes.themeable.axis_text_x()\n\n\nx-axis tick labels\n\n\n\n\ntheme_element: element_text"
  },
  {
    "objectID": "reference/axis_text_x.html#parameters",
    "href": "reference/axis_text_x.html#parameters",
    "title": "axis_text_x",
    "section": "",
    "text": "theme_element: element_text"
  },
  {
    "objectID": "reference/axis_line_y.html",
    "href": "reference/axis_line_y.html",
    "title": "axis_line_y",
    "section": "",
    "text": "themes.themeable.axis_line_y()\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nposition\nstr(object=’’) -&gt; str\n\n\n\n\ny-axis line\n\n\n\n\n\ntheme_element: element_line"
  },
  {
    "objectID": "reference/axis_line_y.html#attributes",
    "href": "reference/axis_line_y.html#attributes",
    "title": "axis_line_y",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nposition\nstr(object=’’) -&gt; str\n\n\n\n\ny-axis line"
  },
  {
    "objectID": "reference/axis_line_y.html#parameters",
    "href": "reference/axis_line_y.html#parameters",
    "title": "axis_line_y",
    "section": "",
    "text": "theme_element: element_line"
  },
  {
    "objectID": "reference/axis_line.html",
    "href": "reference/axis_line.html",
    "title": "axis_line",
    "section": "",
    "text": "themes.themeable.axis_line()\n\n\nx & y axis lines\n\n\n\n\ntheme_element: element_line"
  },
  {
    "objectID": "reference/axis_line.html#parameters",
    "href": "reference/axis_line.html#parameters",
    "title": "axis_line",
    "section": "",
    "text": "theme_element: element_line"
  },
  {
    "objectID": "reference/annotation_stripes.html",
    "href": "reference/annotation_stripes.html",
    "title": "annotation_stripes",
    "section": "",
    "text": "geoms.annotation_stripes(self, fill=('#AAAAAA', '#CCCCCC'), fill_range='auto', direction='vertical', extend=(0, 1), **kwargs)\n\n\nAlternating stripes, centered around each label.\nUseful as a background for geom_jitter.\n\n\n\n\nfill: list - like = (‘#AAAAAA’, ‘#CCCCCC’)\n\nList of colors for the strips.\n\nfill_range: Literal[‘auto’, ‘cycle’, ‘no’, ‘nocycle’] = ‘auto’\n\nHow to fill stripes beyond the range of scale:\n\"cycle\"      # keep cycling the colors of the\n             # stripes after the range ends\n\"nocycle\"    # stop cycling the colors of the\n             # stripes after the range ends\n\"auto\"       # \"cycle\" for continuous scales and\n             # \"nocycle\" for discrete scales.\n\"no\"         # Do not add stripes passed the range\n             # passed the range of the scales\n\ndirection: ‘vertical’ | ‘horizontal’ = ‘vertical’\n\nOrientation of the stripes\n\nextend: tuple = (0, 1)\n\nRange of the stripes. The default is (0, 1), top to bottom. The values should be in the range [0, 1].\n\n**kwargs: dict = {}\n\nOther aesthetic parameters for the rectangular stripes. They include; alpha, color, linetype, and size."
  },
  {
    "objectID": "reference/annotation_stripes.html#parameters",
    "href": "reference/annotation_stripes.html#parameters",
    "title": "annotation_stripes",
    "section": "",
    "text": "fill: list - like = (‘#AAAAAA’, ‘#CCCCCC’)\n\nList of colors for the strips.\n\nfill_range: Literal[‘auto’, ‘cycle’, ‘no’, ‘nocycle’] = ‘auto’\n\nHow to fill stripes beyond the range of scale:\n\"cycle\"      # keep cycling the colors of the\n             # stripes after the range ends\n\"nocycle\"    # stop cycling the colors of the\n             # stripes after the range ends\n\"auto\"       # \"cycle\" for continuous scales and\n             # \"nocycle\" for discrete scales.\n\"no\"         # Do not add stripes passed the range\n             # passed the range of the scales\n\ndirection: ‘vertical’ | ‘horizontal’ = ‘vertical’\n\nOrientation of the stripes\n\nextend: tuple = (0, 1)\n\nRange of the stripes. The default is (0, 1), top to bottom. The values should be in the range [0, 1].\n\n**kwargs: dict = {}\n\nOther aesthetic parameters for the rectangular stripes. They include; alpha, color, linetype, and size."
  },
  {
    "objectID": "reference/annotate.html",
    "href": "reference/annotate.html",
    "title": "annotate",
    "section": "",
    "text": "geoms.annotate(self, geom, x=None, y=None, xmin=None, xmax=None, xend=None, xintercept=None, ymin=None, ymax=None, yend=None, yintercept=None, **kwargs)\n\n\nCreate an annotation layer\n\n\n\n\ngeom: geom | str\n\ngeom to use for annotation, or name of geom (e.g. ‘point’).\n\nx: float = None\n\nPosition\n\ny: float = None\n\nPosition\n\nxmin: float = None\n\nPosition\n\nymin: float = None\n\nPosition\n\nxmax: float = None\n\nPosition\n\nymax: float = None\n\nPosition\n\nxend: float = None\n\nPosition\n\nyend: float = None\n\nPosition\n\nxintercept: float = None\n\nPosition\n\nyintercept: float = None\n\nPosition\n\nkwargs: dict = {}\n\nOther aesthetics or parameters to the geom.\n\n\n\n\n\nThe positioning aethetics x, y, xmin, ymin, xmax, ymax, xend, yend, xintercept, yintercept depend on which geom is used.\nYou should choose or ignore accordingly.\nAll geoms are created with :code:stat='identity'."
  },
  {
    "objectID": "reference/annotate.html#parameters",
    "href": "reference/annotate.html#parameters",
    "title": "annotate",
    "section": "",
    "text": "geom: geom | str\n\ngeom to use for annotation, or name of geom (e.g. ‘point’).\n\nx: float = None\n\nPosition\n\ny: float = None\n\nPosition\n\nxmin: float = None\n\nPosition\n\nymin: float = None\n\nPosition\n\nxmax: float = None\n\nPosition\n\nymax: float = None\n\nPosition\n\nxend: float = None\n\nPosition\n\nyend: float = None\n\nPosition\n\nxintercept: float = None\n\nPosition\n\nyintercept: float = None\n\nPosition\n\nkwargs: dict = {}\n\nOther aesthetics or parameters to the geom."
  },
  {
    "objectID": "reference/annotate.html#notes",
    "href": "reference/annotate.html#notes",
    "title": "annotate",
    "section": "",
    "text": "The positioning aethetics x, y, xmin, ymin, xmax, ymax, xend, yend, xintercept, yintercept depend on which geom is used.\nYou should choose or ignore accordingly.\nAll geoms are created with :code:stat='identity'."
  },
  {
    "objectID": "reference/after_scale.html",
    "href": "reference/after_scale.html",
    "title": "after_scale",
    "section": "",
    "text": "mapping.after_scale(x)\n\n\nEvaluate mapping after variable has been mapped to the scale\nThis gives the user a chance to alter the value of a variable in the final units of the scale e.g. the rgb hex color.\n\n\n\n\nx: str\n\nAn expression\n\n\n\n\n\n\nplotnine.mapping.after_stat\n\n\n\nplotnine.mapping.stage"
  },
  {
    "objectID": "reference/after_scale.html#parameters",
    "href": "reference/after_scale.html#parameters",
    "title": "after_scale",
    "section": "",
    "text": "x: str\n\nAn expression"
  },
  {
    "objectID": "reference/after_scale.html#see-also",
    "href": "reference/after_scale.html#see-also",
    "title": "after_scale",
    "section": "",
    "text": "plotnine.mapping.after_stat\n\n\n\nplotnine.mapping.stage"
  },
  {
    "objectID": "reference/PlotnineAnimation.html",
    "href": "reference/PlotnineAnimation.html",
    "title": "PlotnineAnimation",
    "section": "",
    "text": "animation.PlotnineAnimation(self, plots, interval=200, repeat_delay=None, repeat=True, blit=False)\n\n\nAnimation using ggplot objects\n\n\n\n\nplots: Iterable[Ggplot]\n\nggplot objects that make up the the frames of the animation\n\ninterval: int = 200\n\nDelay between frames in milliseconds. Defaults to 200.\n\nrepeat_delay: int = None\n\nIf the animation in repeated, adds a delay in milliseconds before repeating the animation. Defaults to None.\n\nrepeat: bool = True\n\nControls whether the animation should repeat when the sequence of frames is completed. Defaults to True.\n\nblit: bool = False\n\nControls whether blitting is used to optimize drawing. Defaults to False.\n\n\n\n\n\n\nThe plots should have the same facet and the facet should not have fixed x and y scales.\nThe scales of all the plots should have the same limits. It is a good idea to create a scale (with limits) for each aesthetic and add them to all the plots."
  },
  {
    "objectID": "reference/PlotnineAnimation.html#parameters",
    "href": "reference/PlotnineAnimation.html#parameters",
    "title": "PlotnineAnimation",
    "section": "",
    "text": "plots: Iterable[Ggplot]\n\nggplot objects that make up the the frames of the animation\n\ninterval: int = 200\n\nDelay between frames in milliseconds. Defaults to 200.\n\nrepeat_delay: int = None\n\nIf the animation in repeated, adds a delay in milliseconds before repeating the animation. Defaults to None.\n\nrepeat: bool = True\n\nControls whether the animation should repeat when the sequence of frames is completed. Defaults to True.\n\nblit: bool = False\n\nControls whether blitting is used to optimize drawing. Defaults to False."
  },
  {
    "objectID": "reference/PlotnineAnimation.html#notes",
    "href": "reference/PlotnineAnimation.html#notes",
    "title": "PlotnineAnimation",
    "section": "",
    "text": "The plots should have the same facet and the facet should not have fixed x and y scales.\nThe scales of all the plots should have the same limits. It is a good idea to create a scale (with limits) for each aesthetic and add them to all the plots."
  },
  {
    "objectID": "reference/aes.html",
    "href": "reference/aes.html",
    "title": "aes",
    "section": "",
    "text": "mapping.aes(self, *args, **kwargs)\n\n\nCreate aesthetic mappings\n\n\n\n\nx: expression | array_like | scalar\n\nx aesthetic mapping\n\ny: expression | array_like | scalar\n\ny aesthetic mapping\n\n**kwargs: dict = {}\n\nOther aesthetic mappings\n\n\n\n\n\nOnly the x and y aesthetic mappings can be specified as positional arguments. All the rest must be keyword arguments.\nThe value of each mapping must be one of:\n\nstring\n import pandas as pd\n import numpy as np\n\n arr = [11, 12, 13]\n df = pd.DataFrame({\n     \"alpha\": [1, 2, 3],\n     \"beta\": [1, 2, 3],\n     \"gam ma\": [1, 2, 3]\n })\n\n # Refer to a column in a dataframe\n ggplot(df, aes(x=\"alpha\", y=\"beta\"))\narray_like\n# A variable\nggplot(df, aes(x=\"alpha\", y=arr))\n\n# or an inplace list\nggplot(df, aes(x=\"alpha\", y=[4, 5, 6]))\nscalar\n# A scalar value/variable\nggplot(df, aes(x=\"alpha\", y=4))\n\n# The above statement is equivalent to\nggplot(df, aes(x=\"alpha\", y=[4, 4, 4]))\nString expression\nggplot(df, aes(x=\"alpha\", y=\"2*beta\"))\nggplot(df, aes(x=\"alpha\", y=\"np.sin(beta)\"))\nggplot(df, aes(x=\"df.index\", y=\"beta\"))\n\n# If `count` is an aesthetic calculated by a stat\nggplot(df, aes(x=\"alpha\", y=after_stat(\"count\")))\nggplot(df, aes(x=\"alpha\", y=after_stat(\"count/np.max(count)\")))\nThe strings in the expression can refer to;\n\ncolumns in the dataframe\nvariables in the namespace\naesthetic values (columns) calculated by the stat\n\nwith the column names having precedence over the variables. For expressions, columns in the dataframe that are mapped to must have names that would be valid python variable names.\nThis is okay:\n# \"gam ma\" is a column in the dataframe\nggplot(df, aes(x=\"df.index\", y=\"gam ma\"))\nWhile this is not:\n# \"gam ma\" is a column in the dataframe, but not\n# valid python variable name\nggplot(df, aes(x=\"df.index\", y=\"np.sin(gam ma)\"))\n\naes has 2 internal methods you can use to transform variables being mapped.\n\nfactor - This function turns the variable into a factor. It is just an alias to pandas.Categorical:\nggplot(mtcars, aes(x=\"factor(cyl)\")) + geom_bar()\nreorder - This function changes the order of first variable based on values of the second variable:\ndf = pd.DataFrame({\n    \"x\": [\"b\", \"d\", \"c\", \"a\"],\n    \"y\": [1, 2, 3, 4]\n})\n\nggplot(df, aes(\"reorder(x, y)\", \"y\")) + geom_col()\n\nThe group aesthetic\ngroup is a special aesthetic that the user can map to. It is used to group the plotted items. If not specified, it is automatically computed and in most cases the computed groups are sufficient. However, there may be cases were it is handy to map to it.\n\n\n\n\nplotnine.mapping.after_stat\n\n\n\nplotnine.mapping.after_scale\n\n\n\nplotnine.mapping.stage"
  },
  {
    "objectID": "reference/aes.html#parameters",
    "href": "reference/aes.html#parameters",
    "title": "aes",
    "section": "",
    "text": "x: expression | array_like | scalar\n\nx aesthetic mapping\n\ny: expression | array_like | scalar\n\ny aesthetic mapping\n\n**kwargs: dict = {}\n\nOther aesthetic mappings"
  },
  {
    "objectID": "reference/aes.html#notes",
    "href": "reference/aes.html#notes",
    "title": "aes",
    "section": "",
    "text": "Only the x and y aesthetic mappings can be specified as positional arguments. All the rest must be keyword arguments.\nThe value of each mapping must be one of:\n\nstring\n import pandas as pd\n import numpy as np\n\n arr = [11, 12, 13]\n df = pd.DataFrame({\n     \"alpha\": [1, 2, 3],\n     \"beta\": [1, 2, 3],\n     \"gam ma\": [1, 2, 3]\n })\n\n # Refer to a column in a dataframe\n ggplot(df, aes(x=\"alpha\", y=\"beta\"))\narray_like\n# A variable\nggplot(df, aes(x=\"alpha\", y=arr))\n\n# or an inplace list\nggplot(df, aes(x=\"alpha\", y=[4, 5, 6]))\nscalar\n# A scalar value/variable\nggplot(df, aes(x=\"alpha\", y=4))\n\n# The above statement is equivalent to\nggplot(df, aes(x=\"alpha\", y=[4, 4, 4]))\nString expression\nggplot(df, aes(x=\"alpha\", y=\"2*beta\"))\nggplot(df, aes(x=\"alpha\", y=\"np.sin(beta)\"))\nggplot(df, aes(x=\"df.index\", y=\"beta\"))\n\n# If `count` is an aesthetic calculated by a stat\nggplot(df, aes(x=\"alpha\", y=after_stat(\"count\")))\nggplot(df, aes(x=\"alpha\", y=after_stat(\"count/np.max(count)\")))\nThe strings in the expression can refer to;\n\ncolumns in the dataframe\nvariables in the namespace\naesthetic values (columns) calculated by the stat\n\nwith the column names having precedence over the variables. For expressions, columns in the dataframe that are mapped to must have names that would be valid python variable names.\nThis is okay:\n# \"gam ma\" is a column in the dataframe\nggplot(df, aes(x=\"df.index\", y=\"gam ma\"))\nWhile this is not:\n# \"gam ma\" is a column in the dataframe, but not\n# valid python variable name\nggplot(df, aes(x=\"df.index\", y=\"np.sin(gam ma)\"))\n\naes has 2 internal methods you can use to transform variables being mapped.\n\nfactor - This function turns the variable into a factor. It is just an alias to pandas.Categorical:\nggplot(mtcars, aes(x=\"factor(cyl)\")) + geom_bar()\nreorder - This function changes the order of first variable based on values of the second variable:\ndf = pd.DataFrame({\n    \"x\": [\"b\", \"d\", \"c\", \"a\"],\n    \"y\": [1, 2, 3, 4]\n})\n\nggplot(df, aes(\"reorder(x, y)\", \"y\")) + geom_col()\n\nThe group aesthetic\ngroup is a special aesthetic that the user can map to. It is used to group the plotted items. If not specified, it is automatically computed and in most cases the computed groups are sufficient. However, there may be cases were it is handy to map to it."
  },
  {
    "objectID": "reference/aes.html#see-also",
    "href": "reference/aes.html#see-also",
    "title": "aes",
    "section": "",
    "text": "plotnine.mapping.after_stat\n\n\n\nplotnine.mapping.after_scale\n\n\n\nplotnine.mapping.stage"
  },
  {
    "objectID": "reference/after_stat.html",
    "href": "reference/after_stat.html",
    "title": "after_stat",
    "section": "",
    "text": "mapping.after_stat(x)\n\n\nEvaluate mapping after statistic has been calculated\n\n\n\n\nx: str\n\nAn expression\n\n\n\n\n\n\nplotnine.mapping.after_scale\n\n\n\nplotnine.mapping.stage"
  },
  {
    "objectID": "reference/after_stat.html#parameters",
    "href": "reference/after_stat.html#parameters",
    "title": "after_stat",
    "section": "",
    "text": "x: str\n\nAn expression"
  },
  {
    "objectID": "reference/after_stat.html#see-also",
    "href": "reference/after_stat.html#see-also",
    "title": "after_stat",
    "section": "",
    "text": "plotnine.mapping.after_scale\n\n\n\nplotnine.mapping.stage"
  },
  {
    "objectID": "reference/annotation_logticks.html",
    "href": "reference/annotation_logticks.html",
    "title": "annotation_logticks",
    "section": "",
    "text": "geoms.annotation_logticks(self, sides='bl', alpha=1, color='black', size=0.5, linetype='solid', lengths=(0.036, 0.0225, 0.012), base=None)\n\n\nMarginal log ticks.\nIf added to a plot that does not have a log10 axis on the respective side, a warning will be issued.\n\n\n\n\nsides: str = “bl”\n\nSides onto which to draw the marks. Any combination chosen from the characters btlr, for bottom, top, left or right side marks. If coord_flip() is used, these are the sides after the flip.\n\nalpha: float = 1)\n\nTransparency of the ticks\n\ncolor: str | tuple = “black”\n\nColour of the ticks\n\nsize: float = 0.5\n\nThickness of the ticks\n\nlinetype: ‘solid’ | ‘dashed’ | ‘dashdot’ | ‘dotted’ | tuple[float] = ‘solid’\n\nType of line\n\nlengths: TupleFloat3 = (0.036, 0.0225, 0.012)\n\nlength of the ticks drawn for full / half / tenth ticks relative to panel size\n\nbase: float = None\n\nBase of the logarithm in which the ticks will be calculated. If None, the base used to log transform the scale will be used."
  },
  {
    "objectID": "reference/annotation_logticks.html#parameters",
    "href": "reference/annotation_logticks.html#parameters",
    "title": "annotation_logticks",
    "section": "",
    "text": "sides: str = “bl”\n\nSides onto which to draw the marks. Any combination chosen from the characters btlr, for bottom, top, left or right side marks. If coord_flip() is used, these are the sides after the flip.\n\nalpha: float = 1)\n\nTransparency of the ticks\n\ncolor: str | tuple = “black”\n\nColour of the ticks\n\nsize: float = 0.5\n\nThickness of the ticks\n\nlinetype: ‘solid’ | ‘dashed’ | ‘dashdot’ | ‘dotted’ | tuple[float] = ‘solid’\n\nType of line\n\nlengths: TupleFloat3 = (0.036, 0.0225, 0.012)\n\nlength of the ticks drawn for full / half / tenth ticks relative to panel size\n\nbase: float = None\n\nBase of the logarithm in which the ticks will be calculated. If None, the base used to log transform the scale will be used."
  },
  {
    "objectID": "reference/aspect_ratio.html",
    "href": "reference/aspect_ratio.html",
    "title": "aspect_ratio",
    "section": "",
    "text": "aspect_ratio\noptions.aspect_ratio"
  },
  {
    "objectID": "reference/axis_line_x.html",
    "href": "reference/axis_line_x.html",
    "title": "axis_line_x",
    "section": "",
    "text": "themes.themeable.axis_line_x()\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nposition\nstr(object=’’) -&gt; str\n\n\n\n\nx-axis line\n\n\n\n\n\ntheme_element: element_line"
  },
  {
    "objectID": "reference/axis_line_x.html#attributes",
    "href": "reference/axis_line_x.html#attributes",
    "title": "axis_line_x",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nposition\nstr(object=’’) -&gt; str\n\n\n\n\nx-axis line"
  },
  {
    "objectID": "reference/axis_line_x.html#parameters",
    "href": "reference/axis_line_x.html#parameters",
    "title": "axis_line_x",
    "section": "",
    "text": "theme_element: element_line"
  },
  {
    "objectID": "reference/axis_text.html",
    "href": "reference/axis_text.html",
    "title": "axis_text",
    "section": "",
    "text": "themes.themeable.axis_text()\n\n\nAxis tick labels\n\n\n\n\ntheme_element: element_text"
  },
  {
    "objectID": "reference/axis_text.html#parameters",
    "href": "reference/axis_text.html#parameters",
    "title": "axis_text",
    "section": "",
    "text": "theme_element: element_text"
  },
  {
    "objectID": "reference/axis_text_y.html",
    "href": "reference/axis_text_y.html",
    "title": "axis_text_y",
    "section": "",
    "text": "themes.themeable.axis_text_y()\n\n\ny-axis tick labels\n\n\n\n\ntheme_element: element_text"
  },
  {
    "objectID": "reference/axis_text_y.html#parameters",
    "href": "reference/axis_text_y.html#parameters",
    "title": "axis_text_y",
    "section": "",
    "text": "theme_element: element_text"
  },
  {
    "objectID": "reference/axis_ticks_direction.html",
    "href": "reference/axis_ticks_direction.html",
    "title": "axis_ticks_direction",
    "section": "",
    "text": "themes.themeable.axis_ticks_direction()\n\n\naxis tick direction\n\n\n\n\ntheme_element: ‘in’ | ‘out’ | ‘inout’\n\nin for ticks inside the panel. out for ticks outside the panel. inout for ticks inside and outside the panel."
  },
  {
    "objectID": "reference/axis_ticks_direction.html#parameters",
    "href": "reference/axis_ticks_direction.html#parameters",
    "title": "axis_ticks_direction",
    "section": "",
    "text": "theme_element: ‘in’ | ‘out’ | ‘inout’\n\nin for ticks inside the panel. out for ticks outside the panel. inout for ticks inside and outside the panel."
  },
  {
    "objectID": "reference/axis_ticks_direction_y.html",
    "href": "reference/axis_ticks_direction_y.html",
    "title": "axis_ticks_direction_y",
    "section": "",
    "text": "themes.themeable.axis_ticks_direction_y()\n\n\ny-axis tick direction\n\n\n\n\ntheme_element: ‘in’ | ‘out’ | ‘inout’\n\nin for ticks inside the panel. out for ticks outside the panel. inout for ticks inside and outside the panel."
  },
  {
    "objectID": "reference/axis_ticks_direction_y.html#parameters",
    "href": "reference/axis_ticks_direction_y.html#parameters",
    "title": "axis_ticks_direction_y",
    "section": "",
    "text": "theme_element: ‘in’ | ‘out’ | ‘inout’\n\nin for ticks inside the panel. out for ticks outside the panel. inout for ticks inside and outside the panel."
  },
  {
    "objectID": "reference/axis_ticks_length_major.html",
    "href": "reference/axis_ticks_length_major.html",
    "title": "axis_ticks_length_major",
    "section": "",
    "text": "themes.themeable.axis_ticks_length_major()\n\n\nAxis major-tick length\n\n\n\n\ntheme_element: float\n\nValue in points."
  },
  {
    "objectID": "reference/axis_ticks_length_major.html#parameters",
    "href": "reference/axis_ticks_length_major.html#parameters",
    "title": "axis_ticks_length_major",
    "section": "",
    "text": "theme_element: float\n\nValue in points."
  },
  {
    "objectID": "reference/axis_ticks_major.html",
    "href": "reference/axis_ticks_major.html",
    "title": "axis_ticks_major",
    "section": "",
    "text": "themes.themeable.axis_ticks_major()\n\n\nx & y axis major tick lines\n\n\n\n\ntheme_element: element_line"
  },
  {
    "objectID": "reference/axis_ticks_major.html#parameters",
    "href": "reference/axis_ticks_major.html#parameters",
    "title": "axis_ticks_major",
    "section": "",
    "text": "theme_element: element_line"
  },
  {
    "objectID": "reference/axis_ticks_major_y.html",
    "href": "reference/axis_ticks_major_y.html",
    "title": "axis_ticks_major_y",
    "section": "",
    "text": "themes.themeable.axis_ticks_major_y()\n\n\ny-axis major tick lines\n\n\n\n\ntheme_element: element_line"
  },
  {
    "objectID": "reference/axis_ticks_major_y.html#parameters",
    "href": "reference/axis_ticks_major_y.html#parameters",
    "title": "axis_ticks_major_y",
    "section": "",
    "text": "theme_element: element_line"
  },
  {
    "objectID": "reference/axis_ticks_minor_x.html",
    "href": "reference/axis_ticks_minor_x.html",
    "title": "axis_ticks_minor_x",
    "section": "",
    "text": "themes.themeable.axis_ticks_minor_x()\n\n\nx-axis tick lines\n\n\n\n\ntheme_element: element_line"
  },
  {
    "objectID": "reference/axis_ticks_minor_x.html#parameters",
    "href": "reference/axis_ticks_minor_x.html#parameters",
    "title": "axis_ticks_minor_x",
    "section": "",
    "text": "theme_element: element_line"
  },
  {
    "objectID": "reference/axis_ticks_pad.html",
    "href": "reference/axis_ticks_pad.html",
    "title": "axis_ticks_pad",
    "section": "",
    "text": "themes.themeable.axis_ticks_pad()\n\n\nAxis tick padding\n\n\n\n\ntheme_element: float\n\nValue in points.\n\n\n\n\n\nPadding is not applied when the :class:axis_ticks are blank, but it does apply when the :class:axis_ticks_length is zero."
  },
  {
    "objectID": "reference/axis_ticks_pad.html#parameters",
    "href": "reference/axis_ticks_pad.html#parameters",
    "title": "axis_ticks_pad",
    "section": "",
    "text": "theme_element: float\n\nValue in points."
  },
  {
    "objectID": "reference/axis_ticks_pad.html#note",
    "href": "reference/axis_ticks_pad.html#note",
    "title": "axis_ticks_pad",
    "section": "",
    "text": "Padding is not applied when the :class:axis_ticks are blank, but it does apply when the :class:axis_ticks_length is zero."
  },
  {
    "objectID": "reference/axis_ticks_pad_minor.html",
    "href": "reference/axis_ticks_pad_minor.html",
    "title": "axis_ticks_pad_minor",
    "section": "",
    "text": "themes.themeable.axis_ticks_pad_minor()\n\n\nAxis minor-tick padding\n\n\n\n\ntheme_element: float\n\n\n\n\n\n\n\nPadding is not applied when the :class:axis_ticks_minor are blank, but it does apply when the :class:axis_ticks_length_minor is zero."
  },
  {
    "objectID": "reference/axis_ticks_pad_minor.html#parameters",
    "href": "reference/axis_ticks_pad_minor.html#parameters",
    "title": "axis_ticks_pad_minor",
    "section": "",
    "text": "theme_element: float"
  },
  {
    "objectID": "reference/axis_ticks_pad_minor.html#note",
    "href": "reference/axis_ticks_pad_minor.html#note",
    "title": "axis_ticks_pad_minor",
    "section": "",
    "text": "Padding is not applied when the :class:axis_ticks_minor are blank, but it does apply when the :class:axis_ticks_length_minor is zero."
  },
  {
    "objectID": "reference/axis_title_x.html",
    "href": "reference/axis_title_x.html",
    "title": "axis_title_x",
    "section": "",
    "text": "themes.themeable.axis_title_x()\n\n\nx axis label\n\n\n\n\ntheme_element: element_text"
  },
  {
    "objectID": "reference/axis_title_x.html#parameters",
    "href": "reference/axis_title_x.html#parameters",
    "title": "axis_title_x",
    "section": "",
    "text": "theme_element: element_text"
  },
  {
    "objectID": "reference/base_family.html",
    "href": "reference/base_family.html",
    "title": "base_family",
    "section": "",
    "text": "base_family\noptions.base_family"
  },
  {
    "objectID": "reference/close_all_figures.html",
    "href": "reference/close_all_figures.html",
    "title": "close_all_figures",
    "section": "",
    "text": "close_all_figures\noptions.close_all_figures"
  },
  {
    "objectID": "reference/coord_equal.html",
    "href": "reference/coord_equal.html",
    "title": "coord_equal",
    "section": "",
    "text": "coords.coord_equal\n\nCartesian coordinates with fixed relationship between x and y scales\n\n\n\nratio : float Desired aspect_ratio (:math:y/x) of the panel(s). xlim : tuple[float, float] Limits for x axis. If None, then they are automatically computed. ylim : tuple[float, float] Limits for y axis. If None, then they are automatically computed. expand : bool If True, expand the coordinate axes by some factor. If False, use the limits from the data.\n\n\n\nTo specify aspect ratio of the visual size for the axes use the aspect_ratio themeable.\nggplot(data, aes('x', 'y')) + theme(aspect_ratio=0.5)\nWhen changing the aspect_ratio in either way, the width of the panel remains constant (as derived from the :class:plotnine.themes.themeable.figure_size themeable) and the height is altered to achieve desired ratio."
  },
  {
    "objectID": "reference/coord_equal.html#parameters",
    "href": "reference/coord_equal.html#parameters",
    "title": "coord_equal",
    "section": "",
    "text": "ratio : float Desired aspect_ratio (:math:y/x) of the panel(s). xlim : tuple[float, float] Limits for x axis. If None, then they are automatically computed. ylim : tuple[float, float] Limits for y axis. If None, then they are automatically computed. expand : bool If True, expand the coordinate axes by some factor. If False, use the limits from the data."
  },
  {
    "objectID": "reference/coord_equal.html#notes",
    "href": "reference/coord_equal.html#notes",
    "title": "coord_equal",
    "section": "",
    "text": "To specify aspect ratio of the visual size for the axes use the aspect_ratio themeable.\nggplot(data, aes('x', 'y')) + theme(aspect_ratio=0.5)\nWhen changing the aspect_ratio in either way, the width of the panel remains constant (as derived from the :class:plotnine.themes.themeable.figure_size themeable) and the height is altered to achieve desired ratio."
  },
  {
    "objectID": "reference/coord_flip.html",
    "href": "reference/coord_flip.html",
    "title": "coord_flip",
    "section": "",
    "text": "coords.coord_flip()\n\n\nFlipped cartesian coordinates\nThe horizontal becomes vertical, and vertical becomes horizontal. This is primarily useful for converting geoms and statistics which display y conditional on x, to x conditional on y.\n\n\n\n\nxlim: tuple[float, float] = None\n\nLimits for x axis. If None, then they are automatically computed.\n\nylim: tuple[float, float] = None\n\nLimits for y axis. If None, then they are automatically computed.\n\nexpand: bool = True\n\nIf True, expand the coordinate axes by some factor. If False, use the limits from the data."
  },
  {
    "objectID": "reference/coord_flip.html#parameters",
    "href": "reference/coord_flip.html#parameters",
    "title": "coord_flip",
    "section": "",
    "text": "xlim: tuple[float, float] = None\n\nLimits for x axis. If None, then they are automatically computed.\n\nylim: tuple[float, float] = None\n\nLimits for y axis. If None, then they are automatically computed.\n\nexpand: bool = True\n\nIf True, expand the coordinate axes by some factor. If False, use the limits from the data."
  },
  {
    "objectID": "reference/current_theme.html",
    "href": "reference/current_theme.html",
    "title": "current_theme",
    "section": "",
    "text": "current_theme\noptions.current_theme"
  },
  {
    "objectID": "reference/dpi.html",
    "href": "reference/dpi.html",
    "title": "dpi",
    "section": "",
    "text": "dpi\noptions.dpi"
  },
  {
    "objectID": "reference/economics_long.html",
    "href": "reference/economics_long.html",
    "title": "economics_long",
    "section": "",
    "text": "economics_long\ndata.economics_long\n::: {.description} US economic time series.\nDescription\nThis dataset was produced from US economic time series data available from http://research.stlouisfed.org/fred2. economics is in “wide” format, economics_long is in “long” format.\nFormat\nA data frame with 478 rows and 6 variables\n\n\n\nColumn\nDescription\n\n\n\n\ndate\nMonth of data collection\n\n\npsavert\npersonal savings rate 1\n\n\npce\npersonal consumption expenditures, in billions of dollars 2\n\n\nunemploy\nnumber of unemployed in thousands 3\n\n\nuempmed\nmedian duration of unemployment, in week 4\n\n\npop\ntotal population, in thousands 5\n\n\n\n\n\n\n\n\nFootnotes\n\n\n↩︎\n↩︎\n↩︎\n↩︎\n :::↩︎"
  },
  {
    "objectID": "reference/element_rect.html",
    "href": "reference/element_rect.html",
    "title": "element_rect",
    "section": "",
    "text": "themes.element_rect(self, fill=None, color=None, size=None, linetype=None, colour=None, **kwargs)\n\n\nTheme element: Rectangle\nUsed for backgrounds and borders\n\n\n\n\nfill: str | tuple = None\n\nRectangle background color\n\ncolor: str | tuple = None\n\nLine color\n\ncolour: str | tuple = None\n\nAlias of color\n\nsize: float = None\n\nLine thickness\n\nkwargs: dict = {}\n\nParameters recognised by :class:matplotlib.patches.Rectangle. In some cases you can use the fancy parameters from :class:matplotlib.patches.FancyBboxPatch."
  },
  {
    "objectID": "reference/element_rect.html#parameters",
    "href": "reference/element_rect.html#parameters",
    "title": "element_rect",
    "section": "",
    "text": "fill: str | tuple = None\n\nRectangle background color\n\ncolor: str | tuple = None\n\nLine color\n\ncolour: str | tuple = None\n\nAlias of color\n\nsize: float = None\n\nLine thickness\n\nkwargs: dict = {}\n\nParameters recognised by :class:matplotlib.patches.Rectangle. In some cases you can use the fancy parameters from :class:matplotlib.patches.FancyBboxPatch."
  },
  {
    "objectID": "reference/expand_limits.html",
    "href": "reference/expand_limits.html",
    "title": "expand_limits",
    "section": "",
    "text": "scales.expand_limits(**kwargs)\n\n\nExpand the limits any aesthetic using data\n\n\n\n\nkwargs: dict | dataframe = {}\n\nData to use in expanding the limits. The keys should be aesthetic names e.g. x, y, colour, …"
  },
  {
    "objectID": "reference/expand_limits.html#parameters",
    "href": "reference/expand_limits.html#parameters",
    "title": "expand_limits",
    "section": "",
    "text": "kwargs: dict | dataframe = {}\n\nData to use in expanding the limits. The keys should be aesthetic names e.g. x, y, colour, …"
  },
  {
    "objectID": "reference/facet_grid.html",
    "href": "reference/facet_grid.html",
    "title": "facet_grid",
    "section": "",
    "text": "facets.facet_grid(self, facets, margins=False, scales='fixed', space='fixed', shrink=True, labeller='label_value', as_table=True, drop=True)\n\n\nWrap 1D Panels onto 2D surface\n\n\n\n\nfacets: str | tuple | list\n\nA formula with the rows (of the tabular display) on the LHS and the columns (of the tabular display) on the RHS; the dot in the formula is used to indicate there should be no faceting on this dimension (either row or column). If a tuple/list is used, it must of size two, the elements of which must be strings or lists. If string formula is not processed as you may expect, use tuple/list. For example, the follow two specifications are equivalent:\n\"func(var4) ~ func(var1+var3) + func(var2)\"\n\n[\"func(var4)\", (\"func(var1+var3)\", \"func(var2)\")]\nThere may be cases where you cannot use a use a pure string formula, e.g.\n['var4', ('var1+var3', 'var2')]\n\nmargins: bool | list[str] = False\n\nvariable names to compute margins for. True will compute all possible margins.\n\nspace: str | dict = ‘fixed’\n\nControl the size of the x or y sides of the panels. The size also depends to the scales parameter.\nIf a string, it should be one of ['fixed', 'free', 'free_x', 'free_y']. Currently, only the 'fixed' option is supported.\nAlternatively if a dict, it indicates the relative facet size ratios such as:\n{\"x\": [1, 2], \"y\": [3, 1, 1]}\nThis means that in the horizontal direction, the second panel will be twice the length of the first. In the vertical direction the top facet will be the 3 times longer then the second and third facets.\nNote that the number of dimensions in the list must equal the number of facets that will be produced.\n\nshrink: bool = True\n\nWhether to shrink the scales to the output of the statistics instead of the raw data.\n\nlabeller: str | callable = “label_value”\n\nHow to label the facets. A string value if it should be one of [\"label_value\", \"label_both\", \"label_context\"].\n\nas_table: bool = True\n\nIf True, the facets are laid out like a table with the highest values at the bottom-right. If False the facets are laid out like a plot with the highest value a the top-right\n\ndrop: bool = True\n\nIf True, all factor levels not used in the data will automatically be dropped. If False, all factor levels will be shown, regardless of whether or not they appear in the data."
  },
  {
    "objectID": "reference/facet_grid.html#parameters",
    "href": "reference/facet_grid.html#parameters",
    "title": "facet_grid",
    "section": "",
    "text": "facets: str | tuple | list\n\nA formula with the rows (of the tabular display) on the LHS and the columns (of the tabular display) on the RHS; the dot in the formula is used to indicate there should be no faceting on this dimension (either row or column). If a tuple/list is used, it must of size two, the elements of which must be strings or lists. If string formula is not processed as you may expect, use tuple/list. For example, the follow two specifications are equivalent:\n\"func(var4) ~ func(var1+var3) + func(var2)\"\n\n[\"func(var4)\", (\"func(var1+var3)\", \"func(var2)\")]\nThere may be cases where you cannot use a use a pure string formula, e.g.\n['var4', ('var1+var3', 'var2')]\n\nmargins: bool | list[str] = False\n\nvariable names to compute margins for. True will compute all possible margins.\n\nspace: str | dict = ‘fixed’\n\nControl the size of the x or y sides of the panels. The size also depends to the scales parameter.\nIf a string, it should be one of ['fixed', 'free', 'free_x', 'free_y']. Currently, only the 'fixed' option is supported.\nAlternatively if a dict, it indicates the relative facet size ratios such as:\n{\"x\": [1, 2], \"y\": [3, 1, 1]}\nThis means that in the horizontal direction, the second panel will be twice the length of the first. In the vertical direction the top facet will be the 3 times longer then the second and third facets.\nNote that the number of dimensions in the list must equal the number of facets that will be produced.\n\nshrink: bool = True\n\nWhether to shrink the scales to the output of the statistics instead of the raw data.\n\nlabeller: str | callable = “label_value”\n\nHow to label the facets. A string value if it should be one of [\"label_value\", \"label_both\", \"label_context\"].\n\nas_table: bool = True\n\nIf True, the facets are laid out like a table with the highest values at the bottom-right. If False the facets are laid out like a plot with the highest value a the top-right\n\ndrop: bool = True\n\nIf True, all factor levels not used in the data will automatically be dropped. If False, all factor levels will be shown, regardless of whether or not they appear in the data."
  },
  {
    "objectID": "reference/facet_wrap.html",
    "href": "reference/facet_wrap.html",
    "title": "facet_wrap",
    "section": "",
    "text": "facets.facet_wrap(self, facets, *, nrow=None, ncol=None, scales='fixed', shrink=True, labeller='label_value', as_table=True, drop=True, dir='h')\n\n\nWrap 1D Panels onto 2D surface\n\n\n\n\nfacets: str | tuple\n\nVariables to groupby and plot on different panels. If a string formula is used it should be right sided, e.g \"~ a + b\", (\"a\", \"b\")\n\nnrow: int = None\n\nNumber of rows\n\nncol: int = None\n\nNumber of columns\n\nscales: ‘fixed’ | ‘free’ | ‘free_x’ | ‘free_y’ = “fixed”\n\nWhether x or y scales should be allowed (free) to vary according to the data on each of the panel.\n\nshrink: bool = True\n\nWhether to shrink the scales to the output of the statistics instead of the raw data.\n\nlabeller: str | callable = “label_value”\n\nHow to label the facets. A string value if it should be one of [\"label_value\", \"label_both\", \"label_context\"].\n\nas_table: bool = True\n\nIf True, the facets are laid out like a table with the highest values at the bottom-right. If False the facets are laid out like a plot with the highest value a the top-right\n\ndrop: bool = True\n\nIf True, all factor levels not used in the data will automatically be dropped. If False, all factor levels will be shown, regardless of whether or not they appear in the data.\n\ndir: ‘h’ | ‘v’ = “h”\n\nDirection in which to layout the panels. h for horizontal and v for vertical."
  },
  {
    "objectID": "reference/facet_wrap.html#parameters",
    "href": "reference/facet_wrap.html#parameters",
    "title": "facet_wrap",
    "section": "",
    "text": "facets: str | tuple\n\nVariables to groupby and plot on different panels. If a string formula is used it should be right sided, e.g \"~ a + b\", (\"a\", \"b\")\n\nnrow: int = None\n\nNumber of rows\n\nncol: int = None\n\nNumber of columns\n\nscales: ‘fixed’ | ‘free’ | ‘free_x’ | ‘free_y’ = “fixed”\n\nWhether x or y scales should be allowed (free) to vary according to the data on each of the panel.\n\nshrink: bool = True\n\nWhether to shrink the scales to the output of the statistics instead of the raw data.\n\nlabeller: str | callable = “label_value”\n\nHow to label the facets. A string value if it should be one of [\"label_value\", \"label_both\", \"label_context\"].\n\nas_table: bool = True\n\nIf True, the facets are laid out like a table with the highest values at the bottom-right. If False the facets are laid out like a plot with the highest value a the top-right\n\ndrop: bool = True\n\nIf True, all factor levels not used in the data will automatically be dropped. If False, all factor levels will be shown, regardless of whether or not they appear in the data.\n\ndir: ‘h’ | ‘v’ = “h”\n\nDirection in which to layout the panels. h for horizontal and v for vertical."
  },
  {
    "objectID": "reference/faithfuld.html",
    "href": "reference/faithfuld.html",
    "title": "faithfuld",
    "section": "",
    "text": "faithfuld\ndata.faithfuld\n\nOld Faithful Geyser Data\nDescription\nWaiting time between eruptions and the duration of the eruption for the Old Faithful geyser in Yellowstone National Park, Wyoming, USA.\nFormat\nA data frame with grid data for 272 observations on 2 variables and the density at those locations.\n\n\n\nColumn\nDescription\n\n\n\n\neruptions\nEruption time in mins\n\n\nwaiting W\naiting time to next eruption (in mins)\n\n\ndensity D\nensity Estimate\n\n\n\nDetails\nA closer look at faithful.eruptions reveals that these are heavily rounded times originally in seconds, where multiples of 5 are more frequent than expected under non-human measurement. For a better version of the eruption times, see the example below.\nThere are many versions of this dataset around: Azzalini and Bowman (1990) use a more complete version.\nSource\nW. Härdle.\nReferences\nHärdle, W. (1991) Smoothing Techniques with Implementation in S. New York: Springer.\nAzzalini, A. and Bowman, A. W. (1990). A look at some data on the Old Faithful geyser. Applied Statistics 39, 357–365."
  },
  {
    "objectID": "reference/geom.html",
    "href": "reference/geom.html",
    "title": "geom",
    "section": "",
    "text": "geom\n\ngeoms.geom.geom(self, mapping=None, data=None, **kwargs)\n\n\nBase class of all Geoms"
  },
  {
    "objectID": "reference/geom_area.html",
    "href": "reference/geom_area.html",
    "title": "geom_area",
    "section": "",
    "text": "geoms.geom_area()\n\n\nArea plot\nAn area plot is a special case of geom_ribbon, where the minimum of the range is fixed to 0, and the position adjustment defaults to ‘stack’.\nUsage\ngeom_area(mapping=None, data=None, stat='identity', position='stack',\n          na_rm=False, inherit_aes=True, show_legend=None, raster=False,\n          outline_type='upper', **kwargs)\nOnly the data and mapping can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the stat.\n\n\n\n\nmapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\n'none'\n\n\n\n\nfill\n\n\n'#333333'\n\n\n\n\ngroup\n\n\n\n\n\n\nlinetype\n\n\n'solid'\n\n\n\n\nsize\n\n\n0.5\n\n\n\n\nwhere\n\n\nTrue\n\n\n\n\nThe bold aesthetics are required.\nAesthetics Descriptions\n\nwhere\n\nDefine where to exclude horizontal regions from being filled. Regions between any two False values are skipped. For sensible demarcation the value used in the where predicate expression should match the ymin value or expression. i.e.\n aes(ymin=0, ymax='col1', where='col1 &gt; 0')  # good\n aes(ymin=0, ymax='col1', where='col1 &gt; 10')  # bad\n\n aes(ymin=col2, ymax='col1', where='col1 &gt; col2')  # good\n aes(ymin=col2, ymax='col1', where='col1 &gt; col3')  # bad\n\n\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “identity”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “stack”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\n\n\n\n\n\nplotnine.geoms.geom_ribbon"
  },
  {
    "objectID": "reference/geom_area.html#parameters",
    "href": "reference/geom_area.html#parameters",
    "title": "geom_area",
    "section": "",
    "text": "mapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\n'none'\n\n\n\n\nfill\n\n\n'#333333'\n\n\n\n\ngroup\n\n\n\n\n\n\nlinetype\n\n\n'solid'\n\n\n\n\nsize\n\n\n0.5\n\n\n\n\nwhere\n\n\nTrue\n\n\n\n\nThe bold aesthetics are required.\nAesthetics Descriptions\n\nwhere\n\nDefine where to exclude horizontal regions from being filled. Regions between any two False values are skipped. For sensible demarcation the value used in the where predicate expression should match the ymin value or expression. i.e.\n aes(ymin=0, ymax='col1', where='col1 &gt; 0')  # good\n aes(ymin=0, ymax='col1', where='col1 &gt; 10')  # bad\n\n aes(ymin=col2, ymax='col1', where='col1 &gt; col2')  # good\n aes(ymin=col2, ymax='col1', where='col1 &gt; col3')  # bad\n\n\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “identity”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “stack”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format."
  },
  {
    "objectID": "reference/geom_area.html#see-also",
    "href": "reference/geom_area.html#see-also",
    "title": "geom_area",
    "section": "",
    "text": "plotnine.geoms.geom_ribbon"
  },
  {
    "objectID": "reference/geom_bin_2d.html",
    "href": "reference/geom_bin_2d.html",
    "title": "geom_bin_2d",
    "section": "",
    "text": "geoms.geom_bin_2d()\n\n\nHeatmap of 2d bin counts\nDivides the plane into rectangles, counts the number of cases in each rectangle, and then (by default) maps the number of cases to the rectangle’s fill. This is a useful alternative to geom_point in the presence of overplotting.\nUsage\ngeom_bin_2d(mapping=None, data=None, stat='bin_2d', position='identity',\n            na_rm=False, inherit_aes=True, show_legend=None, raster=False,\n            **kwargs)\nOnly the data and mapping can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the stat.\n\n\n\n\nmapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nxmax\n\n\n\n\n\n\nxmin\n\n\n\n\n\n\nymax\n\n\n\n\n\n\nymin\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\nNone\n\n\n\n\nfill\n\n\n'#595959'\n\n\n\n\ngroup\n\n\n\n\n\n\nlinetype\n\n\n'solid'\n\n\n\n\nsize\n\n\n0.5\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “bin_2d”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format."
  },
  {
    "objectID": "reference/geom_bin_2d.html#parameters",
    "href": "reference/geom_bin_2d.html#parameters",
    "title": "geom_bin_2d",
    "section": "",
    "text": "mapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nxmax\n\n\n\n\n\n\nxmin\n\n\n\n\n\n\nymax\n\n\n\n\n\n\nymin\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\nNone\n\n\n\n\nfill\n\n\n'#595959'\n\n\n\n\ngroup\n\n\n\n\n\n\nlinetype\n\n\n'solid'\n\n\n\n\nsize\n\n\n0.5\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “bin_2d”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format."
  },
  {
    "objectID": "reference/geom_boxplot.html",
    "href": "reference/geom_boxplot.html",
    "title": "geom_boxplot",
    "section": "",
    "text": "geoms.geom_boxplot(self, mapping=None, data=None, **kwargs)\n\n\nBox and whiskers plot\nUsage\ngeom_boxplot(mapping=None, data=None, stat='boxplot', position='dodge2',\n             na_rm=False, inherit_aes=True, show_legend=None, raster=False,\n             varwidth=False, outlier_shape='o', outlier_stroke=0.5,\n             notch=False, width=None, outlier_alpha=1, outlier_color=None,\n             notchwidth=0.5, outlier_size=1.5, fatten=2, **kwargs)\nOnly the data and mapping can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the stat.\n\n\n\n\nmapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nlower\n\n\n\n\n\n\nmiddle\n\n\n\n\n\n\nupper\n\n\n\n\n\n\nx\n\n\n\n\n\n\nymax\n\n\n\n\n\n\nymin\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\n'#333333'\n\n\n\n\nfill\n\n\n'white'\n\n\n\n\ngroup\n\n\n\n\n\n\nlinetype\n\n\n'solid'\n\n\n\n\nshape\n\n\n'o'\n\n\n\n\nsize\n\n\n0.5\n\n\n\n\nweight\n\n\n1\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “boxplot”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “dodge2”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\nwidth: float = None\n\nBox width. If None, the width is set to 90% of the resolution of the data. Note that if the stat has a width parameter, that takes precedence over this one.\n\noutlier_alpha: float = 1\n\nTransparency of the outlier points.\n\noutlier_color: str | tuple = None\n\nColor of the outlier points.\n\noutlier_shape: str = “o”\n\nShape of the outlier points. An empty string hides the outliers.\n\noutlier_size: float = 1.5\n\nSize of the outlier points.\n\noutlier_stroke: float = 0.5\n\nStroke-size of the outlier points.\n\nnotch: bool = False\n\nWhether the boxes should have a notch.\n\nvarwidth: bool = False\n\nIf True, boxes are drawn with widths proportional to the square-roots of the number of observations in the groups.\n\nnotchwidth: float = 0.5\n\nWidth of notch relative to the body width.\n\nfatten: float = 2\n\nA multiplicative factor used to increase the size of the middle bar across the box."
  },
  {
    "objectID": "reference/geom_boxplot.html#parameters",
    "href": "reference/geom_boxplot.html#parameters",
    "title": "geom_boxplot",
    "section": "",
    "text": "mapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nlower\n\n\n\n\n\n\nmiddle\n\n\n\n\n\n\nupper\n\n\n\n\n\n\nx\n\n\n\n\n\n\nymax\n\n\n\n\n\n\nymin\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\n'#333333'\n\n\n\n\nfill\n\n\n'white'\n\n\n\n\ngroup\n\n\n\n\n\n\nlinetype\n\n\n'solid'\n\n\n\n\nshape\n\n\n'o'\n\n\n\n\nsize\n\n\n0.5\n\n\n\n\nweight\n\n\n1\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “boxplot”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “dodge2”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\nwidth: float = None\n\nBox width. If None, the width is set to 90% of the resolution of the data. Note that if the stat has a width parameter, that takes precedence over this one.\n\noutlier_alpha: float = 1\n\nTransparency of the outlier points.\n\noutlier_color: str | tuple = None\n\nColor of the outlier points.\n\noutlier_shape: str = “o”\n\nShape of the outlier points. An empty string hides the outliers.\n\noutlier_size: float = 1.5\n\nSize of the outlier points.\n\noutlier_stroke: float = 0.5\n\nStroke-size of the outlier points.\n\nnotch: bool = False\n\nWhether the boxes should have a notch.\n\nvarwidth: bool = False\n\nIf True, boxes are drawn with widths proportional to the square-roots of the number of observations in the groups.\n\nnotchwidth: float = 0.5\n\nWidth of notch relative to the body width.\n\nfatten: float = 2\n\nA multiplicative factor used to increase the size of the middle bar across the box."
  },
  {
    "objectID": "reference/geom_count.html",
    "href": "reference/geom_count.html",
    "title": "geom_count",
    "section": "",
    "text": "geoms.geom_count()\n\n\nPlot overlapping points\nThis is a variant geom_point that counts the number of observations at each location, then maps the count to point area. It useful when you have discrete data and overplotting.\nUsage\ngeom_count(mapping=None, data=None, stat='sum', position='identity',\n           na_rm=False, inherit_aes=True, show_legend=None, raster=False,\n           **kwargs)\nOnly the data and mapping can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the stat.\n\n\n\n\nmapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\n'black'\n\n\n\n\nfill\n\n\nNone\n\n\n\n\ngroup\n\n\n\n\n\n\nshape\n\n\n'o'\n\n\n\n\nsize\n\n\n1.5\n\n\n\n\nstroke\n\n\n0.5\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “sum”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format."
  },
  {
    "objectID": "reference/geom_count.html#parameters",
    "href": "reference/geom_count.html#parameters",
    "title": "geom_count",
    "section": "",
    "text": "mapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\n'black'\n\n\n\n\nfill\n\n\nNone\n\n\n\n\ngroup\n\n\n\n\n\n\nshape\n\n\n'o'\n\n\n\n\nsize\n\n\n1.5\n\n\n\n\nstroke\n\n\n0.5\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “sum”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format."
  },
  {
    "objectID": "reference/geom_density.html",
    "href": "reference/geom_density.html",
    "title": "geom_density",
    "section": "",
    "text": "geoms.geom_density()\n\n\nSmooth density estimate\nUsage\ngeom_density(mapping=None, data=None, stat='density', position='identity',\n             na_rm=False, inherit_aes=True, show_legend=None, raster=False,\n             outline_type='upper', **kwargs)\nOnly the data and mapping can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the stat.\n\n\n\n\nmapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\n'black'\n\n\n\n\nfill\n\n\nNone\n\n\n\n\ngroup\n\n\n\n\n\n\nlinetype\n\n\n'solid'\n\n\n\n\nsize\n\n\n0.5\n\n\n\n\nweight\n\n\n1\n\n\n\n\nwhere\n\n\nTrue\n\n\n\n\nThe bold aesthetics are required.\nAesthetics Descriptions\n\nwhere\n\nDefine where to exclude horizontal regions from being filled. Regions between any two False values are skipped. For sensible demarcation the value used in the where predicate expression should match the ymin value or expression. i.e.\n aes(ymin=0, ymax='col1', where='col1 &gt; 0')  # good\n aes(ymin=0, ymax='col1', where='col1 &gt; 10')  # bad\n\n aes(ymin=col2, ymax='col1', where='col1 &gt; col2')  # good\n aes(ymin=col2, ymax='col1', where='col1 &gt; col3')  # bad\n\n\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “density”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\n\n\n\n\n\nplotnine.geoms.geom_ribbon"
  },
  {
    "objectID": "reference/geom_density.html#parameters",
    "href": "reference/geom_density.html#parameters",
    "title": "geom_density",
    "section": "",
    "text": "mapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\n'black'\n\n\n\n\nfill\n\n\nNone\n\n\n\n\ngroup\n\n\n\n\n\n\nlinetype\n\n\n'solid'\n\n\n\n\nsize\n\n\n0.5\n\n\n\n\nweight\n\n\n1\n\n\n\n\nwhere\n\n\nTrue\n\n\n\n\nThe bold aesthetics are required.\nAesthetics Descriptions\n\nwhere\n\nDefine where to exclude horizontal regions from being filled. Regions between any two False values are skipped. For sensible demarcation the value used in the where predicate expression should match the ymin value or expression. i.e.\n aes(ymin=0, ymax='col1', where='col1 &gt; 0')  # good\n aes(ymin=0, ymax='col1', where='col1 &gt; 10')  # bad\n\n aes(ymin=col2, ymax='col1', where='col1 &gt; col2')  # good\n aes(ymin=col2, ymax='col1', where='col1 &gt; col3')  # bad\n\n\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “density”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format."
  },
  {
    "objectID": "reference/geom_density.html#see-also",
    "href": "reference/geom_density.html#see-also",
    "title": "geom_density",
    "section": "",
    "text": "plotnine.geoms.geom_ribbon"
  },
  {
    "objectID": "reference/geom_dotplot.html",
    "href": "reference/geom_dotplot.html",
    "title": "geom_dotplot",
    "section": "",
    "text": "geoms.geom_dotplot()\n\n\nDot plot\nUsage\ngeom_dotplot(mapping=None, data=None, stat='bindot', position='identity',\n             na_rm=False, inherit_aes=True, show_legend=None, raster=False,\n             stackgroups=False, dotsize=1, stackdir='up', stackratio=1,\n             **kwargs)\nOnly the data and mapping can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the stat.\n\n\n\n\nmapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\n'black'\n\n\n\n\nfill\n\n\n'black'\n\n\n\n\ngroup\n\n\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “bindot”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\nstackdir: “up” | “down” | “center”, | “centerwhole” = “up”\n\nDirection in which to stack the dots. Options are\n\nstackratio: float = 1\n\nHow close to stack the dots. If value is less than 1, the dots overlap, if greater than 1 they are spaced.\n\ndotsize: float = 1\n\nDiameter of dots relative to binwidth.\n\nstackgroups: bool = False\n\nIf True, the dots are stacked across groups.\n\n\n\n\n\n\nplotnine.stats.statbindot"
  },
  {
    "objectID": "reference/geom_dotplot.html#parameters",
    "href": "reference/geom_dotplot.html#parameters",
    "title": "geom_dotplot",
    "section": "",
    "text": "mapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\n'black'\n\n\n\n\nfill\n\n\n'black'\n\n\n\n\ngroup\n\n\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “bindot”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\nstackdir: “up” | “down” | “center”, | “centerwhole” = “up”\n\nDirection in which to stack the dots. Options are\n\nstackratio: float = 1\n\nHow close to stack the dots. If value is less than 1, the dots overlap, if greater than 1 they are spaced.\n\ndotsize: float = 1\n\nDiameter of dots relative to binwidth.\n\nstackgroups: bool = False\n\nIf True, the dots are stacked across groups."
  },
  {
    "objectID": "reference/geom_dotplot.html#see-also",
    "href": "reference/geom_dotplot.html#see-also",
    "title": "geom_dotplot",
    "section": "",
    "text": "plotnine.stats.statbindot"
  },
  {
    "objectID": "reference/geom_errorbarh.html",
    "href": "reference/geom_errorbarh.html",
    "title": "geom_errorbarh",
    "section": "",
    "text": "geoms.geom_errorbarh()\n\n\nHorizontal interval represented as an errorbar\nUsage\ngeom_errorbarh(mapping=None, data=None, stat='identity', position='identity',\n               na_rm=False, inherit_aes=True, show_legend=None, raster=False,\n               height=0.5, **kwargs)\nOnly the data and mapping can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the stat.\n\n\n\n\nmapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nxmax\n\n\n\n\n\n\nxmin\n\n\n\n\n\n\ny\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\n'black'\n\n\n\n\ngroup\n\n\n\n\n\n\nlinetype\n\n\n'solid'\n\n\n\n\nsize\n\n\n0.5\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “identity”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\nheight: float = 0.5\n\nBar height as a fraction of the resolution of the data."
  },
  {
    "objectID": "reference/geom_errorbarh.html#parameters",
    "href": "reference/geom_errorbarh.html#parameters",
    "title": "geom_errorbarh",
    "section": "",
    "text": "mapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nxmax\n\n\n\n\n\n\nxmin\n\n\n\n\n\n\ny\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\n'black'\n\n\n\n\ngroup\n\n\n\n\n\n\nlinetype\n\n\n'solid'\n\n\n\n\nsize\n\n\n0.5\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “identity”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\nheight: float = 0.5\n\nBar height as a fraction of the resolution of the data."
  },
  {
    "objectID": "reference/geom_histogram.html",
    "href": "reference/geom_histogram.html",
    "title": "geom_histogram",
    "section": "",
    "text": "geoms.geom_histogram()\n\n\nHistogram\nUsage\ngeom_histogram(mapping=None, data=None, stat='bin', position='stack',\n               na_rm=False, inherit_aes=True, show_legend=None, raster=False,\n               **kwargs)\nOnly the data and mapping can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the stat.\n\n\n\n\nmapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\nNone\n\n\n\n\nfill\n\n\n'#595959'\n\n\n\n\ngroup\n\n\n\n\n\n\nlinetype\n\n\n'solid'\n\n\n\n\nsize\n\n\n0.5\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “bin”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “stack”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\n\n\n\n\n\nplotnine.geoms.geom_bar"
  },
  {
    "objectID": "reference/geom_histogram.html#parameters",
    "href": "reference/geom_histogram.html#parameters",
    "title": "geom_histogram",
    "section": "",
    "text": "mapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\nNone\n\n\n\n\nfill\n\n\n'#595959'\n\n\n\n\ngroup\n\n\n\n\n\n\nlinetype\n\n\n'solid'\n\n\n\n\nsize\n\n\n0.5\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “bin”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “stack”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format."
  },
  {
    "objectID": "reference/geom_histogram.html#see-also",
    "href": "reference/geom_histogram.html#see-also",
    "title": "geom_histogram",
    "section": "",
    "text": "plotnine.geoms.geom_bar"
  },
  {
    "objectID": "reference/geom_jitter.html",
    "href": "reference/geom_jitter.html",
    "title": "geom_jitter",
    "section": "",
    "text": "geoms.geom_jitter(self, mapping=None, data=None, **kwargs)\n\n\nScatter plot with points jittered to reduce overplotting\nUsage\ngeom_jitter(mapping=None, data=None, stat='identity', position='jitter',\n            na_rm=False, inherit_aes=True, show_legend=None, raster=False,\n            width=None, height=None, random_state=None, **kwargs)\nOnly the data and mapping can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the stat.\n\n\n\n\nmapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\n'black'\n\n\n\n\nfill\n\n\nNone\n\n\n\n\ngroup\n\n\n\n\n\n\nshape\n\n\n'o'\n\n\n\n\nsize\n\n\n1.5\n\n\n\n\nstroke\n\n\n0.5\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “identity”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “jitter”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\nwidth: float = None\n\nProportion to jitter in horizontal direction. The default value is that from position_jitter\n\nheight: float = None\n\nProportion to jitter in vertical direction. The default value is that from position_jitter.\n\nrandom_state: int | ~numpy.random.RandomState = None\n\nSeed or Random number generator to use. If None, then numpy global generator :class:numpy.random is used.\n\n\n\n\n\n\nplotnine.positions.position_jitter\n\n\n\nplotnine.geoms.geom_point"
  },
  {
    "objectID": "reference/geom_jitter.html#parameters",
    "href": "reference/geom_jitter.html#parameters",
    "title": "geom_jitter",
    "section": "",
    "text": "mapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\n'black'\n\n\n\n\nfill\n\n\nNone\n\n\n\n\ngroup\n\n\n\n\n\n\nshape\n\n\n'o'\n\n\n\n\nsize\n\n\n1.5\n\n\n\n\nstroke\n\n\n0.5\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “identity”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “jitter”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\nwidth: float = None\n\nProportion to jitter in horizontal direction. The default value is that from position_jitter\n\nheight: float = None\n\nProportion to jitter in vertical direction. The default value is that from position_jitter.\n\nrandom_state: int | ~numpy.random.RandomState = None\n\nSeed or Random number generator to use. If None, then numpy global generator :class:numpy.random is used."
  },
  {
    "objectID": "reference/geom_jitter.html#see-also",
    "href": "reference/geom_jitter.html#see-also",
    "title": "geom_jitter",
    "section": "",
    "text": "plotnine.positions.position_jitter\n\n\n\nplotnine.geoms.geom_point"
  },
  {
    "objectID": "reference/geom_line.html",
    "href": "reference/geom_line.html",
    "title": "geom_line",
    "section": "",
    "text": "geoms.geom_line()\n\n\nConnected points\nUsage\ngeom_line(mapping=None, data=None, stat='identity', position='identity',\n          na_rm=False, inherit_aes=True, show_legend=None, raster=False,\n          lineend='butt', arrow=None, linejoin='round', **kwargs)\nOnly the data and mapping can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the stat.\n\n\n\n\nmapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\n'black'\n\n\n\n\ngroup\n\n\n\n\n\n\nlinetype\n\n\n'solid'\n\n\n\n\nsize\n\n\n0.5\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “identity”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\n\n\n\n\n\nplotnine.geoms.geom_path\n\nFor documentation of other parameters."
  },
  {
    "objectID": "reference/geom_line.html#parameters",
    "href": "reference/geom_line.html#parameters",
    "title": "geom_line",
    "section": "",
    "text": "mapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\n'black'\n\n\n\n\ngroup\n\n\n\n\n\n\nlinetype\n\n\n'solid'\n\n\n\n\nsize\n\n\n0.5\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “identity”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format."
  },
  {
    "objectID": "reference/geom_line.html#see-also",
    "href": "reference/geom_line.html#see-also",
    "title": "geom_line",
    "section": "",
    "text": "plotnine.geoms.geom_path\n\nFor documentation of other parameters."
  },
  {
    "objectID": "reference/geom_map.html",
    "href": "reference/geom_map.html",
    "title": "geom_map",
    "section": "",
    "text": "geoms.geom_map(self, mapping=None, data=None, **kwargs)\n\n\nDraw map feature\nThe map feature are drawn without any special projections.\nUsage\ngeom_map(mapping=None, data=None, stat='identity', position='identity',\n         na_rm=False, inherit_aes=True, show_legend=None, raster=False,\n         **kwargs)\nOnly the data and mapping can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the stat.\n\n\n\n\nmapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\ngeometry\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\n'#111111'\n\n\n\n\nfill\n\n\n'#333333'\n\n\n\n\ngroup\n\n\n\n\n\n\nlinetype\n\n\n'solid'\n\n\n\n\nshape\n\n\n'o'\n\n\n\n\nsize\n\n\n0.5\n\n\n\n\nstroke\n\n\n0.5\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “identity”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\n\n\n\n\nThis geom is best suited for plotting a shapefile read into geopandas dataframe. The dataframe should have a geometry column."
  },
  {
    "objectID": "reference/geom_map.html#parameters",
    "href": "reference/geom_map.html#parameters",
    "title": "geom_map",
    "section": "",
    "text": "mapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\ngeometry\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\n'#111111'\n\n\n\n\nfill\n\n\n'#333333'\n\n\n\n\ngroup\n\n\n\n\n\n\nlinetype\n\n\n'solid'\n\n\n\n\nshape\n\n\n'o'\n\n\n\n\nsize\n\n\n0.5\n\n\n\n\nstroke\n\n\n0.5\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “identity”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format."
  },
  {
    "objectID": "reference/geom_map.html#notes",
    "href": "reference/geom_map.html#notes",
    "title": "geom_map",
    "section": "",
    "text": "This geom is best suited for plotting a shapefile read into geopandas dataframe. The dataframe should have a geometry column."
  },
  {
    "objectID": "reference/geom_path:arrow.html",
    "href": "reference/geom_path:arrow.html",
    "title": "geom_path:arrow",
    "section": "",
    "text": "geoms.geom_path.arrow(self, angle=30, length=0.2, ends='last', type='open')\n\n\nDefine arrow (actually an arrowhead)\nThis is used to define arrow heads for geom_path.\n\n\n\n\nangle: int | float = 30\n\nangle in degrees between the tail a single edge.\n\nlength: int | float = 0.2\n\nof the edge in “inches”\n\nends: ‘last’ | ‘first’ | ‘both’ = ‘last’\n\nAt which end of the line to draw the arrowhead\n\ntype: ‘open’ | ‘closed’ = ‘open’\n\nWhen it is closed, it is also filled"
  },
  {
    "objectID": "reference/geom_path:arrow.html#parameters",
    "href": "reference/geom_path:arrow.html#parameters",
    "title": "geom_path:arrow",
    "section": "",
    "text": "angle: int | float = 30\n\nangle in degrees between the tail a single edge.\n\nlength: int | float = 0.2\n\nof the edge in “inches”\n\nends: ‘last’ | ‘first’ | ‘both’ = ‘last’\n\nAt which end of the line to draw the arrowhead\n\ntype: ‘open’ | ‘closed’ = ‘open’\n\nWhen it is closed, it is also filled"
  },
  {
    "objectID": "reference/geom_pointdensity.html",
    "href": "reference/geom_pointdensity.html",
    "title": "geom_pointdensity",
    "section": "",
    "text": "geoms.geom_pointdensity()\n\n\nScatterplot with density estimation at each point\nUsage\ngeom_pointdensity(mapping=None, data=None, stat='pointdensity',\n                  position='identity', na_rm=False, inherit_aes=True,\n                  show_legend=None, raster=False, **kwargs)\nOnly the data and mapping can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the stat.\n\n\n\n\nmapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\n'black'\n\n\n\n\nfill\n\n\nNone\n\n\n\n\ngroup\n\n\n\n\n\n\nshape\n\n\n'o'\n\n\n\n\nsize\n\n\n1.5\n\n\n\n\nstroke\n\n\n0.5\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “pointdensity”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format."
  },
  {
    "objectID": "reference/geom_pointdensity.html#parameters",
    "href": "reference/geom_pointdensity.html#parameters",
    "title": "geom_pointdensity",
    "section": "",
    "text": "mapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\n'black'\n\n\n\n\nfill\n\n\nNone\n\n\n\n\ngroup\n\n\n\n\n\n\nshape\n\n\n'o'\n\n\n\n\nsize\n\n\n1.5\n\n\n\n\nstroke\n\n\n0.5\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “pointdensity”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format."
  },
  {
    "objectID": "reference/geom_polygon.html",
    "href": "reference/geom_polygon.html",
    "title": "geom_polygon",
    "section": "",
    "text": "geoms.geom_polygon()\n\n\nPolygon, a filled path\nUsage\ngeom_polygon(mapping=None, data=None, stat='identity', position='identity',\n             na_rm=False, inherit_aes=True, show_legend=None, raster=False,\n             **kwargs)\nOnly the data and mapping can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the stat.\n\n\n\n\nmapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\nNone\n\n\n\n\nfill\n\n\n'#333333'\n\n\n\n\ngroup\n\n\n\n\n\n\nlinetype\n\n\n'solid'\n\n\n\n\nsize\n\n\n0.5\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “identity”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\n\n\n\n\nAll paths in the same group aesthetic value make up a polygon."
  },
  {
    "objectID": "reference/geom_polygon.html#parameters",
    "href": "reference/geom_polygon.html#parameters",
    "title": "geom_polygon",
    "section": "",
    "text": "mapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\nNone\n\n\n\n\nfill\n\n\n'#333333'\n\n\n\n\ngroup\n\n\n\n\n\n\nlinetype\n\n\n'solid'\n\n\n\n\nsize\n\n\n0.5\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “identity”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format."
  },
  {
    "objectID": "reference/geom_polygon.html#notes",
    "href": "reference/geom_polygon.html#notes",
    "title": "geom_polygon",
    "section": "",
    "text": "All paths in the same group aesthetic value make up a polygon."
  },
  {
    "objectID": "reference/geom_qq_line.html",
    "href": "reference/geom_qq_line.html",
    "title": "geom_qq_line",
    "section": "",
    "text": "geoms.geom_qq_line()\n\n\nQuantile-Quantile Line plot\nUsage\ngeom_qq_line(mapping=None, data=None, stat='qq_line', position='identity',\n             na_rm=False, inherit_aes=True, show_legend=None, raster=False,\n             **kwargs)\nOnly the data and mapping can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the stat.\n\n\n\n\nmapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\n'black'\n\n\n\n\ngroup\n\n\n\n\n\n\nlinetype\n\n\n'solid'\n\n\n\n\nsize\n\n\n0.5\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “qq_line”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format."
  },
  {
    "objectID": "reference/geom_qq_line.html#parameters",
    "href": "reference/geom_qq_line.html#parameters",
    "title": "geom_qq_line",
    "section": "",
    "text": "mapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\n'black'\n\n\n\n\ngroup\n\n\n\n\n\n\nlinetype\n\n\n'solid'\n\n\n\n\nsize\n\n\n0.5\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “qq_line”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format."
  },
  {
    "objectID": "reference/geom_raster.html",
    "href": "reference/geom_raster.html",
    "title": "geom_raster",
    "section": "",
    "text": "geoms.geom_raster(self, mapping=None, data=None, **kwargs)\n\n\nRasterized Rectangles specified using center points\nUsage\ngeom_raster(mapping=None, data=None, stat='identity', position='identity',\n            na_rm=False, inherit_aes=True, show_legend=None, raster=True,\n            vjust=0.5, hjust=0.5, interpolation=None, filterrad=4.0, **kwargs)\nOnly the data and mapping can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the stat.\n\n\n\n\nmapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\nfill\n\n\n'#333333'\n\n\n\n\ngroup\n\n\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “identity”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = True\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\nhjust: float = 0.5\n\nHorizontal justification for the rectangle at point x. Default is 0.5, which centers the rectangle horizontally. Must be in the range [0, 1].\n\nvjust: float = 0.5\n\nVertical justification for the rectangle at point y Default is 0.5, which centers the rectangle vertically. Must be in the range [0, 1].\n\ninterpolation: str = None\n\nHow to calculate values between the center points of adjacent rectangles. The default is None not to interpolate. Allowed values are:\n\"antialiased\"\n\"nearest\"\n\"bilinear\"\n\"bicubic\"\n\"spline16\"\n\"spline36\"\n\"hanning\"\n\"hamming\"\n\"hermite\"\n\"kaiser\"\n\"quadric\"\n\"catrom\"\n\"gaussian\"\n\"bessel\"\n\"mitchell\"\n\"sinc\"\n\"lanczos\"\n\"blackman\"\n\nfilterrad: float = 4.0\n\nThe filter radius for filters that have a radius parameter, i.e. when interpolation is one of: sinc, lanczos, blackman. Must be a number greater than zero.\n\n\n\n\n\n\nplotnine.geoms.geom_rect\n\n\n\nplotnine.geoms.geom_tile"
  },
  {
    "objectID": "reference/geom_raster.html#parameters",
    "href": "reference/geom_raster.html#parameters",
    "title": "geom_raster",
    "section": "",
    "text": "mapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\nfill\n\n\n'#333333'\n\n\n\n\ngroup\n\n\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “identity”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = True\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\nhjust: float = 0.5\n\nHorizontal justification for the rectangle at point x. Default is 0.5, which centers the rectangle horizontally. Must be in the range [0, 1].\n\nvjust: float = 0.5\n\nVertical justification for the rectangle at point y Default is 0.5, which centers the rectangle vertically. Must be in the range [0, 1].\n\ninterpolation: str = None\n\nHow to calculate values between the center points of adjacent rectangles. The default is None not to interpolate. Allowed values are:\n\"antialiased\"\n\"nearest\"\n\"bilinear\"\n\"bicubic\"\n\"spline16\"\n\"spline36\"\n\"hanning\"\n\"hamming\"\n\"hermite\"\n\"kaiser\"\n\"quadric\"\n\"catrom\"\n\"gaussian\"\n\"bessel\"\n\"mitchell\"\n\"sinc\"\n\"lanczos\"\n\"blackman\"\n\nfilterrad: float = 4.0\n\nThe filter radius for filters that have a radius parameter, i.e. when interpolation is one of: sinc, lanczos, blackman. Must be a number greater than zero."
  },
  {
    "objectID": "reference/geom_raster.html#see-also",
    "href": "reference/geom_raster.html#see-also",
    "title": "geom_raster",
    "section": "",
    "text": "plotnine.geoms.geom_rect\n\n\n\nplotnine.geoms.geom_tile"
  },
  {
    "objectID": "reference/geom_ribbon.html",
    "href": "reference/geom_ribbon.html",
    "title": "geom_ribbon",
    "section": "",
    "text": "geoms.geom_ribbon()\n\n\nRibbon plot\nUsage\ngeom_ribbon(mapping=None, data=None, stat='identity', position='identity',\n            na_rm=False, inherit_aes=True, show_legend=None, raster=False,\n            outline_type='both', **kwargs)\nOnly the data and mapping can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the stat.\n\n\n\n\nmapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\nymax\n\n\n\n\n\n\nymin\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\n'none'\n\n\n\n\nfill\n\n\n'#333333'\n\n\n\n\ngroup\n\n\n\n\n\n\nlinetype\n\n\n'solid'\n\n\n\n\nsize\n\n\n0.5\n\n\n\n\nwhere\n\n\nTrue\n\n\n\n\nThe bold aesthetics are required.\nAesthetics Descriptions\n\nwhere\n\nDefine where to exclude horizontal regions from being filled. Regions between any two False values are skipped. For sensible demarcation the value used in the where predicate expression should match the ymin value or expression. i.e.\n aes(ymin=0, ymax='col1', where='col1 &gt; 0')  # good\n aes(ymin=0, ymax='col1', where='col1 &gt; 10')  # bad\n\n aes(ymin=col2, ymax='col1', where='col1 &gt; col2')  # good\n aes(ymin=col2, ymax='col1', where='col1 &gt; col3')  # bad\n\n\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “identity”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\noutline_type: ‘upper’ | ‘lower’ | ‘both’ | ‘full’ = “both”\n\nHow to stroke to outline of the region / area. If upper, draw only upper bounding line. If lower, draw only lower bounding line. If both, draw both upper & lower bounding lines. If full, draw closed polygon around the area."
  },
  {
    "objectID": "reference/geom_ribbon.html#parameters",
    "href": "reference/geom_ribbon.html#parameters",
    "title": "geom_ribbon",
    "section": "",
    "text": "mapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\nymax\n\n\n\n\n\n\nymin\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\n'none'\n\n\n\n\nfill\n\n\n'#333333'\n\n\n\n\ngroup\n\n\n\n\n\n\nlinetype\n\n\n'solid'\n\n\n\n\nsize\n\n\n0.5\n\n\n\n\nwhere\n\n\nTrue\n\n\n\n\nThe bold aesthetics are required.\nAesthetics Descriptions\n\nwhere\n\nDefine where to exclude horizontal regions from being filled. Regions between any two False values are skipped. For sensible demarcation the value used in the where predicate expression should match the ymin value or expression. i.e.\n aes(ymin=0, ymax='col1', where='col1 &gt; 0')  # good\n aes(ymin=0, ymax='col1', where='col1 &gt; 10')  # bad\n\n aes(ymin=col2, ymax='col1', where='col1 &gt; col2')  # good\n aes(ymin=col2, ymax='col1', where='col1 &gt; col3')  # bad\n\n\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “identity”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\noutline_type: ‘upper’ | ‘lower’ | ‘both’ | ‘full’ = “both”\n\nHow to stroke to outline of the region / area. If upper, draw only upper bounding line. If lower, draw only lower bounding line. If both, draw both upper & lower bounding lines. If full, draw closed polygon around the area."
  },
  {
    "objectID": "reference/geom_segment.html",
    "href": "reference/geom_segment.html",
    "title": "geom_segment",
    "section": "",
    "text": "geoms.geom_segment()\n\n\nLine segments\nUsage\ngeom_segment(mapping=None, data=None, stat='identity', position='identity',\n             na_rm=False, inherit_aes=True, show_legend=None, raster=False,\n             lineend='butt', arrow=None, **kwargs)\nOnly the data and mapping can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the stat.\n\n\n\n\nmapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\nxend\n\n\n\n\n\n\ny\n\n\n\n\n\n\nyend\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\n'black'\n\n\n\n\ngroup\n\n\n\n\n\n\nlinetype\n\n\n'solid'\n\n\n\n\nsize\n\n\n0.5\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “identity”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\nlineend: ‘butt’ | ‘round’ | ‘projecting’ = “butt”\n\nLine end style. This option is applied for solid linetypes.\n\narrow: ~plotnine.geoms.geom_path.arrow = None\n\nArrow specification. Default is no arrow.\n\n\n\n\n\n\nplotnine.geoms.geom_path.arrow\n\nfor adding arrowhead(s) to segments."
  },
  {
    "objectID": "reference/geom_segment.html#parameters",
    "href": "reference/geom_segment.html#parameters",
    "title": "geom_segment",
    "section": "",
    "text": "mapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\nxend\n\n\n\n\n\n\ny\n\n\n\n\n\n\nyend\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\n'black'\n\n\n\n\ngroup\n\n\n\n\n\n\nlinetype\n\n\n'solid'\n\n\n\n\nsize\n\n\n0.5\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “identity”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\nlineend: ‘butt’ | ‘round’ | ‘projecting’ = “butt”\n\nLine end style. This option is applied for solid linetypes.\n\narrow: ~plotnine.geoms.geom_path.arrow = None\n\nArrow specification. Default is no arrow."
  },
  {
    "objectID": "reference/geom_segment.html#see-also",
    "href": "reference/geom_segment.html#see-also",
    "title": "geom_segment",
    "section": "",
    "text": "plotnine.geoms.geom_path.arrow\n\nfor adding arrowhead(s) to segments."
  },
  {
    "objectID": "reference/geom_smooth.html",
    "href": "reference/geom_smooth.html",
    "title": "geom_smooth",
    "section": "",
    "text": "geoms.geom_smooth()\n\n\nA smoothed conditional mean\nUsage\ngeom_smooth(mapping=None, data=None, stat='smooth', position='identity',\n            na_rm=False, inherit_aes=True, show_legend=None, raster=False,\n            legend_fill_ratio=0.5, **kwargs)\nOnly the data and mapping can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the stat.\n\n\n\n\nmapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nalpha\n\n\n0.4\n\n\n\n\ncolor\n\n\n'black'\n\n\n\n\nfill\n\n\n'#999999'\n\n\n\n\ngroup\n\n\n\n\n\n\nlinetype\n\n\n'solid'\n\n\n\n\nsize\n\n\n1\n\n\n\n\nymax\n\n\nNone\n\n\n\n\nymin\n\n\nNone\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “smooth”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\nlegend_fill_ratio: float = 0.5\n\nHow much (vertically) of the legend box should be filled by the color that indicates the confidence intervals. Should be in the range [0, 1]."
  },
  {
    "objectID": "reference/geom_smooth.html#parameters",
    "href": "reference/geom_smooth.html#parameters",
    "title": "geom_smooth",
    "section": "",
    "text": "mapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nalpha\n\n\n0.4\n\n\n\n\ncolor\n\n\n'black'\n\n\n\n\nfill\n\n\n'#999999'\n\n\n\n\ngroup\n\n\n\n\n\n\nlinetype\n\n\n'solid'\n\n\n\n\nsize\n\n\n1\n\n\n\n\nymax\n\n\nNone\n\n\n\n\nymin\n\n\nNone\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “smooth”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\nlegend_fill_ratio: float = 0.5\n\nHow much (vertically) of the legend box should be filled by the color that indicates the confidence intervals. Should be in the range [0, 1]."
  },
  {
    "objectID": "reference/geom_step.html",
    "href": "reference/geom_step.html",
    "title": "geom_step",
    "section": "",
    "text": "geoms.geom_step()\n\n\nStepped connected points\nUsage\ngeom_step(mapping=None, data=None, stat='identity', position='identity',\n          na_rm=False, inherit_aes=True, show_legend=None, raster=False,\n          direction='hv', **kwargs)\nOnly the data and mapping can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the stat.\n\n\n\n\nmapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\n'black'\n\n\n\n\ngroup\n\n\n\n\n\n\nlinetype\n\n\n'solid'\n\n\n\n\nsize\n\n\n0.5\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “identity”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\ndirection: ‘hv’ | ‘vh’ | ‘mid’ = “hv”\n\nhorizontal-vertical steps, vertical-horizontal steps or steps half-way between adjacent x values.\n\n\n\n\n\n\nplotnine.geoms.geom_path\n\nFor documentation of extra parameters."
  },
  {
    "objectID": "reference/geom_step.html#parameters",
    "href": "reference/geom_step.html#parameters",
    "title": "geom_step",
    "section": "",
    "text": "mapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\n'black'\n\n\n\n\ngroup\n\n\n\n\n\n\nlinetype\n\n\n'solid'\n\n\n\n\nsize\n\n\n0.5\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “identity”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\ndirection: ‘hv’ | ‘vh’ | ‘mid’ = “hv”\n\nhorizontal-vertical steps, vertical-horizontal steps or steps half-way between adjacent x values."
  },
  {
    "objectID": "reference/geom_step.html#see-also",
    "href": "reference/geom_step.html#see-also",
    "title": "geom_step",
    "section": "",
    "text": "plotnine.geoms.geom_path\n\nFor documentation of extra parameters."
  },
  {
    "objectID": "reference/geom_tile.html",
    "href": "reference/geom_tile.html",
    "title": "geom_tile",
    "section": "",
    "text": "geoms.geom_tile()\n\n\nRectangles specified using a center points\nUsage\ngeom_tile(mapping=None, data=None, stat='identity', position='identity',\n          na_rm=False, inherit_aes=True, show_legend=None, raster=False,\n          **kwargs)\nOnly the data and mapping can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the stat.\n\n\n\n\nmapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\nNone\n\n\n\n\nfill\n\n\n'#333333'\n\n\n\n\ngroup\n\n\n\n\n\n\nlinetype\n\n\n'solid'\n\n\n\n\nsize\n\n\n0.1\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “identity”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\n\n\n\n\n\nplotnine.geoms.geom_rect"
  },
  {
    "objectID": "reference/geom_tile.html#parameters",
    "href": "reference/geom_tile.html#parameters",
    "title": "geom_tile",
    "section": "",
    "text": "mapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\nNone\n\n\n\n\nfill\n\n\n'#333333'\n\n\n\n\ngroup\n\n\n\n\n\n\nlinetype\n\n\n'solid'\n\n\n\n\nsize\n\n\n0.1\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “identity”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format."
  },
  {
    "objectID": "reference/geom_tile.html#see-also",
    "href": "reference/geom_tile.html#see-also",
    "title": "geom_tile",
    "section": "",
    "text": "plotnine.geoms.geom_rect"
  },
  {
    "objectID": "reference/geom_vline.html",
    "href": "reference/geom_vline.html",
    "title": "geom_vline",
    "section": "",
    "text": "geoms.geom_vline(self, mapping=None, data=None, **kwargs)\n\n\nVertical line\nUsage\ngeom_vline(mapping=None, data=None, stat='identity', position='identity',\n           na_rm=False, inherit_aes=False, show_legend=None, raster=False,\n           **kwargs)\nOnly the data and mapping can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the stat.\n\n\n\n\nmapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nxintercept\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\n'black'\n\n\n\n\ngroup\n\n\n\n\n\n\nlinetype\n\n\n'solid'\n\n\n\n\nsize\n\n\n0.5\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “identity”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = False\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format."
  },
  {
    "objectID": "reference/geom_vline.html#parameters",
    "href": "reference/geom_vline.html#parameters",
    "title": "geom_vline",
    "section": "",
    "text": "mapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nxintercept\n\n\n\n\n\n\nalpha\n\n\n1\n\n\n\n\ncolor\n\n\n'black'\n\n\n\n\ngroup\n\n\n\n\n\n\nlinetype\n\n\n'solid'\n\n\n\n\nsize\n\n\n0.5\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat: str | stat = “identity”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes: bool = False\n\nIf False, overrides the default aesthetics.\n\nshow_legend: bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a :class:bool, False never includes and True always includes. A :class:dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format."
  },
  {
    "objectID": "reference/ggplot.html",
    "href": "reference/ggplot.html",
    "title": "ggplot",
    "section": "",
    "text": "ggplot(self, data=None, mapping=None, environment=None)\n\n\nCreate a new ggplot object\n\n\n\n\ndata: dataframe = None\n\nDefault data for plot. Every layer that does not have data of its own will use this one.\n\nmapping: aes = None\n\nDefault aesthetics mapping for the plot. These will be used by all layers unless specifically overridden.\n\nenvironment: ~patsy.Eval.EvalEnvironment = None\n\nIf a variable defined in the aesthetic mapping is not found in the data, ggplot will look for it in this namespace. It defaults to using the environment/namespace. in which ggplot() is called.\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ndraw\nRender the complete plot\n\n\nsave\nSave a ggplot object as an image file\n\n\nsave_helper\nCreate MPL figure that will be saved\n\n\n\n\n\n\nggplot.draw(show=False)\n\n\nRender the complete plot\n\n\n\n\nshow: bool = False\n\nWhether to show the plot.\n\n\n\n\n\n\nfig: ~matplotlib.figure.Figure\n\nMatplotlib figure\n\n\n\n\n\n\n\nggplot.save(filename=None, format=None, path='', width=None, height=None, units='in', dpi=None, limitsize=True, verbose=True, **kwargs)\n\n\nSave a ggplot object as an image file\n\n\n\n\nfilename: str | pathlib.Path = None\n\nFile name to write the plot to. If not specified, a name like “plotnine-save-.” is used.\n\nformat: str = None\n\nImage format to use, automatically extract from file name extension.\n\npath: str = ’’\n\nPath to save plot to (if you just want to set path and not filename).\n\nwidth: number = None\n\nWidth (defaults to value set by the theme). If specified the height must also be given.\n\nheight: number = None\n\nHeight (defaults to value set by the theme). If specified the width must also be given.\n\nunits: str = ‘in’\n\nUnits for width and height when either one is explicitly specified (in, cm, or mm).\n\ndpi: float = None\n\nDPI to use for raster graphics. If None, defaults to using the dpi of theme, if none is set then a dpi of 100.\n\nlimitsize: bool = True\n\nIf True (the default), ggsave will not save images larger than 50x50 inches, to prevent the common error of specifying dimensions in pixels.\n\nverbose: bool = True\n\nIf True, print the saving information.\n\nkwargs: dict = {}\n\nAdditional arguments to pass to matplotlib savefig().\n\n\n\n\n\n\n\nggplot.save_helper(filename=None, format=None, path=None, width=None, height=None, units='in', dpi=None, limitsize=True, verbose=True, **kwargs)\n\n\nCreate MPL figure that will be saved\n\n\n\nThis method has the same arguments as :meth:ggplot.save. Use it to get access to the figure that will be saved."
  },
  {
    "objectID": "reference/ggplot.html#parameters",
    "href": "reference/ggplot.html#parameters",
    "title": "ggplot",
    "section": "",
    "text": "data: dataframe = None\n\nDefault data for plot. Every layer that does not have data of its own will use this one.\n\nmapping: aes = None\n\nDefault aesthetics mapping for the plot. These will be used by all layers unless specifically overridden.\n\nenvironment: ~patsy.Eval.EvalEnvironment = None\n\nIf a variable defined in the aesthetic mapping is not found in the data, ggplot will look for it in this namespace. It defaults to using the environment/namespace. in which ggplot() is called."
  },
  {
    "objectID": "reference/ggplot.html#methods",
    "href": "reference/ggplot.html#methods",
    "title": "ggplot",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ndraw\nRender the complete plot\n\n\nsave\nSave a ggplot object as an image file\n\n\nsave_helper\nCreate MPL figure that will be saved\n\n\n\n\n\n\nggplot.draw(show=False)\n\n\nRender the complete plot\n\n\n\n\nshow: bool = False\n\nWhether to show the plot.\n\n\n\n\n\n\nfig: ~matplotlib.figure.Figure\n\nMatplotlib figure\n\n\n\n\n\n\n\nggplot.save(filename=None, format=None, path='', width=None, height=None, units='in', dpi=None, limitsize=True, verbose=True, **kwargs)\n\n\nSave a ggplot object as an image file\n\n\n\n\nfilename: str | pathlib.Path = None\n\nFile name to write the plot to. If not specified, a name like “plotnine-save-.” is used.\n\nformat: str = None\n\nImage format to use, automatically extract from file name extension.\n\npath: str = ’’\n\nPath to save plot to (if you just want to set path and not filename).\n\nwidth: number = None\n\nWidth (defaults to value set by the theme). If specified the height must also be given.\n\nheight: number = None\n\nHeight (defaults to value set by the theme). If specified the width must also be given.\n\nunits: str = ‘in’\n\nUnits for width and height when either one is explicitly specified (in, cm, or mm).\n\ndpi: float = None\n\nDPI to use for raster graphics. If None, defaults to using the dpi of theme, if none is set then a dpi of 100.\n\nlimitsize: bool = True\n\nIf True (the default), ggsave will not save images larger than 50x50 inches, to prevent the common error of specifying dimensions in pixels.\n\nverbose: bool = True\n\nIf True, print the saving information.\n\nkwargs: dict = {}\n\nAdditional arguments to pass to matplotlib savefig().\n\n\n\n\n\n\n\nggplot.save_helper(filename=None, format=None, path=None, width=None, height=None, units='in', dpi=None, limitsize=True, verbose=True, **kwargs)\n\n\nCreate MPL figure that will be saved\n\n\n\nThis method has the same arguments as :meth:ggplot.save. Use it to get access to the figure that will be saved."
  },
  {
    "objectID": "reference/guide.html",
    "href": "reference/guide.html",
    "title": "guide",
    "section": "",
    "text": "guide\nguides.guide"
  },
  {
    "objectID": "reference/guide_legend.html",
    "href": "reference/guide_legend.html",
    "title": "guide_legend",
    "section": "",
    "text": "guides.guide_legend()\n\n\nLegend guide\n\n\n\n\nnrow: int = None\n\nNumber of rows of legends.\n\nncol: int = None\n\nNumber of columns of legends.\n\nbyrow: bool = False\n\nWhether to fill the legend row-wise or column-wise.\n\nkeywidth: float = None\n\nWidth of the legend key.\n\nkeyheight: float = None\n\nHeight of the legend key.\n\nkwargs: dict\n\nParameters passed on to guide."
  },
  {
    "objectID": "reference/guide_legend.html#parameters",
    "href": "reference/guide_legend.html#parameters",
    "title": "guide_legend",
    "section": "",
    "text": "nrow: int = None\n\nNumber of rows of legends.\n\nncol: int = None\n\nNumber of columns of legends.\n\nbyrow: bool = False\n\nWhether to fill the legend row-wise or column-wise.\n\nkeywidth: float = None\n\nWidth of the legend key.\n\nkeyheight: float = None\n\nHeight of the legend key.\n\nkwargs: dict\n\nParameters passed on to guide."
  },
  {
    "objectID": "reference/huron.html",
    "href": "reference/huron.html",
    "title": "huron",
    "section": "",
    "text": "huron\ndata.huron\n\nLevel of Lake Huron 1875–1972\nDescription\nAnnual measurements of the level, in feet, of Lake Huron 1875–1972.\nFormat\n\n\n\nColumn\nDescription\n\n\n\n\nyear\nYear\n\n\nlevel\nWater level\n\n\ndecade\nDecade\n\n\n\nSource\nBrockwell, P. J. and Davis, R. A. (1991). Time Series and Forecasting Methods. Second edition. Springer, New York. Series A, page 555.\nBrockwell, P. J. and Davis, R. A. (1996). Introduction to Time Series and Forecasting. Springer, New York. Sections 5.1 and 7.6."
  },
  {
    "objectID": "reference/labelling.as_labeller.html",
    "href": "reference/labelling.as_labeller.html",
    "title": "labelling.as_labeller",
    "section": "",
    "text": "facets.labelling.as_labeller(x=None, default=label_value, multi_line=True)\n\n\nCoerse to labeller\n\n\n\n\nx: callable | dict = None\n\nObject to coerce\n\ndefault: str | callable = label_value\n\nDefault labeller. If it is a string, it should be the name of one the labelling functions provided by plotnine.\n\nmulti_line: bool = True\n\nWhether to place each variable on a separate line\n\n\n\n\n\n\nout: labeller\n\nLabelling function"
  },
  {
    "objectID": "reference/labelling.as_labeller.html#parameters",
    "href": "reference/labelling.as_labeller.html#parameters",
    "title": "labelling.as_labeller",
    "section": "",
    "text": "x: callable | dict = None\n\nObject to coerce\n\ndefault: str | callable = label_value\n\nDefault labeller. If it is a string, it should be the name of one the labelling functions provided by plotnine.\n\nmulti_line: bool = True\n\nWhether to place each variable on a separate line"
  },
  {
    "objectID": "reference/labelling.as_labeller.html#returns",
    "href": "reference/labelling.as_labeller.html#returns",
    "title": "labelling.as_labeller",
    "section": "",
    "text": "out: labeller\n\nLabelling function"
  },
  {
    "objectID": "reference/labelling.label_context.html",
    "href": "reference/labelling.label_context.html",
    "title": "labelling.label_context",
    "section": "",
    "text": "facets.labelling.label_context(label_info, multi_line=True, sep=': ')\n\n\nCreate an unabiguous label string\nIf facetting over a single variable, label_value is used, if two or more variables then label_both is used.\n\n\n\n\nlabel_info: strip_label_details\n\nLabel information\n\nmulti_line: bool = True\n\nWhether to place each variable on a separate line\n\nsep: str = ‘:’\n\nSeparation between variable name and value\n\n\n\n\n\n\nout: str\n\nContatenated label values (or pairs of variable names & values)"
  },
  {
    "objectID": "reference/labelling.label_context.html#parameters",
    "href": "reference/labelling.label_context.html#parameters",
    "title": "labelling.label_context",
    "section": "",
    "text": "label_info: strip_label_details\n\nLabel information\n\nmulti_line: bool = True\n\nWhether to place each variable on a separate line\n\nsep: str = ‘:’\n\nSeparation between variable name and value"
  },
  {
    "objectID": "reference/labelling.label_context.html#returns",
    "href": "reference/labelling.label_context.html#returns",
    "title": "labelling.label_context",
    "section": "",
    "text": "out: str\n\nContatenated label values (or pairs of variable names & values)"
  },
  {
    "objectID": "reference/labelling.labeller.html",
    "href": "reference/labelling.labeller.html",
    "title": "labelling.labeller",
    "section": "",
    "text": "facets.labelling.labeller(self, rows=None, cols=None, multi_line=True, default='label_value', **kwargs)\n\n\nFacet Strip Labelling\nWhen called with strip_label_details knows how to alter the strip labels along either dimension.\n\n\n\n\nrows: str | callable = None\n\nHow to label the rows\n\ncols: str | callable = None\n\nHow to label the columns\n\nmulti_line: bool = True\n\nWhether to place each variable on a separate line\n\ndefault: str | callable = ‘label_value’\n\nFallback labelling function. If it is a string, it should be one of [\"label_value\", \"label_both\", \"label_context\"].\n\nkwargs: dict = {}\n\n{variable name : function | string} pairs for renaming variables. A function to rename the variable or a string name."
  },
  {
    "objectID": "reference/labelling.labeller.html#parameters",
    "href": "reference/labelling.labeller.html#parameters",
    "title": "labelling.labeller",
    "section": "",
    "text": "rows: str | callable = None\n\nHow to label the rows\n\ncols: str | callable = None\n\nHow to label the columns\n\nmulti_line: bool = True\n\nWhether to place each variable on a separate line\n\ndefault: str | callable = ‘label_value’\n\nFallback labelling function. If it is a string, it should be one of [\"label_value\", \"label_both\", \"label_context\"].\n\nkwargs: dict = {}\n\n{variable name : function | string} pairs for renaming variables. A function to rename the variable or a string name."
  },
  {
    "objectID": "reference/layer.html",
    "href": "reference/layer.html",
    "title": "layer",
    "section": "",
    "text": "layer\n\n\n\n\n\nName\nDescription\n\n\n\n\nLayers\nList of layers\n\n\nlayer\nLayer\n\n\n\n\n\n\nlayer.Layers()\n\n\nList of layers\nDuring the plot building pipeline, many operations are applied at all layers in the plot. This class makes those tasks easier.\n\n\n\n\n\nlayer.layer(self, geom, stat, *, mapping, data, position, inherit_aes=True, show_legend=None, raster=False)\n\n\nLayer\nWhen a geom or stat is added to a ggplot object, it creates a single layer. This class is a representation of that layer.\n\n\n\n\ngeom: geom\n\ngeom to used to draw this layer.\n\nstat: stat\n\nstat used for the statistical transformation of data in this layer\n\nmapping: aes\n\nAesthetic mappings.\n\ndata: dataframe\n\nData plotted in this layer. If None, the data from the ggplot object will be used.\n\nposition: position\n\nPosition object to adjust the geometries in this layer.\n\ninherit_aes: bool = True\n\nIf True inherit from the aesthetic mappings of the ggplot object.\n\nshow_legend: bool | None = None\n\nWhether to make up and show a legend for the mappings of this layer. If None then an automatic/good choice is made\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even if the final image format is vector.\n\n\n\n\n\nThere is no benefit to manually creating a layer. You should always use a geom or stat.\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncompute_aesthetics\nReturn a dataframe where the columns match the aesthetic mappings\n\n\ncompute_position\nCompute the position of each geometric object\n\n\ncompute_statistic\nCompute & return statistics for this layer\n\n\ndraw\nDraw geom\n\n\nfinish_statistics\nPrepare/modify data for plotting\n\n\nfrom_geom\nCreate a layer given a \n\n\nmap_statistic\nMapping aesthetics to computed statistics\n\n\nsetup\nPrepare layer for the plot building\n\n\nsetup_data\nPrepare/modify data for plotting\n\n\nuse_defaults\nPrepare/modify data for plotting\n\n\n\n\n\n\nlayer.layer.compute_aesthetics(plot)\n\n\nReturn a dataframe where the columns match the aesthetic mappings\nTransformations like ‘factor(cyl)’ and other expression evaluation are made in here\n\n\n\n\n\nlayer.layer.compute_position(layout)\n\n\nCompute the position of each geometric object\nThis is in concert with the other objects in the panel depending on the position class of the geom\n\n\n\n\n\nlayer.layer.compute_statistic(layout)\n\n\nCompute & return statistics for this layer\n\n\n\n\n\nlayer.layer.draw(layout, coord)\n\n\nDraw geom\n\n\n\n\nlayout: Layout\n\nLayout object created when the plot is getting built\n\ncoord: coord\n\nType of coordinate axes\n\n\n\n\n\n\n\nlayer.layer.finish_statistics()\n\n\nPrepare/modify data for plotting\n\n\n\n\n\nlayer.layer.from_geom(geom)\n\n\nCreate a layer given a \n\n\n\n\ngeom: geom\n\ngeom from which a layer will be created\n\n\n\n\n\n\nout: layer\n\nLayer that represents the specific geom.\n\n\n\n\n\n\n\nlayer.layer.map_statistic(plot)\n\n\nMapping aesthetics to computed statistics\n\n\n\n\n\nlayer.layer.setup(plot)\n\n\nPrepare layer for the plot building\nGive the layer access to the data, mapping and environment\n\n\n\n\n\nlayer.layer.setup_data()\n\n\nPrepare/modify data for plotting\n\n\n\n\n\nlayer.layer.use_defaults(data=None, aes_modifiers=None)\n\n\nPrepare/modify data for plotting\n\n\n\n\ndata: dataframe = None\n\nData\n\naes_modifiers: dict = None\n\nExpression to evaluate and replace aesthetics in the data.\n\n\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nadd_group\nAdd group to the dataframe\n\n\ndiscrete_columns\nReturn a list of the discrete columns in the dataframe\n\n\n\n\n\n\nlayer.add_group(data)\n\n\nAdd group to the dataframe\nThe group depends on the interaction of the discrete aesthetic columns in the dataframe.\n\n\n\n\n\nlayer.discrete_columns(df, ignore)\n\n\nReturn a list of the discrete columns in the dataframe\n\n\n\n\ndf: dataframe\n\nData\n\nignore: list[str]\n\nA list|set|tuple with the names of the columns to skip."
  },
  {
    "objectID": "reference/layer.html#classes",
    "href": "reference/layer.html#classes",
    "title": "layer",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nLayers\nList of layers\n\n\nlayer\nLayer\n\n\n\n\n\n\nlayer.Layers()\n\n\nList of layers\nDuring the plot building pipeline, many operations are applied at all layers in the plot. This class makes those tasks easier.\n\n\n\n\n\nlayer.layer(self, geom, stat, *, mapping, data, position, inherit_aes=True, show_legend=None, raster=False)\n\n\nLayer\nWhen a geom or stat is added to a ggplot object, it creates a single layer. This class is a representation of that layer.\n\n\n\n\ngeom: geom\n\ngeom to used to draw this layer.\n\nstat: stat\n\nstat used for the statistical transformation of data in this layer\n\nmapping: aes\n\nAesthetic mappings.\n\ndata: dataframe\n\nData plotted in this layer. If None, the data from the ggplot object will be used.\n\nposition: position\n\nPosition object to adjust the geometries in this layer.\n\ninherit_aes: bool = True\n\nIf True inherit from the aesthetic mappings of the ggplot object.\n\nshow_legend: bool | None = None\n\nWhether to make up and show a legend for the mappings of this layer. If None then an automatic/good choice is made\n\nraster: bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even if the final image format is vector.\n\n\n\n\n\nThere is no benefit to manually creating a layer. You should always use a geom or stat.\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncompute_aesthetics\nReturn a dataframe where the columns match the aesthetic mappings\n\n\ncompute_position\nCompute the position of each geometric object\n\n\ncompute_statistic\nCompute & return statistics for this layer\n\n\ndraw\nDraw geom\n\n\nfinish_statistics\nPrepare/modify data for plotting\n\n\nfrom_geom\nCreate a layer given a \n\n\nmap_statistic\nMapping aesthetics to computed statistics\n\n\nsetup\nPrepare layer for the plot building\n\n\nsetup_data\nPrepare/modify data for plotting\n\n\nuse_defaults\nPrepare/modify data for plotting\n\n\n\n\n\n\nlayer.layer.compute_aesthetics(plot)\n\n\nReturn a dataframe where the columns match the aesthetic mappings\nTransformations like ‘factor(cyl)’ and other expression evaluation are made in here\n\n\n\n\n\nlayer.layer.compute_position(layout)\n\n\nCompute the position of each geometric object\nThis is in concert with the other objects in the panel depending on the position class of the geom\n\n\n\n\n\nlayer.layer.compute_statistic(layout)\n\n\nCompute & return statistics for this layer\n\n\n\n\n\nlayer.layer.draw(layout, coord)\n\n\nDraw geom\n\n\n\n\nlayout: Layout\n\nLayout object created when the plot is getting built\n\ncoord: coord\n\nType of coordinate axes\n\n\n\n\n\n\n\nlayer.layer.finish_statistics()\n\n\nPrepare/modify data for plotting\n\n\n\n\n\nlayer.layer.from_geom(geom)\n\n\nCreate a layer given a \n\n\n\n\ngeom: geom\n\ngeom from which a layer will be created\n\n\n\n\n\n\nout: layer\n\nLayer that represents the specific geom.\n\n\n\n\n\n\n\nlayer.layer.map_statistic(plot)\n\n\nMapping aesthetics to computed statistics\n\n\n\n\n\nlayer.layer.setup(plot)\n\n\nPrepare layer for the plot building\nGive the layer access to the data, mapping and environment\n\n\n\n\n\nlayer.layer.setup_data()\n\n\nPrepare/modify data for plotting\n\n\n\n\n\nlayer.layer.use_defaults(data=None, aes_modifiers=None)\n\n\nPrepare/modify data for plotting\n\n\n\n\ndata: dataframe = None\n\nData\n\naes_modifiers: dict = None\n\nExpression to evaluate and replace aesthetics in the data."
  },
  {
    "objectID": "reference/layer.html#functions",
    "href": "reference/layer.html#functions",
    "title": "layer",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nadd_group\nAdd group to the dataframe\n\n\ndiscrete_columns\nReturn a list of the discrete columns in the dataframe\n\n\n\n\n\n\nlayer.add_group(data)\n\n\nAdd group to the dataframe\nThe group depends on the interaction of the discrete aesthetic columns in the dataframe.\n\n\n\n\n\nlayer.discrete_columns(df, ignore)\n\n\nReturn a list of the discrete columns in the dataframe\n\n\n\n\ndf: dataframe\n\nData\n\nignore: list[str]\n\nA list|set|tuple with the names of the columns to skip."
  },
  {
    "objectID": "reference/legend_box.html",
    "href": "reference/legend_box.html",
    "title": "legend_box",
    "section": "",
    "text": "themes.themeable.legend_box()\n\n\nHow to box up multiple legends\n\n\n\n\ntheme_element: ‘vertical’ | ‘horizontal’\n\nWhether to stack up the legends vertically or horizontally."
  },
  {
    "objectID": "reference/legend_box.html#parameters",
    "href": "reference/legend_box.html#parameters",
    "title": "legend_box",
    "section": "",
    "text": "theme_element: ‘vertical’ | ‘horizontal’\n\nWhether to stack up the legends vertically or horizontally."
  },
  {
    "objectID": "reference/legend_box_just.html",
    "href": "reference/legend_box_just.html",
    "title": "legend_box_just",
    "section": "",
    "text": "themes.themeable.legend_box_just()\n\n\nJustification of legend boxes\n\n\n\n\ntheme_element: (‘left’, ‘right’, ‘center’, ‘top’, ‘bottom’) = None\n\nIf None, the value that will apply depends on :class:legend_box."
  },
  {
    "objectID": "reference/legend_box_just.html#parameters",
    "href": "reference/legend_box_just.html#parameters",
    "title": "legend_box_just",
    "section": "",
    "text": "theme_element: (‘left’, ‘right’, ‘center’, ‘top’, ‘bottom’) = None\n\nIf None, the value that will apply depends on :class:legend_box."
  },
  {
    "objectID": "reference/legend_box_spacing.html",
    "href": "reference/legend_box_spacing.html",
    "title": "legend_box_spacing",
    "section": "",
    "text": "themes.themeable.legend_box_spacing()\n\n\nSpacing between the legend and the plotting area\n\n\n\n\ntheme_element: float\n\nValue in points."
  },
  {
    "objectID": "reference/legend_box_spacing.html#parameters",
    "href": "reference/legend_box_spacing.html#parameters",
    "title": "legend_box_spacing",
    "section": "",
    "text": "theme_element: float\n\nValue in points."
  },
  {
    "objectID": "reference/legend_entry_spacing.html",
    "href": "reference/legend_entry_spacing.html",
    "title": "legend_entry_spacing",
    "section": "",
    "text": "themes.themeable.legend_entry_spacing()\n\n\nSpacing between two entries in a legend\n\n\n\n\ntheme_element: float\n\nSize in points"
  },
  {
    "objectID": "reference/legend_entry_spacing.html#parameters",
    "href": "reference/legend_entry_spacing.html#parameters",
    "title": "legend_entry_spacing",
    "section": "",
    "text": "theme_element: float\n\nSize in points"
  },
  {
    "objectID": "reference/legend_entry_spacing_y.html",
    "href": "reference/legend_entry_spacing_y.html",
    "title": "legend_entry_spacing_y",
    "section": "",
    "text": "themes.themeable.legend_entry_spacing_y()\n\n\nVertical spacing between two entries in a legend\n\n\n\n\ntheme_element: float\n\nSize in points"
  },
  {
    "objectID": "reference/legend_entry_spacing_y.html#parameters",
    "href": "reference/legend_entry_spacing_y.html#parameters",
    "title": "legend_entry_spacing_y",
    "section": "",
    "text": "theme_element: float\n\nSize in points"
  },
  {
    "objectID": "reference/legend_key_height.html",
    "href": "reference/legend_key_height.html",
    "title": "legend_key_height",
    "section": "",
    "text": "themes.themeable.legend_key_height()\n\n\nLegend key background height\n\n\n\n\ntheme_element: float\n\nValue in points."
  },
  {
    "objectID": "reference/legend_key_height.html#parameters",
    "href": "reference/legend_key_height.html#parameters",
    "title": "legend_key_height",
    "section": "",
    "text": "theme_element: float\n\nValue in points."
  },
  {
    "objectID": "reference/legend_key_width.html",
    "href": "reference/legend_key_width.html",
    "title": "legend_key_width",
    "section": "",
    "text": "themes.themeable.legend_key_width()\n\n\nLegend key background width\n\n\n\n\ntheme_element: float\n\nValue in points"
  },
  {
    "objectID": "reference/legend_key_width.html#parameters",
    "href": "reference/legend_key_width.html#parameters",
    "title": "legend_key_width",
    "section": "",
    "text": "theme_element: float\n\nValue in points"
  },
  {
    "objectID": "reference/legend_position.html",
    "href": "reference/legend_position.html",
    "title": "legend_position",
    "section": "",
    "text": "themes.themeable.legend_position()\n\n\nLocation of legend\n\n\n\n\ntheme_element: ‘right’ | ‘left’ | ‘top’ | ‘bottom’ | ‘none’ | tuple\n\nIf none, no legend. If a tuple, 2-floats in the range [0, 1] for the location in screen coordinates."
  },
  {
    "objectID": "reference/legend_position.html#parameters",
    "href": "reference/legend_position.html#parameters",
    "title": "legend_position",
    "section": "",
    "text": "theme_element: ‘right’ | ‘left’ | ‘top’ | ‘bottom’ | ‘none’ | tuple\n\nIf none, no legend. If a tuple, 2-floats in the range [0, 1] for the location in screen coordinates."
  },
  {
    "objectID": "reference/legend_text.html",
    "href": "reference/legend_text.html",
    "title": "legend_text",
    "section": "",
    "text": "themes.themeable.legend_text()\n\n\nLegend text\n\n\n\n\ntheme_element: element_text"
  },
  {
    "objectID": "reference/legend_text.html#parameters",
    "href": "reference/legend_text.html#parameters",
    "title": "legend_text",
    "section": "",
    "text": "theme_element: element_text"
  },
  {
    "objectID": "reference/legend_text_legend.html",
    "href": "reference/legend_text_legend.html",
    "title": "legend_text_legend",
    "section": "",
    "text": "themes.themeable.legend_text_legend()\n\n\nLegend text for the common legend\n\n\n\n\ntheme_element: element_text\n\n\n\n\n\n\n\nThis themeable exists mainly to cater for differences in how the text is aligned compared to the colorbar. Unless you experience those alignment issues (i.e when using parameters va or ha), you should use :class:legend_text."
  },
  {
    "objectID": "reference/legend_text_legend.html#parameters",
    "href": "reference/legend_text_legend.html#parameters",
    "title": "legend_text_legend",
    "section": "",
    "text": "theme_element: element_text"
  },
  {
    "objectID": "reference/legend_text_legend.html#notes",
    "href": "reference/legend_text_legend.html#notes",
    "title": "legend_text_legend",
    "section": "",
    "text": "This themeable exists mainly to cater for differences in how the text is aligned compared to the colorbar. Unless you experience those alignment issues (i.e when using parameters va or ha), you should use :class:legend_text."
  },
  {
    "objectID": "reference/legend_title_align.html",
    "href": "reference/legend_title_align.html",
    "title": "legend_title_align",
    "section": "",
    "text": "themes.themeable.legend_title_align()\n\n\nAlignment of legend title\n\n\n\n\ntheme_element: ‘right’ | ‘left’ | ‘center’ | ‘top’ | ‘bottom’ | ‘auto’\n\nIf auto, depends on the position of the legend."
  },
  {
    "objectID": "reference/legend_title_align.html#parameters",
    "href": "reference/legend_title_align.html#parameters",
    "title": "legend_title_align",
    "section": "",
    "text": "theme_element: ‘right’ | ‘left’ | ‘center’ | ‘top’ | ‘bottom’ | ‘auto’\n\nIf auto, depends on the position of the legend."
  },
  {
    "objectID": "reference/line.html",
    "href": "reference/line.html",
    "title": "line",
    "section": "",
    "text": "themes.themeable.line()\n\n\nAll line elements\n\n\n\n\ntheme_element: element_line"
  },
  {
    "objectID": "reference/line.html#parameters",
    "href": "reference/line.html#parameters",
    "title": "line",
    "section": "",
    "text": "theme_element: element_line"
  },
  {
    "objectID": "reference/meat.html",
    "href": "reference/meat.html",
    "title": "meat",
    "section": "",
    "text": "meat\ndata.meat"
  },
  {
    "objectID": "reference/mpg.html",
    "href": "reference/mpg.html",
    "title": "mpg",
    "section": "",
    "text": "mpg\ndata.mpg\n\nFuel economy data from 1999 and 2008 for 38 popular models of car\nDescription\nThis dataset contains a subset of the fuel economy data that the EPA makes available on http://fueleconomy.gov. It contains only models which had a new release every year between 1999 and 2008 - this was used as a proxy for the popularity of the car.\nFormat\nA data frame with 234 rows and 11 variables\n\n\n\n\n\n\n\nColumn\nDescription\n\n\n\n\nmanufacturer\n\n\n\nmodel\n\n\n\ndispl\nengine displacement, in litres\n\n\nyear\n\n\n\ncyl\nnumber of cylinders\n\n\ntrans\ntype of transmission\n\n\ndrv\nf = front-wheel drive r = rear wheel drive 4 = 4wd\n\n\ncty\ncity miles per gallon\n\n\nhwy\nhighway miles per gallon\n\n\nfl\n\n\n\nclass"
  },
  {
    "objectID": "reference/mtcars.html",
    "href": "reference/mtcars.html",
    "title": "mtcars",
    "section": "",
    "text": "mtcars\ndata.mtcars\n\nMotor Trend Car Road Tests\nDescription\nThe data was extracted from the 1974 Motor Trend US magazine, and comprises fuel consumption and 10 aspects of automobile design and performance for 32 automobiles (1973–74 models).\nFormat\nA data frame with 32 observations on 11 variables.\n\n\n\nColumn\nDescription\n\n\n\n\nmpg\nMiles/(US) gallon\n\n\ncyl\nNumber of cylinders\n\n\ndisp\nDisplacement (cu.in.)\n\n\nhp\nGross horsepower\n\n\ndrat\nRear axle ratio\n\n\nwt\nWeight (1000 lbs)\n\n\nqsec\n1/4 mile time\n\n\nvs\nV/S\n\n\nam\nTransmission (0 = automatic, 1 = manual)\n\n\ngear\nNumber of forward gears\n\n\ncarb\nNumber of carburetors\n\n\n\nSource\nHenderson and Velleman (1981), Building multiple regression models interactively. Biometrics, 37, 391–411."
  },
  {
    "objectID": "reference/panel_background.html",
    "href": "reference/panel_background.html",
    "title": "panel_background",
    "section": "",
    "text": "themes.themeable.panel_background()\n\n\nPanel background\n\n\n\n\ntheme_element: element_rect"
  },
  {
    "objectID": "reference/panel_background.html#parameters",
    "href": "reference/panel_background.html#parameters",
    "title": "panel_background",
    "section": "",
    "text": "theme_element: element_rect"
  },
  {
    "objectID": "reference/panel_grid.html",
    "href": "reference/panel_grid.html",
    "title": "panel_grid",
    "section": "",
    "text": "themes.themeable.panel_grid()\n\n\nGrid lines\n\n\n\n\ntheme_element: element_line"
  },
  {
    "objectID": "reference/panel_grid.html#parameters",
    "href": "reference/panel_grid.html#parameters",
    "title": "panel_grid",
    "section": "",
    "text": "theme_element: element_line"
  },
  {
    "objectID": "reference/panel_grid_major_x.html",
    "href": "reference/panel_grid_major_x.html",
    "title": "panel_grid_major_x",
    "section": "",
    "text": "themes.themeable.panel_grid_major_x()\n\n\nVertical major grid lines\n\n\n\n\ntheme_element: element_line"
  },
  {
    "objectID": "reference/panel_grid_major_x.html#parameters",
    "href": "reference/panel_grid_major_x.html#parameters",
    "title": "panel_grid_major_x",
    "section": "",
    "text": "theme_element: element_line"
  },
  {
    "objectID": "reference/panel_grid_minor.html",
    "href": "reference/panel_grid_minor.html",
    "title": "panel_grid_minor",
    "section": "",
    "text": "themes.themeable.panel_grid_minor()\n\n\nMinor grid lines\n\n\n\n\ntheme_element: element_line"
  },
  {
    "objectID": "reference/panel_grid_minor.html#parameters",
    "href": "reference/panel_grid_minor.html#parameters",
    "title": "panel_grid_minor",
    "section": "",
    "text": "theme_element: element_line"
  },
  {
    "objectID": "reference/panel_grid_minor_y.html",
    "href": "reference/panel_grid_minor_y.html",
    "title": "panel_grid_minor_y",
    "section": "",
    "text": "themes.themeable.panel_grid_minor_y()\n\n\nHorizontal minor grid lines\n\n\n\n\ntheme_element: element_line"
  },
  {
    "objectID": "reference/panel_grid_minor_y.html#parameters",
    "href": "reference/panel_grid_minor_y.html#parameters",
    "title": "panel_grid_minor_y",
    "section": "",
    "text": "theme_element: element_line"
  },
  {
    "objectID": "reference/panel_spacing.html",
    "href": "reference/panel_spacing.html",
    "title": "panel_spacing",
    "section": "",
    "text": "themes.themeable.panel_spacing()\n\n\nSpacing between the facet panels\n\n\n\n\ntheme_element: float\n\nSize in inches of the space between the facet panels"
  },
  {
    "objectID": "reference/panel_spacing.html#parameters",
    "href": "reference/panel_spacing.html#parameters",
    "title": "panel_spacing",
    "section": "",
    "text": "theme_element: float\n\nSize in inches of the space between the facet panels"
  },
  {
    "objectID": "reference/panel_spacing_y.html",
    "href": "reference/panel_spacing_y.html",
    "title": "panel_spacing_y",
    "section": "",
    "text": "themes.themeable.panel_spacing_y()\n\n\nVertical spacing between the facet panels\n\n\n\n\ntheme_element: float\n\nSize as a fraction of the figure width.\n\n\n\n\n\nIt is deliberate to have the vertical spacing be a fraction of the width. That means that when :class:panel_spacing_x is the equal :class:panel_spacing_x, the spaces in both directions will be equal."
  },
  {
    "objectID": "reference/panel_spacing_y.html#parameters",
    "href": "reference/panel_spacing_y.html#parameters",
    "title": "panel_spacing_y",
    "section": "",
    "text": "theme_element: float\n\nSize as a fraction of the figure width."
  },
  {
    "objectID": "reference/panel_spacing_y.html#notes",
    "href": "reference/panel_spacing_y.html#notes",
    "title": "panel_spacing_y",
    "section": "",
    "text": "It is deliberate to have the vertical spacing be a fraction of the width. That means that when :class:panel_spacing_x is the equal :class:panel_spacing_x, the spaces in both directions will be equal."
  },
  {
    "objectID": "reference/plot_margin.html",
    "href": "reference/plot_margin.html",
    "title": "plot_margin",
    "section": "",
    "text": "themes.themeable.plot_margin()\n\n\nPlot Margin\n\n\n\n\ntheme_element: float\n\nMust be in the [0, 1] range. It is specified as a fraction of the figure width and figure height."
  },
  {
    "objectID": "reference/plot_margin.html#parameters",
    "href": "reference/plot_margin.html#parameters",
    "title": "plot_margin",
    "section": "",
    "text": "theme_element: float\n\nMust be in the [0, 1] range. It is specified as a fraction of the figure width and figure height."
  },
  {
    "objectID": "reference/position_dodge.html",
    "href": "reference/position_dodge.html",
    "title": "position_dodge",
    "section": "",
    "text": "positions.position_dodge(self, width=None, preserve='total')\n\n\nDodge overlaps and place objects side-by-side\n\n\n\n\nwidth=None\n\nDodging width, when different to the width of the individual elements. This is useful when you want to align narrow geoms with wider geoms\n\npreserve=‘total’\n\nShould dodging preserve the total width of all elements at a position, or the width of a single element?"
  },
  {
    "objectID": "reference/position_dodge.html#parameters",
    "href": "reference/position_dodge.html#parameters",
    "title": "position_dodge",
    "section": "",
    "text": "width=None\n\nDodging width, when different to the width of the individual elements. This is useful when you want to align narrow geoms with wider geoms\n\npreserve=‘total’\n\nShould dodging preserve the total width of all elements at a position, or the width of a single element?"
  },
  {
    "objectID": "reference/position_fill.html",
    "href": "reference/position_fill.html",
    "title": "position_fill",
    "section": "",
    "text": "position_fill\n\npositions.position_fill()\n\n\nNormalise stacked objects to unit height"
  },
  {
    "objectID": "reference/position_jitter.html",
    "href": "reference/position_jitter.html",
    "title": "position_jitter",
    "section": "",
    "text": "positions.position_jitter(self, width=None, height=None, random_state=None)\n\n\nJitter points to avoid overplotting\n\n\n\n\nwidth: float = None\n\nProportion to jitter in horizontal direction. If None, 0.4 of the resolution of the data.\n\nheight: float = None\n\nProportion to jitter in vertical direction. If None, 0.4 of the resolution of the data.\n\nrandom_state: int | ~numpy.random.RandomState = None\n\nSeed or Random number generator to use. If None, then numpy global generator :class:numpy.random is used."
  },
  {
    "objectID": "reference/position_jitter.html#parameters",
    "href": "reference/position_jitter.html#parameters",
    "title": "position_jitter",
    "section": "",
    "text": "width: float = None\n\nProportion to jitter in horizontal direction. If None, 0.4 of the resolution of the data.\n\nheight: float = None\n\nProportion to jitter in vertical direction. If None, 0.4 of the resolution of the data.\n\nrandom_state: int | ~numpy.random.RandomState = None\n\nSeed or Random number generator to use. If None, then numpy global generator :class:numpy.random is used."
  },
  {
    "objectID": "reference/position_nudge.html",
    "href": "reference/position_nudge.html",
    "title": "position_nudge",
    "section": "",
    "text": "positions.position_nudge(self, x=0, y=0)\n\n\nNudge points\nUseful to nudge labels away from the points being labels.\n\n\n\n\nx: float = 0\n\nHorizontal nudge\n\ny: float = 0\n\nVertical nudge"
  },
  {
    "objectID": "reference/position_nudge.html#parameters",
    "href": "reference/position_nudge.html#parameters",
    "title": "position_nudge",
    "section": "",
    "text": "x: float = 0\n\nHorizontal nudge\n\ny: float = 0\n\nVertical nudge"
  },
  {
    "objectID": "reference/presidential.html",
    "href": "reference/presidential.html",
    "title": "presidential",
    "section": "",
    "text": "presidential\ndata.presidential\n\nTerms of 11 presidents from Eisenhower to Obama.\nDescription\nThe names of each president, the start and end date of their term, and their party of 11 US presidents from Eisenhower to Obama.\nFormat\nA data frame with 11 rows and 4 variables\n\n\n\nColumn\nDescription\n\n\n\n\nname\nName of president\n\n\nstart\nStart of presidential term\n\n\nend\nEnd of presidential term\n\n\nparty\nPolitical Party"
  },
  {
    "objectID": "reference/rect.html",
    "href": "reference/rect.html",
    "title": "rect",
    "section": "",
    "text": "themes.themeable.rect()\n\n\nAll rectangle elements\n\n\n\n\ntheme_element: element_rect"
  },
  {
    "objectID": "reference/rect.html#parameters",
    "href": "reference/rect.html#parameters",
    "title": "rect",
    "section": "",
    "text": "theme_element: element_rect"
  },
  {
    "objectID": "reference/scale.html",
    "href": "reference/scale.html",
    "title": "scale",
    "section": "",
    "text": "scales.scale.scale(self, **kwargs)\n\n\nBase class for all scales\n\n\n\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\nna_value: scalar = float(“nan”)\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun."
  },
  {
    "objectID": "reference/scale.html#parameters",
    "href": "reference/scale.html#parameters",
    "title": "scale",
    "section": "",
    "text": "breaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\nna_value: scalar = float(“nan”)\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun."
  },
  {
    "objectID": "reference/scale_alpha_continuous.html",
    "href": "reference/scale_alpha_continuous.html",
    "title": "scale_alpha_continuous",
    "section": "",
    "text": "scales.scale_alpha.scale_alpha_continuous\n\nContinuous Alpha Scale\n\n\n\nrange : tuple Range ([Minimum, Maximum]) of output alpha values. Should be between 0 and 1. breaks : bool | list | callable, default=True List of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks. expand : tuple, default=None Multiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n```\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\n```\n\nFor example,\n\n- `(0, 0)` - Do not expand.\n- `(0, 1)` - Expand lower and upper limits by 1 unit.\n- `(1, 0)` - Expand lower and upper limits by 100%.\n- `(0, 0, 0, 0)` - Do not expand, as `(0, 0)`.\n- `(0, 0, 0, 1)` - Expand upper limit by 1 unit.\n- `(0, 1, 0.1, 0)` - Expand lower limit by 1 unit and\n  upper limit by 10%.\n- `(0, 0, 0.1, 2)` - Expand upper limit by 10% plus\n  2 units.\n\nIf not specified, suitable defaults are chosen.\nname : str, default=None Name used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale. labels : bool | list | callable, default=True List of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings. limits : array_like, default=None Limits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories. na_value : scalar, default=float(“nan”) What value to assign to missing values. Default is to assign np.nan. palette : callable, default=None Function to map data points onto the scale. Most scales define their own palettes. aesthetics : list | str, default=None list of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun. trans : str | callable Name of a trans function or a trans function. See :mod:mizani.transforms for possible options. oob : callable, default=mizani.bounds.censor Function to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped. minor_breaks : list | int | callable, default=None If a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them. rescaler : callable, default=mizani.bounds.rescale Function to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default."
  },
  {
    "objectID": "reference/scale_alpha_continuous.html#parameters",
    "href": "reference/scale_alpha_continuous.html#parameters",
    "title": "scale_alpha_continuous",
    "section": "",
    "text": "range : tuple Range ([Minimum, Maximum]) of output alpha values. Should be between 0 and 1. breaks : bool | list | callable, default=True List of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks. expand : tuple, default=None Multiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n```\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\n```\n\nFor example,\n\n- `(0, 0)` - Do not expand.\n- `(0, 1)` - Expand lower and upper limits by 1 unit.\n- `(1, 0)` - Expand lower and upper limits by 100%.\n- `(0, 0, 0, 0)` - Do not expand, as `(0, 0)`.\n- `(0, 0, 0, 1)` - Expand upper limit by 1 unit.\n- `(0, 1, 0.1, 0)` - Expand lower limit by 1 unit and\n  upper limit by 10%.\n- `(0, 0, 0.1, 2)` - Expand upper limit by 10% plus\n  2 units.\n\nIf not specified, suitable defaults are chosen.\nname : str, default=None Name used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale. labels : bool | list | callable, default=True List of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings. limits : array_like, default=None Limits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories. na_value : scalar, default=float(“nan”) What value to assign to missing values. Default is to assign np.nan. palette : callable, default=None Function to map data points onto the scale. Most scales define their own palettes. aesthetics : list | str, default=None list of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun. trans : str | callable Name of a trans function or a trans function. See :mod:mizani.transforms for possible options. oob : callable, default=mizani.bounds.censor Function to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped. minor_breaks : list | int | callable, default=None If a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them. rescaler : callable, default=mizani.bounds.rescale Function to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default."
  },
  {
    "objectID": "reference/scale_alpha_discrete.html",
    "href": "reference/scale_alpha_discrete.html",
    "title": "scale_alpha_discrete",
    "section": "",
    "text": "scales.scale_alpha.scale_alpha_discrete(self, **kwargs)\n\n\nDiscrete Alpha Scale\n\n\n\n\nrange: tuple\n\nRange ([Minimum, Maximum]) of output alpha values. Should be between 0 and 1.\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nlimits: array_like = None\n\nLimits of the scale. For scales that deal with categoricals, these may be a subset or superset of the categories. Data values that are not in the limits will be treated as missing data and represented with the na_value.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values. Default value is True\n\nna_value: object\n\nIf na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right."
  },
  {
    "objectID": "reference/scale_alpha_discrete.html#parameters",
    "href": "reference/scale_alpha_discrete.html#parameters",
    "title": "scale_alpha_discrete",
    "section": "",
    "text": "range: tuple\n\nRange ([Minimum, Maximum]) of output alpha values. Should be between 0 and 1.\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nlimits: array_like = None\n\nLimits of the scale. For scales that deal with categoricals, these may be a subset or superset of the categories. Data values that are not in the limits will be treated as missing data and represented with the na_value.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values. Default value is True\n\nna_value: object\n\nIf na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right."
  },
  {
    "objectID": "reference/scale_alpha_manual.html",
    "href": "reference/scale_alpha_manual.html",
    "title": "scale_alpha_manual",
    "section": "",
    "text": "scales.scale_alpha_manual()\n\n\nCustom discrete alpha scale\n\n\n\n\nvalues: array_like | dict\n\nAlpha values (in the [0, 1] range) that make up the palette. The values will be matched with the limits of the scale or the breaks if provided. If it is a dict then it should map data values to alpha values.\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nlimits: array_like = None\n\nLimits of the scale. For scales that deal with categoricals, these may be a subset or superset of the categories. Data values that are not in the limits will be treated as missing data and represented with the na_value.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values. Default value is True\n\nna_value: object\n\nIf na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right."
  },
  {
    "objectID": "reference/scale_alpha_manual.html#parameters",
    "href": "reference/scale_alpha_manual.html#parameters",
    "title": "scale_alpha_manual",
    "section": "",
    "text": "values: array_like | dict\n\nAlpha values (in the [0, 1] range) that make up the palette. The values will be matched with the limits of the scale or the breaks if provided. If it is a dict then it should map data values to alpha values.\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nlimits: array_like = None\n\nLimits of the scale. For scales that deal with categoricals, these may be a subset or superset of the categories. Data values that are not in the limits will be treated as missing data and represented with the na_value.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values. Default value is True\n\nna_value: object\n\nIf na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right."
  },
  {
    "objectID": "reference/scale_color_cmap.html",
    "href": "reference/scale_color_cmap.html",
    "title": "scale_color_cmap",
    "section": "",
    "text": "scales.scale_color_cmap(self, cmap_name='viridis', **kwargs)\n\n\nCreate color scales using Matplotlib colormaps\n\n\n\n\ncmap_name: str = “viridis”\n\nA standard Matplotlib colormap name. The default is viridis. For the list of names checkout the output of matplotlib.cm.cmap_d.keys() or see the documentation &lt;http://matplotlib.org/users/colormaps.html&gt;_.\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\nna_value: str = “#7F7F7F”\n\nColor of missing values.\n\n\n\n\n\n\nmatplotlib.cm\n\n\n\nmatplotlib.colors"
  },
  {
    "objectID": "reference/scale_color_cmap.html#parameters",
    "href": "reference/scale_color_cmap.html#parameters",
    "title": "scale_color_cmap",
    "section": "",
    "text": "cmap_name: str = “viridis”\n\nA standard Matplotlib colormap name. The default is viridis. For the list of names checkout the output of matplotlib.cm.cmap_d.keys() or see the documentation &lt;http://matplotlib.org/users/colormaps.html&gt;_.\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\nna_value: str = “#7F7F7F”\n\nColor of missing values."
  },
  {
    "objectID": "reference/scale_color_cmap.html#see-also",
    "href": "reference/scale_color_cmap.html#see-also",
    "title": "scale_color_cmap",
    "section": "",
    "text": "matplotlib.cm\n\n\n\nmatplotlib.colors"
  },
  {
    "objectID": "reference/scale_color_datetime.html",
    "href": "reference/scale_color_datetime.html",
    "title": "scale_color_datetime",
    "section": "",
    "text": "scales.scale_color_datetime()\n\n\nDatetime color scale\n\n\n\n\ndate_breaks: str = None\n\nA string giving the distance between major breaks. For example '2 weeks', '5 years'. If specified, date_breaks takes precedence over breaks.\n\ndate_labels: str = None\n\nFormat string for the labels. See :ref:strftime &lt;strftime-strptime-behavior&gt;. If specified, date_labels takes precedence over labels.\n\ndate_minor_breaks: str = None\n\nA string giving the distance between minor breaks. For example '2 weeks', '5 years'. If specified, date_minor_breaks takes precedence over minor_breaks.\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\nna_value: scalar = float(“nan”)\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\ncmap_name: str = “viridis”\n\nA standard Matplotlib colormap name. The default is viridis. For the list of names checkout the output of matplotlib.cm.cmap_d.keys() or see the documentation &lt;http://matplotlib.org/users/colormaps.html&gt;_."
  },
  {
    "objectID": "reference/scale_color_datetime.html#parameters",
    "href": "reference/scale_color_datetime.html#parameters",
    "title": "scale_color_datetime",
    "section": "",
    "text": "date_breaks: str = None\n\nA string giving the distance between major breaks. For example '2 weeks', '5 years'. If specified, date_breaks takes precedence over breaks.\n\ndate_labels: str = None\n\nFormat string for the labels. See :ref:strftime &lt;strftime-strptime-behavior&gt;. If specified, date_labels takes precedence over labels.\n\ndate_minor_breaks: str = None\n\nA string giving the distance between minor breaks. For example '2 weeks', '5 years'. If specified, date_minor_breaks takes precedence over minor_breaks.\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\nna_value: scalar = float(“nan”)\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\ncmap_name: str = “viridis”\n\nA standard Matplotlib colormap name. The default is viridis. For the list of names checkout the output of matplotlib.cm.cmap_d.keys() or see the documentation &lt;http://matplotlib.org/users/colormaps.html&gt;_."
  },
  {
    "objectID": "reference/scale_color_discrete.html",
    "href": "reference/scale_color_discrete.html",
    "title": "scale_color_discrete",
    "section": "",
    "text": "scales.scale_color_discrete\n\nQualitative color scale with evenly spaced hues\n\n\n\nh : float first hue. Must be in the range [0, 1] l : float lightness. Must be in the range [0, 1] s : float saturation. Must be in the range [0, 1] colorspace : str, default=“hls” Color space to use. Should be one of hls or husl. breaks : bool | list | callable, default=True List of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks. expand : tuple, default=None Multiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n```\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\n```\n\nFor example,\n\n- `(0, 0)` - Do not expand.\n- `(0, 1)` - Expand lower and upper limits by 1 unit.\n- `(1, 0)` - Expand lower and upper limits by 100%.\n- `(0, 0, 0, 0)` - Do not expand, as `(0, 0)`.\n- `(0, 0, 0, 1)` - Expand upper limit by 1 unit.\n- `(0, 1, 0.1, 0)` - Expand lower limit by 1 unit and\n  upper limit by 10%.\n- `(0, 0, 0.1, 2)` - Expand upper limit by 10% plus\n  2 units.\n\nIf not specified, suitable defaults are chosen.\nname : str, default=None Name used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale. labels : bool | list | callable, default=True List of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings. palette : callable, default=None Function to map data points onto the scale. Most scales define their own palettes. aesthetics : list | str, default=None list of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun. limits : array_like, default=None Limits of the scale. For scales that deal with categoricals, these may be a subset or superset of the categories. Data values that are not in the limits will be treated as missing data and represented with the na_value. drop : bool, default=True Whether to drop unused categories from the scale na_translate : bool, default=True If True translate missing values and show them. If False remove missing values. Default value is True na_value : str, default=“#7F7F7F” Color of missing values."
  },
  {
    "objectID": "reference/scale_color_discrete.html#parameters",
    "href": "reference/scale_color_discrete.html#parameters",
    "title": "scale_color_discrete",
    "section": "",
    "text": "h : float first hue. Must be in the range [0, 1] l : float lightness. Must be in the range [0, 1] s : float saturation. Must be in the range [0, 1] colorspace : str, default=“hls” Color space to use. Should be one of hls or husl. breaks : bool | list | callable, default=True List of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks. expand : tuple, default=None Multiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n```\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\n```\n\nFor example,\n\n- `(0, 0)` - Do not expand.\n- `(0, 1)` - Expand lower and upper limits by 1 unit.\n- `(1, 0)` - Expand lower and upper limits by 100%.\n- `(0, 0, 0, 0)` - Do not expand, as `(0, 0)`.\n- `(0, 0, 0, 1)` - Expand upper limit by 1 unit.\n- `(0, 1, 0.1, 0)` - Expand lower limit by 1 unit and\n  upper limit by 10%.\n- `(0, 0, 0.1, 2)` - Expand upper limit by 10% plus\n  2 units.\n\nIf not specified, suitable defaults are chosen.\nname : str, default=None Name used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale. labels : bool | list | callable, default=True List of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings. palette : callable, default=None Function to map data points onto the scale. Most scales define their own palettes. aesthetics : list | str, default=None list of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun. limits : array_like, default=None Limits of the scale. For scales that deal with categoricals, these may be a subset or superset of the categories. Data values that are not in the limits will be treated as missing data and represented with the na_value. drop : bool, default=True Whether to drop unused categories from the scale na_translate : bool, default=True If True translate missing values and show them. If False remove missing values. Default value is True na_value : str, default=“#7F7F7F” Color of missing values."
  },
  {
    "objectID": "reference/scale_color_gradient.html",
    "href": "reference/scale_color_gradient.html",
    "title": "scale_color_gradient",
    "section": "",
    "text": "scales.scale_color_gradient(self, low='#132B43', high='#56B1F7', **kwargs)\n\n\nCreate a 2 point color gradient\n\n\n\n\nlow: str = ‘#132B43’\n\nlow color\n\nhigh: str = ‘#56B1F7’\n\nhigh color\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\nna_value: str = “#7F7F7F”\n\nColor of missing values.\n\n\n\n\n\n\nplotnine.scales.scale_color_gradient2\n\n\n\nplotnine.scales.scale_color_gradientn"
  },
  {
    "objectID": "reference/scale_color_gradient.html#parameters",
    "href": "reference/scale_color_gradient.html#parameters",
    "title": "scale_color_gradient",
    "section": "",
    "text": "low: str = ‘#132B43’\n\nlow color\n\nhigh: str = ‘#56B1F7’\n\nhigh color\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\nna_value: str = “#7F7F7F”\n\nColor of missing values."
  },
  {
    "objectID": "reference/scale_color_gradient.html#see-also",
    "href": "reference/scale_color_gradient.html#see-also",
    "title": "scale_color_gradient",
    "section": "",
    "text": "plotnine.scales.scale_color_gradient2\n\n\n\nplotnine.scales.scale_color_gradientn"
  },
  {
    "objectID": "reference/scale_color_gradientn.html",
    "href": "reference/scale_color_gradientn.html",
    "title": "scale_color_gradientn",
    "section": "",
    "text": "scales.scale_color_gradientn(self, colors, values=None, **kwargs)\n\n\nCreate a n color gradient\n\n\n\n\ncolors: (list)\n\nlist of colors\n\nvalues: list = None\n\nlist of points in the range [0, 1] at which to place each color. Must be the same size as colors. Default to evenly space the colors\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\nna_value: str = “#7F7F7F”\n\nColor of missing values\n\n\n\n\n\n\nplotnine.scales.scale_color_gradient\n\n\n\nplotnine.scales.scale_color_gradientn"
  },
  {
    "objectID": "reference/scale_color_gradientn.html#parameters",
    "href": "reference/scale_color_gradientn.html#parameters",
    "title": "scale_color_gradientn",
    "section": "",
    "text": "colors: (list)\n\nlist of colors\n\nvalues: list = None\n\nlist of points in the range [0, 1] at which to place each color. Must be the same size as colors. Default to evenly space the colors\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\nna_value: str = “#7F7F7F”\n\nColor of missing values"
  },
  {
    "objectID": "reference/scale_color_gradientn.html#see-also",
    "href": "reference/scale_color_gradientn.html#see-also",
    "title": "scale_color_gradientn",
    "section": "",
    "text": "plotnine.scales.scale_color_gradient\n\n\n\nplotnine.scales.scale_color_gradientn"
  },
  {
    "objectID": "reference/scale_color_grey.html",
    "href": "reference/scale_color_grey.html",
    "title": "scale_color_grey",
    "section": "",
    "text": "scales.scale_color_grey(self, start=0.2, end=0.8, **kwargs)\n\n\nSequential grey color scale.\n\n\n\n\nstart: float = 0.2\n\ngrey value at low end of palette.\n\nend: float = 0.8\n\ngrey value at high end of palette\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nlimits: array_like = None\n\nLimits of the scale. For scales that deal with categoricals, these may be a subset or superset of the categories. Data values that are not in the limits will be treated as missing data and represented with the na_value.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values. Default value is True\n\nna_value: object\n\nIf na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right."
  },
  {
    "objectID": "reference/scale_color_grey.html#parameters",
    "href": "reference/scale_color_grey.html#parameters",
    "title": "scale_color_grey",
    "section": "",
    "text": "start: float = 0.2\n\ngrey value at low end of palette.\n\nend: float = 0.8\n\ngrey value at high end of palette\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nlimits: array_like = None\n\nLimits of the scale. For scales that deal with categoricals, these may be a subset or superset of the categories. Data values that are not in the limits will be treated as missing data and represented with the na_value.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values. Default value is True\n\nna_value: object\n\nIf na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right."
  },
  {
    "objectID": "reference/scale_color_identity.html",
    "href": "reference/scale_color_identity.html",
    "title": "scale_color_identity",
    "section": "",
    "text": "scales.scale_identity.scale_color_identity()\n\n\nNo color scaling\n\n\n\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nlimits: array_like = None\n\nLimits of the scale. For scales that deal with categoricals, these may be a subset or superset of the categories. Data values that are not in the limits will be treated as missing data and represented with the na_value.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values. Default value is True\n\nna_value: object\n\nIf na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right.\n\nguide: None | ‘legend’ = None\n\nWhether to include a legend."
  },
  {
    "objectID": "reference/scale_color_identity.html#parameters",
    "href": "reference/scale_color_identity.html#parameters",
    "title": "scale_color_identity",
    "section": "",
    "text": "breaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nlimits: array_like = None\n\nLimits of the scale. For scales that deal with categoricals, these may be a subset or superset of the categories. Data values that are not in the limits will be treated as missing data and represented with the na_value.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values. Default value is True\n\nna_value: object\n\nIf na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right.\n\nguide: None | ‘legend’ = None\n\nWhether to include a legend."
  },
  {
    "objectID": "reference/scale_colour_identity.html",
    "href": "reference/scale_colour_identity.html",
    "title": "scale_colour_identity",
    "section": "",
    "text": "scales.scale_identity.scale_colour_identity\n\nNo color scaling\n\n\n\nbreaks : bool | list | callable, default=True List of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks. expand : tuple, default=None Multiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n```\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\n```\n\nFor example,\n\n- `(0, 0)` - Do not expand.\n- `(0, 1)` - Expand lower and upper limits by 1 unit.\n- `(1, 0)` - Expand lower and upper limits by 100%.\n- `(0, 0, 0, 0)` - Do not expand, as `(0, 0)`.\n- `(0, 0, 0, 1)` - Expand upper limit by 1 unit.\n- `(0, 1, 0.1, 0)` - Expand lower limit by 1 unit and\n  upper limit by 10%.\n- `(0, 0, 0.1, 2)` - Expand upper limit by 10% plus\n  2 units.\n\nIf not specified, suitable defaults are chosen.\nname : str, default=None Name used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale. labels : bool | list | callable, default=True List of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings. palette : callable, default=None Function to map data points onto the scale. Most scales define their own palettes. aesthetics : list | str, default=None list of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun. limits : array_like, default=None Limits of the scale. For scales that deal with categoricals, these may be a subset or superset of the categories. Data values that are not in the limits will be treated as missing data and represented with the na_value. drop : bool, default=True Whether to drop unused categories from the scale na_translate : bool, default=True If True translate missing values and show them. If False remove missing values. Default value is True na_value : object If na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right.\nguide : None | “legend”, default=None Whether to include a legend."
  },
  {
    "objectID": "reference/scale_colour_identity.html#parameters",
    "href": "reference/scale_colour_identity.html#parameters",
    "title": "scale_colour_identity",
    "section": "",
    "text": "breaks : bool | list | callable, default=True List of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks. expand : tuple, default=None Multiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n```\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\n```\n\nFor example,\n\n- `(0, 0)` - Do not expand.\n- `(0, 1)` - Expand lower and upper limits by 1 unit.\n- `(1, 0)` - Expand lower and upper limits by 100%.\n- `(0, 0, 0, 0)` - Do not expand, as `(0, 0)`.\n- `(0, 0, 0, 1)` - Expand upper limit by 1 unit.\n- `(0, 1, 0.1, 0)` - Expand lower limit by 1 unit and\n  upper limit by 10%.\n- `(0, 0, 0.1, 2)` - Expand upper limit by 10% plus\n  2 units.\n\nIf not specified, suitable defaults are chosen.\nname : str, default=None Name used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale. labels : bool | list | callable, default=True List of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings. palette : callable, default=None Function to map data points onto the scale. Most scales define their own palettes. aesthetics : list | str, default=None list of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun. limits : array_like, default=None Limits of the scale. For scales that deal with categoricals, these may be a subset or superset of the categories. Data values that are not in the limits will be treated as missing data and represented with the na_value. drop : bool, default=True Whether to drop unused categories from the scale na_translate : bool, default=True If True translate missing values and show them. If False remove missing values. Default value is True na_value : object If na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right.\nguide : None | “legend”, default=None Whether to include a legend."
  },
  {
    "objectID": "reference/scale_continuous.html",
    "href": "reference/scale_continuous.html",
    "title": "scale_continuous",
    "section": "",
    "text": "scales.scale_continuous.scale_continuous(self, **kwargs)\n\n\nBase class for all continuous scales\n\n\n\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\nna_value: scalar = float(“nan”)\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\n\n\n\n\nIf using the class directly all arguments must be keyword arguments."
  },
  {
    "objectID": "reference/scale_continuous.html#parameters",
    "href": "reference/scale_continuous.html#parameters",
    "title": "scale_continuous",
    "section": "",
    "text": "breaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\nna_value: scalar = float(“nan”)\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default."
  },
  {
    "objectID": "reference/scale_continuous.html#notes",
    "href": "reference/scale_continuous.html#notes",
    "title": "scale_continuous",
    "section": "",
    "text": "If using the class directly all arguments must be keyword arguments."
  },
  {
    "objectID": "reference/scale_discrete.html",
    "href": "reference/scale_discrete.html",
    "title": "scale_discrete",
    "section": "",
    "text": "scales.scale_discrete.scale_discrete()\n\n\nBase class for all discrete scales\n\n\n\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nlimits: array_like = None\n\nLimits of the scale. For scales that deal with categoricals, these may be a subset or superset of the categories. Data values that are not in the limits will be treated as missing data and represented with the na_value.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values. Default value is True\n\nna_value: object\n\nIf na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right."
  },
  {
    "objectID": "reference/scale_discrete.html#parameters",
    "href": "reference/scale_discrete.html#parameters",
    "title": "scale_discrete",
    "section": "",
    "text": "breaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nlimits: array_like = None\n\nLimits of the scale. For scales that deal with categoricals, these may be a subset or superset of the categories. Data values that are not in the limits will be treated as missing data and represented with the na_value.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values. Default value is True\n\nna_value: object\n\nIf na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right."
  },
  {
    "objectID": "reference/scale_fill_cmap.html",
    "href": "reference/scale_fill_cmap.html",
    "title": "scale_fill_cmap",
    "section": "",
    "text": "scales.scale_fill_cmap()\n\n\nCreate color scales using Matplotlib colormaps\n\n\n\n\ncmap_name: str = “viridis”\n\nA standard Matplotlib colormap name. The default is viridis. For the list of names checkout the output of matplotlib.cm.cmap_d.keys() or see the documentation &lt;http://matplotlib.org/users/colormaps.html&gt;_.\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\nna_value: str = “#7F7F7F”\n\nColor of missing values."
  },
  {
    "objectID": "reference/scale_fill_cmap.html#parameters",
    "href": "reference/scale_fill_cmap.html#parameters",
    "title": "scale_fill_cmap",
    "section": "",
    "text": "cmap_name: str = “viridis”\n\nA standard Matplotlib colormap name. The default is viridis. For the list of names checkout the output of matplotlib.cm.cmap_d.keys() or see the documentation &lt;http://matplotlib.org/users/colormaps.html&gt;_.\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\nna_value: str = “#7F7F7F”\n\nColor of missing values."
  },
  {
    "objectID": "reference/scale_fill_datetime.html",
    "href": "reference/scale_fill_datetime.html",
    "title": "scale_fill_datetime",
    "section": "",
    "text": "scales.scale_fill_datetime()\n\n\nDatetime fill scale\n\n\n\n\ndate_breaks: str = None\n\nA string giving the distance between major breaks. For example '2 weeks', '5 years'. If specified, date_breaks takes precedence over breaks.\n\ndate_labels: str = None\n\nFormat string for the labels. See :ref:strftime &lt;strftime-strptime-behavior&gt;. If specified, date_labels takes precedence over labels.\n\ndate_minor_breaks: str = None\n\nA string giving the distance between minor breaks. For example '2 weeks', '5 years'. If specified, date_minor_breaks takes precedence over minor_breaks.\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\nna_value: scalar = float(“nan”)\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\ncmap_name: str = “viridis”\n\nA standard Matplotlib colormap name. The default is viridis. For the list of names checkout the output of matplotlib.cm.cmap_d.keys() or see the documentation &lt;http://matplotlib.org/users/colormaps.html&gt;_."
  },
  {
    "objectID": "reference/scale_fill_datetime.html#parameters",
    "href": "reference/scale_fill_datetime.html#parameters",
    "title": "scale_fill_datetime",
    "section": "",
    "text": "date_breaks: str = None\n\nA string giving the distance between major breaks. For example '2 weeks', '5 years'. If specified, date_breaks takes precedence over breaks.\n\ndate_labels: str = None\n\nFormat string for the labels. See :ref:strftime &lt;strftime-strptime-behavior&gt;. If specified, date_labels takes precedence over labels.\n\ndate_minor_breaks: str = None\n\nA string giving the distance between minor breaks. For example '2 weeks', '5 years'. If specified, date_minor_breaks takes precedence over minor_breaks.\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\nna_value: scalar = float(“nan”)\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\ncmap_name: str = “viridis”\n\nA standard Matplotlib colormap name. The default is viridis. For the list of names checkout the output of matplotlib.cm.cmap_d.keys() or see the documentation &lt;http://matplotlib.org/users/colormaps.html&gt;_."
  },
  {
    "objectID": "reference/scale_fill_discrete.html",
    "href": "reference/scale_fill_discrete.html",
    "title": "scale_fill_discrete",
    "section": "",
    "text": "scales.scale_fill_discrete\n\nQualitative color scale with evenly spaced hues\n\n\n\nh : float first hue. Must be in the range [0, 1] l : float lightness. Must be in the range [0, 1] s : float saturation. Must be in the range [0, 1] colorspace : str, default=“hls” Color space to use. Should be one of hls or husl. breaks : bool | list | callable, default=True List of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks. expand : tuple, default=None Multiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n```\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\n```\n\nFor example,\n\n- `(0, 0)` - Do not expand.\n- `(0, 1)` - Expand lower and upper limits by 1 unit.\n- `(1, 0)` - Expand lower and upper limits by 100%.\n- `(0, 0, 0, 0)` - Do not expand, as `(0, 0)`.\n- `(0, 0, 0, 1)` - Expand upper limit by 1 unit.\n- `(0, 1, 0.1, 0)` - Expand lower limit by 1 unit and\n  upper limit by 10%.\n- `(0, 0, 0.1, 2)` - Expand upper limit by 10% plus\n  2 units.\n\nIf not specified, suitable defaults are chosen.\nname : str, default=None Name used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale. labels : bool | list | callable, default=True List of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings. palette : callable, default=None Function to map data points onto the scale. Most scales define their own palettes. aesthetics : list | str, default=None list of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun. limits : array_like, default=None Limits of the scale. For scales that deal with categoricals, these may be a subset or superset of the categories. Data values that are not in the limits will be treated as missing data and represented with the na_value. drop : bool, default=True Whether to drop unused categories from the scale na_translate : bool, default=True If True translate missing values and show them. If False remove missing values. Default value is True na_value : str, default=“#7F7F7F” Color of missing values."
  },
  {
    "objectID": "reference/scale_fill_discrete.html#parameters",
    "href": "reference/scale_fill_discrete.html#parameters",
    "title": "scale_fill_discrete",
    "section": "",
    "text": "h : float first hue. Must be in the range [0, 1] l : float lightness. Must be in the range [0, 1] s : float saturation. Must be in the range [0, 1] colorspace : str, default=“hls” Color space to use. Should be one of hls or husl. breaks : bool | list | callable, default=True List of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks. expand : tuple, default=None Multiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n```\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\n```\n\nFor example,\n\n- `(0, 0)` - Do not expand.\n- `(0, 1)` - Expand lower and upper limits by 1 unit.\n- `(1, 0)` - Expand lower and upper limits by 100%.\n- `(0, 0, 0, 0)` - Do not expand, as `(0, 0)`.\n- `(0, 0, 0, 1)` - Expand upper limit by 1 unit.\n- `(0, 1, 0.1, 0)` - Expand lower limit by 1 unit and\n  upper limit by 10%.\n- `(0, 0, 0.1, 2)` - Expand upper limit by 10% plus\n  2 units.\n\nIf not specified, suitable defaults are chosen.\nname : str, default=None Name used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale. labels : bool | list | callable, default=True List of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings. palette : callable, default=None Function to map data points onto the scale. Most scales define their own palettes. aesthetics : list | str, default=None list of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun. limits : array_like, default=None Limits of the scale. For scales that deal with categoricals, these may be a subset or superset of the categories. Data values that are not in the limits will be treated as missing data and represented with the na_value. drop : bool, default=True Whether to drop unused categories from the scale na_translate : bool, default=True If True translate missing values and show them. If False remove missing values. Default value is True na_value : str, default=“#7F7F7F” Color of missing values."
  },
  {
    "objectID": "reference/scale_fill_gradient.html",
    "href": "reference/scale_fill_gradient.html",
    "title": "scale_fill_gradient",
    "section": "",
    "text": "scales.scale_fill_gradient()\n\n\nCreate a 2 point color gradient\n\n\n\n\nlow: str\n\nlow color\n\nhigh: str\n\nhigh color\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\nna_value: str = “#7F7F7F”\n\nColor of missing values."
  },
  {
    "objectID": "reference/scale_fill_gradient.html#parameters",
    "href": "reference/scale_fill_gradient.html#parameters",
    "title": "scale_fill_gradient",
    "section": "",
    "text": "low: str\n\nlow color\n\nhigh: str\n\nhigh color\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\nna_value: str = “#7F7F7F”\n\nColor of missing values."
  },
  {
    "objectID": "reference/scale_fill_gradientn.html",
    "href": "reference/scale_fill_gradientn.html",
    "title": "scale_fill_gradientn",
    "section": "",
    "text": "scales.scale_fill_gradientn()\n\n\nCreate a n color gradient\n\n\n\n\ncolors: (list)\n\nlist of colors\n\nvalues: list = None\n\nlist of points in the range [0, 1] at which to place each color. Must be the same size as colors. Default to evenly space the colors\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\nna_value: str = “#7F7F7F”\n\nColor of missing values"
  },
  {
    "objectID": "reference/scale_fill_gradientn.html#parameters",
    "href": "reference/scale_fill_gradientn.html#parameters",
    "title": "scale_fill_gradientn",
    "section": "",
    "text": "colors: (list)\n\nlist of colors\n\nvalues: list = None\n\nlist of points in the range [0, 1] at which to place each color. Must be the same size as colors. Default to evenly space the colors\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\nna_value: str = “#7F7F7F”\n\nColor of missing values"
  },
  {
    "objectID": "reference/scale_fill_grey.html",
    "href": "reference/scale_fill_grey.html",
    "title": "scale_fill_grey",
    "section": "",
    "text": "scales.scale_fill_grey()\n\n\nSequential grey color scale.\n\n\n\n\nstart: float = 0.2\n\ngrey value at low end of palette.\n\nend: float = 0.8\n\ngrey value at high end of palette\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nlimits: array_like = None\n\nLimits of the scale. For scales that deal with categoricals, these may be a subset or superset of the categories. Data values that are not in the limits will be treated as missing data and represented with the na_value.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values. Default value is True\n\nna_value: object\n\nIf na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right."
  },
  {
    "objectID": "reference/scale_fill_grey.html#parameters",
    "href": "reference/scale_fill_grey.html#parameters",
    "title": "scale_fill_grey",
    "section": "",
    "text": "start: float = 0.2\n\ngrey value at low end of palette.\n\nend: float = 0.8\n\ngrey value at high end of palette\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nlimits: array_like = None\n\nLimits of the scale. For scales that deal with categoricals, these may be a subset or superset of the categories. Data values that are not in the limits will be treated as missing data and represented with the na_value.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values. Default value is True\n\nna_value: object\n\nIf na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right."
  },
  {
    "objectID": "reference/scale_fill_identity.html",
    "href": "reference/scale_fill_identity.html",
    "title": "scale_fill_identity",
    "section": "",
    "text": "scales.scale_identity.scale_fill_identity()\n\n\nNo color scaling\n\n\n\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nlimits: array_like = None\n\nLimits of the scale. For scales that deal with categoricals, these may be a subset or superset of the categories. Data values that are not in the limits will be treated as missing data and represented with the na_value.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values. Default value is True\n\nna_value: object\n\nIf na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right.\n\nguide: None | ‘legend’ = None\n\nWhether to include a legend."
  },
  {
    "objectID": "reference/scale_fill_identity.html#parameters",
    "href": "reference/scale_fill_identity.html#parameters",
    "title": "scale_fill_identity",
    "section": "",
    "text": "breaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nlimits: array_like = None\n\nLimits of the scale. For scales that deal with categoricals, these may be a subset or superset of the categories. Data values that are not in the limits will be treated as missing data and represented with the na_value.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values. Default value is True\n\nna_value: object\n\nIf na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right.\n\nguide: None | ‘legend’ = None\n\nWhether to include a legend."
  },
  {
    "objectID": "reference/scale_linetype.html",
    "href": "reference/scale_linetype.html",
    "title": "scale_linetype",
    "section": "",
    "text": "scales.scale_linetype(self, **kwargs)\n\n\nScale for line patterns\n\n\n\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nlimits: array_like = None\n\nLimits of the scale. For scales that deal with categoricals, these may be a subset or superset of the categories. Data values that are not in the limits will be treated as missing data and represented with the na_value.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values. Default value is True\n\nna_value: object\n\nIf na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right.\n\n\n\n\n\nThe available linetypes are 'solid', 'dashed', 'dashdot', 'dotted' If you need more custom linetypes, use scale_linetype_manual"
  },
  {
    "objectID": "reference/scale_linetype.html#parameters",
    "href": "reference/scale_linetype.html#parameters",
    "title": "scale_linetype",
    "section": "",
    "text": "breaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nlimits: array_like = None\n\nLimits of the scale. For scales that deal with categoricals, these may be a subset or superset of the categories. Data values that are not in the limits will be treated as missing data and represented with the na_value.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values. Default value is True\n\nna_value: object\n\nIf na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right."
  },
  {
    "objectID": "reference/scale_linetype.html#notes",
    "href": "reference/scale_linetype.html#notes",
    "title": "scale_linetype",
    "section": "",
    "text": "The available linetypes are 'solid', 'dashed', 'dashdot', 'dotted' If you need more custom linetypes, use scale_linetype_manual"
  },
  {
    "objectID": "reference/scale_linetype_identity.html",
    "href": "reference/scale_linetype_identity.html",
    "title": "scale_linetype_identity",
    "section": "",
    "text": "scales.scale_identity.scale_linetype_identity()\n\n\nNo linetype scaling\n\n\n\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nlimits: array_like = None\n\nLimits of the scale. For scales that deal with categoricals, these may be a subset or superset of the categories. Data values that are not in the limits will be treated as missing data and represented with the na_value.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values. Default value is True\n\nna_value: object\n\nIf na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right.\n\nguide: None | ‘legend’ = None\n\nWhether to include a legend."
  },
  {
    "objectID": "reference/scale_linetype_identity.html#parameters",
    "href": "reference/scale_linetype_identity.html#parameters",
    "title": "scale_linetype_identity",
    "section": "",
    "text": "breaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nlimits: array_like = None\n\nLimits of the scale. For scales that deal with categoricals, these may be a subset or superset of the categories. Data values that are not in the limits will be treated as missing data and represented with the na_value.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values. Default value is True\n\nna_value: object\n\nIf na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right.\n\nguide: None | ‘legend’ = None\n\nWhether to include a legend."
  },
  {
    "objectID": "reference/scale_shape.html",
    "href": "reference/scale_shape.html",
    "title": "scale_shape",
    "section": "",
    "text": "scales.scale_shape(self, unfilled=False, **kwargs)\n\n\nScale for shapes\n\n\n\n\nunfilled: bool = False\n\nIf True, then all shapes will have no interiors that can be a filled.\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nlimits: array_like = None\n\nLimits of the scale. For scales that deal with categoricals, these may be a subset or superset of the categories. Data values that are not in the limits will be treated as missing data and represented with the na_value.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values. Default value is True\n\nna_value: object\n\nIf na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right."
  },
  {
    "objectID": "reference/scale_shape.html#parameters",
    "href": "reference/scale_shape.html#parameters",
    "title": "scale_shape",
    "section": "",
    "text": "unfilled: bool = False\n\nIf True, then all shapes will have no interiors that can be a filled.\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nlimits: array_like = None\n\nLimits of the scale. For scales that deal with categoricals, these may be a subset or superset of the categories. Data values that are not in the limits will be treated as missing data and represented with the na_value.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values. Default value is True\n\nna_value: object\n\nIf na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right."
  },
  {
    "objectID": "reference/scale_shape_identity.html",
    "href": "reference/scale_shape_identity.html",
    "title": "scale_shape_identity",
    "section": "",
    "text": "scales.scale_identity.scale_shape_identity()\n\n\nNo shape scaling\n\n\n\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nlimits: array_like = None\n\nLimits of the scale. For scales that deal with categoricals, these may be a subset or superset of the categories. Data values that are not in the limits will be treated as missing data and represented with the na_value.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values. Default value is True\n\nna_value: object\n\nIf na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right.\n\nguide: None | ‘legend’ = None\n\nWhether to include a legend."
  },
  {
    "objectID": "reference/scale_shape_identity.html#parameters",
    "href": "reference/scale_shape_identity.html#parameters",
    "title": "scale_shape_identity",
    "section": "",
    "text": "breaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nlimits: array_like = None\n\nLimits of the scale. For scales that deal with categoricals, these may be a subset or superset of the categories. Data values that are not in the limits will be treated as missing data and represented with the na_value.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values. Default value is True\n\nna_value: object\n\nIf na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right.\n\nguide: None | ‘legend’ = None\n\nWhether to include a legend."
  },
  {
    "objectID": "reference/scale_size.html",
    "href": "reference/scale_size.html",
    "title": "scale_size",
    "section": "",
    "text": "scales.scale_size\n\nContinuous area size scale\n\n\n\nrange : array_like Minimum and maximum area of the plotting symbol. It must be of size 2. breaks : bool | list | callable, default=True List of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks. expand : tuple, default=None Multiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n```\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\n```\n\nFor example,\n\n- `(0, 0)` - Do not expand.\n- `(0, 1)` - Expand lower and upper limits by 1 unit.\n- `(1, 0)` - Expand lower and upper limits by 100%.\n- `(0, 0, 0, 0)` - Do not expand, as `(0, 0)`.\n- `(0, 0, 0, 1)` - Expand upper limit by 1 unit.\n- `(0, 1, 0.1, 0)` - Expand lower limit by 1 unit and\n  upper limit by 10%.\n- `(0, 0, 0.1, 2)` - Expand upper limit by 10% plus\n  2 units.\n\nIf not specified, suitable defaults are chosen.\nname : str, default=None Name used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale. labels : bool | list | callable, default=True List of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings. limits : array_like, default=None Limits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories. na_value : scalar, default=float(“nan”) What value to assign to missing values. Default is to assign np.nan. palette : callable, default=None Function to map data points onto the scale. Most scales define their own palettes. aesthetics : list | str, default=None list of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun. trans : str | callable Name of a trans function or a trans function. See :mod:mizani.transforms for possible options. oob : callable, default=mizani.bounds.censor Function to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped. minor_breaks : list | int | callable, default=None If a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them. rescaler : callable, default=mizani.bounds.rescale Function to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default."
  },
  {
    "objectID": "reference/scale_size.html#parameters",
    "href": "reference/scale_size.html#parameters",
    "title": "scale_size",
    "section": "",
    "text": "range : array_like Minimum and maximum area of the plotting symbol. It must be of size 2. breaks : bool | list | callable, default=True List of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks. expand : tuple, default=None Multiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n```\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\n```\n\nFor example,\n\n- `(0, 0)` - Do not expand.\n- `(0, 1)` - Expand lower and upper limits by 1 unit.\n- `(1, 0)` - Expand lower and upper limits by 100%.\n- `(0, 0, 0, 0)` - Do not expand, as `(0, 0)`.\n- `(0, 0, 0, 1)` - Expand upper limit by 1 unit.\n- `(0, 1, 0.1, 0)` - Expand lower limit by 1 unit and\n  upper limit by 10%.\n- `(0, 0, 0.1, 2)` - Expand upper limit by 10% plus\n  2 units.\n\nIf not specified, suitable defaults are chosen.\nname : str, default=None Name used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale. labels : bool | list | callable, default=True List of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings. limits : array_like, default=None Limits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories. na_value : scalar, default=float(“nan”) What value to assign to missing values. Default is to assign np.nan. palette : callable, default=None Function to map data points onto the scale. Most scales define their own palettes. aesthetics : list | str, default=None list of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun. trans : str | callable Name of a trans function or a trans function. See :mod:mizani.transforms for possible options. oob : callable, default=mizani.bounds.censor Function to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped. minor_breaks : list | int | callable, default=None If a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them. rescaler : callable, default=mizani.bounds.rescale Function to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default."
  },
  {
    "objectID": "reference/scale_size_continuous.html",
    "href": "reference/scale_size_continuous.html",
    "title": "scale_size_continuous",
    "section": "",
    "text": "scales.scale_size_continuous(self, range=(1, 6), **kwargs)\n\n\nContinuous area size scale\n\n\n\n\nrange: array_like = (1, 6)\n\nMinimum and maximum area of the plotting symbol. It must be of size 2.\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\nna_value: scalar = float(“nan”)\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default."
  },
  {
    "objectID": "reference/scale_size_continuous.html#parameters",
    "href": "reference/scale_size_continuous.html#parameters",
    "title": "scale_size_continuous",
    "section": "",
    "text": "range: array_like = (1, 6)\n\nMinimum and maximum area of the plotting symbol. It must be of size 2.\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\nna_value: scalar = float(“nan”)\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default."
  },
  {
    "objectID": "reference/scale_size_discrete.html",
    "href": "reference/scale_size_discrete.html",
    "title": "scale_size_discrete",
    "section": "",
    "text": "scales.scale_size_discrete(self, **kwargs)\n\n\nDiscrete area size scale\n\n\n\n\nrange: array_like\n\nMinimum and maximum size of the plotting symbol. It must be of size 2.\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nlimits: array_like = None\n\nLimits of the scale. For scales that deal with categoricals, these may be a subset or superset of the categories. Data values that are not in the limits will be treated as missing data and represented with the na_value.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values. Default value is True\n\nna_value: object\n\nIf na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right."
  },
  {
    "objectID": "reference/scale_size_discrete.html#parameters",
    "href": "reference/scale_size_discrete.html#parameters",
    "title": "scale_size_discrete",
    "section": "",
    "text": "range: array_like\n\nMinimum and maximum size of the plotting symbol. It must be of size 2.\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nlimits: array_like = None\n\nLimits of the scale. For scales that deal with categoricals, these may be a subset or superset of the categories. Data values that are not in the limits will be treated as missing data and represented with the na_value.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values. Default value is True\n\nna_value: object\n\nIf na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right."
  },
  {
    "objectID": "reference/scale_size_manual.html",
    "href": "reference/scale_size_manual.html",
    "title": "scale_size_manual",
    "section": "",
    "text": "scales.scale_size_manual()\n\n\nCustom discrete size scale\n\n\n\n\nvalues: array_like | dict\n\nSizes that make up the palette. The values will be matched with the limits of the scale or the breaks if provided. If it is a dict then it should map data values to sizes.\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nlimits: array_like = None\n\nLimits of the scale. For scales that deal with categoricals, these may be a subset or superset of the categories. Data values that are not in the limits will be treated as missing data and represented with the na_value.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values. Default value is True\n\nna_value: object\n\nIf na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right."
  },
  {
    "objectID": "reference/scale_size_manual.html#parameters",
    "href": "reference/scale_size_manual.html#parameters",
    "title": "scale_size_manual",
    "section": "",
    "text": "values: array_like | dict\n\nSizes that make up the palette. The values will be matched with the limits of the scale or the breaks if provided. If it is a dict then it should map data values to sizes.\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nlimits: array_like = None\n\nLimits of the scale. For scales that deal with categoricals, these may be a subset or superset of the categories. Data values that are not in the limits will be treated as missing data and represented with the na_value.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values. Default value is True\n\nna_value: object\n\nIf na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right."
  },
  {
    "objectID": "reference/scale_x_continuous.html",
    "href": "reference/scale_x_continuous.html",
    "title": "scale_x_continuous",
    "section": "",
    "text": "scales.scale_x_continuous()\n\n\nContinuous x position\n\n\n\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\nna_value: scalar = float(“nan”)\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default."
  },
  {
    "objectID": "reference/scale_x_continuous.html#parameters",
    "href": "reference/scale_x_continuous.html#parameters",
    "title": "scale_x_continuous",
    "section": "",
    "text": "breaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\nna_value: scalar = float(“nan”)\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default."
  },
  {
    "objectID": "reference/scale_x_datetime.html",
    "href": "reference/scale_x_datetime.html",
    "title": "scale_x_datetime",
    "section": "",
    "text": "scales.scale_x_datetime()\n\n\nContinuous x position for datetime data points\n\n\n\n\ndate_breaks: str = None\n\nA string giving the distance between major breaks. For example '2 weeks', '5 years'. If specified, date_breaks takes precedence over breaks.\n\ndate_labels: str = None\n\nFormat string for the labels. See :ref:strftime &lt;strftime-strptime-behavior&gt;. If specified, date_labels takes precedence over labels.\n\ndate_minor_breaks: str = None\n\nA string giving the distance between minor breaks. For example '2 weeks', '5 years'. If specified, date_minor_breaks takes precedence over minor_breaks.\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\nna_value: scalar = float(“nan”)\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default."
  },
  {
    "objectID": "reference/scale_x_datetime.html#parameters",
    "href": "reference/scale_x_datetime.html#parameters",
    "title": "scale_x_datetime",
    "section": "",
    "text": "date_breaks: str = None\n\nA string giving the distance between major breaks. For example '2 weeks', '5 years'. If specified, date_breaks takes precedence over breaks.\n\ndate_labels: str = None\n\nFormat string for the labels. See :ref:strftime &lt;strftime-strptime-behavior&gt;. If specified, date_labels takes precedence over labels.\n\ndate_minor_breaks: str = None\n\nA string giving the distance between minor breaks. For example '2 weeks', '5 years'. If specified, date_minor_breaks takes precedence over minor_breaks.\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\nna_value: scalar = float(“nan”)\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default."
  },
  {
    "objectID": "reference/scale_x_log10.html",
    "href": "reference/scale_x_log10.html",
    "title": "scale_x_log10",
    "section": "",
    "text": "scales.scale_x_log10()\n\n\nContinuous x position log10 transformed scale\n\n\n\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\nna_value: scalar = float(“nan”)\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default."
  },
  {
    "objectID": "reference/scale_x_log10.html#parameters",
    "href": "reference/scale_x_log10.html#parameters",
    "title": "scale_x_log10",
    "section": "",
    "text": "breaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\nna_value: scalar = float(“nan”)\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default."
  },
  {
    "objectID": "reference/scale_x_sqrt.html",
    "href": "reference/scale_x_sqrt.html",
    "title": "scale_x_sqrt",
    "section": "",
    "text": "scales.scale_x_sqrt()\n\n\nContinuous x position sqrt transformed scale\n\n\n\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\nna_value: scalar = float(“nan”)\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default."
  },
  {
    "objectID": "reference/scale_x_sqrt.html#parameters",
    "href": "reference/scale_x_sqrt.html#parameters",
    "title": "scale_x_sqrt",
    "section": "",
    "text": "breaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\nna_value: scalar = float(“nan”)\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default."
  },
  {
    "objectID": "reference/scale_y_continuous.html",
    "href": "reference/scale_y_continuous.html",
    "title": "scale_y_continuous",
    "section": "",
    "text": "scales.scale_y_continuous()\n\n\nContinuous y position\n\n\n\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\nna_value: scalar = float(“nan”)\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default."
  },
  {
    "objectID": "reference/scale_y_continuous.html#parameters",
    "href": "reference/scale_y_continuous.html#parameters",
    "title": "scale_y_continuous",
    "section": "",
    "text": "breaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\nna_value: scalar = float(“nan”)\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default."
  },
  {
    "objectID": "reference/scale_y_datetime.html",
    "href": "reference/scale_y_datetime.html",
    "title": "scale_y_datetime",
    "section": "",
    "text": "scales.scale_y_datetime()\n\n\nContinuous y position for datetime data points\n\n\n\n\ndate_breaks: str = None\n\nA string giving the distance between major breaks. For example '2 weeks', '5 years'. If specified, date_breaks takes precedence over breaks.\n\ndate_labels: str = None\n\nFormat string for the labels. See :ref:strftime &lt;strftime-strptime-behavior&gt;. If specified, date_labels takes precedence over labels.\n\ndate_minor_breaks: str = None\n\nA string giving the distance between minor breaks. For example '2 weeks', '5 years'. If specified, date_minor_breaks takes precedence over minor_breaks.\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\nna_value: scalar = float(“nan”)\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default."
  },
  {
    "objectID": "reference/scale_y_datetime.html#parameters",
    "href": "reference/scale_y_datetime.html#parameters",
    "title": "scale_y_datetime",
    "section": "",
    "text": "date_breaks: str = None\n\nA string giving the distance between major breaks. For example '2 weeks', '5 years'. If specified, date_breaks takes precedence over breaks.\n\ndate_labels: str = None\n\nFormat string for the labels. See :ref:strftime &lt;strftime-strptime-behavior&gt;. If specified, date_labels takes precedence over labels.\n\ndate_minor_breaks: str = None\n\nA string giving the distance between minor breaks. For example '2 weeks', '5 years'. If specified, date_minor_breaks takes precedence over minor_breaks.\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\nna_value: scalar = float(“nan”)\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default."
  },
  {
    "objectID": "reference/scale_y_log10.html",
    "href": "reference/scale_y_log10.html",
    "title": "scale_y_log10",
    "section": "",
    "text": "scales.scale_y_log10()\n\n\nContinuous y position log10 transformed scale\n\n\n\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\nna_value: scalar = float(“nan”)\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default."
  },
  {
    "objectID": "reference/scale_y_log10.html#parameters",
    "href": "reference/scale_y_log10.html#parameters",
    "title": "scale_y_log10",
    "section": "",
    "text": "breaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\nna_value: scalar = float(“nan”)\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default."
  },
  {
    "objectID": "reference/scale_y_sqrt.html",
    "href": "reference/scale_y_sqrt.html",
    "title": "scale_y_sqrt",
    "section": "",
    "text": "scales.scale_y_sqrt()\n\n\nContinuous y position sqrt transformed scale\n\n\n\n\nbreaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\nna_value: scalar = float(“nan”)\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default."
  },
  {
    "objectID": "reference/scale_y_sqrt.html#parameters",
    "href": "reference/scale_y_sqrt.html#parameters",
    "title": "scale_y_sqrt",
    "section": "",
    "text": "breaks: bool | list | callable = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nexpand: tuple = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nname: str = None\n\nName used as the label of the scale. This is what shows up as the axis label or legend title. Suitable defaults are chosen depending on the type of scale.\n\nlabels: bool | list | callable = True\n\nList of :py:class:str. Labels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nlimits: array_like = None\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\nna_value: scalar = float(“nan”)\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\npalette: callable = None\n\nFunction to map data points onto the scale. Most scales define their own palettes.\n\naesthetics: list | str = None\n\nlist of :py:class:str. Aesthetics covered by the scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ntrans: str | callable\n\nName of a trans function or a trans function. See :mod:mizani.transforms for possible options.\n\noob: callable = mizani.bounds.censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: list | int | callable = None\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\nrescaler: callable = mizani.bounds.rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default."
  },
  {
    "objectID": "reference/seals.html",
    "href": "reference/seals.html",
    "title": "seals",
    "section": "",
    "text": "seals\ndata.seals\n\nVector field of seal movements.\nDescription\nThis vector field was produced from the data described in Brillinger, D.R., Preisler, H.K., Ager, A.A. and Kie, J.G. “An exploratory data analysis (EDA) of the paths of moving animals”. J. Statistical Planning and Inference 122 (2004), 43-63, using the methods of Brillinger, D.R., “Learning a potential function from a trajectory”, Signal Processing Letters. December (2007).\nFormat\nA data frame with 1155 rows and 4 variables\n\n\n\nColumn\nDescription\n\n\n\n\nlat\nLatitude\n\n\nlong\nLongitude\n\n\ndelta_long\nChange in Longitude\n\n\ndelta_lat\nChange in Latitude\n\n\n\nReferences"
  },
  {
    "objectID": "reference/stage.html",
    "href": "reference/stage.html",
    "title": "stage",
    "section": "",
    "text": "mapping.stage(self, start=None, after_stat=None, after_scale=None)\n\n\nStage allows you evaluating mapping at more than one stage\nYou can evaluate an expression of a variable in a dataframe, and later evaluate an expression that modifies the values mapped to the scale.\n\n\n\n\nstart: expression | array_like | scalar = None\n\nAesthetic expression using primary variables from the layer data.\n\nafter_stat: expression = None\n\nAesthetic expression using variables calculated by the stat.\n\nafter_scale: expression = None\n\nAesthetic expression using aesthetics of the layer."
  },
  {
    "objectID": "reference/stage.html#parameters",
    "href": "reference/stage.html#parameters",
    "title": "stage",
    "section": "",
    "text": "start: expression | array_like | scalar = None\n\nAesthetic expression using primary variables from the layer data.\n\nafter_stat: expression = None\n\nAesthetic expression using variables calculated by the stat.\n\nafter_scale: expression = None\n\nAesthetic expression using aesthetics of the layer."
  },
  {
    "objectID": "reference/stat_bin.html",
    "href": "reference/stat_bin.html",
    "title": "stat_bin",
    "section": "",
    "text": "stats.stat_bin()\n\n\nCount cases in each interval\nUsage\nstat_bin(mapping=None, data=None, geom='histogram', position='stack',\n         na_rm=False, closed='right', breaks=None, center=None, bins=None,\n         binwidth=None, boundary=None, pad=False, **kwargs)\nOnly the mapping and data can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the geom.\n\n\n\n\nmapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\nweight\n\n\nNone\n\n\n\n\ny\n\n\nafter_stat('count')\n\n\n\n\nThe bold aesthetics are required.\nOptions for computed aesthetics\n\"count\"    # number of points in bin\n\"density\"  # density of points in bin, scaled to integrate to 1\n\"ncount\"   # count, scaled to maximum of 1\n\"ndensity\" # density, scaled to maximum of 1\n\"ngroup\"   # number of points in group\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom: str | geom = “histogram”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “stack”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\nbinwidth: float = None\n\nThe width of the bins. The default is to use bins bins that cover the range of the data. You should always override this value, exploring multiple widths to find the best to illustrate the stories in your data.\n\nbins: int = None\n\nNumber of bins. Overridden by binwidth. If None, a number is computed using the freedman-diaconis method.\n\nbreaks: array - like = None\n\nBin boundaries. This supercedes the binwidth, bins, center and boundary.\n\ncenter: float = None\n\nThe center of one of the bins. Note that if center is above or below the range of the data, things will be shifted by an appropriate number of widths. To center on integers, for example, use width=1 and :py:center=0, even if 0 i s outside the range of the data. At most one of center and boundary may be specified.\n\nboundary: float = None\n\nA boundary between two bins. As with center, things are shifted when boundary is outside the range of the data. For example, to center on integers, use width=1 and boundary=0.5, even if 1 is outside the range of the data. At most one of center and boundary may be specified.\n\nclosed: left | right = “right”\n\nWhich edge of the bins is included.\n\npad: bool = False\n\nIf True, adds empty bins at either side of x. This ensures that frequency polygons touch 0."
  },
  {
    "objectID": "reference/stat_bin.html#parameters",
    "href": "reference/stat_bin.html#parameters",
    "title": "stat_bin",
    "section": "",
    "text": "mapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\nweight\n\n\nNone\n\n\n\n\ny\n\n\nafter_stat('count')\n\n\n\n\nThe bold aesthetics are required.\nOptions for computed aesthetics\n\"count\"    # number of points in bin\n\"density\"  # density of points in bin, scaled to integrate to 1\n\"ncount\"   # count, scaled to maximum of 1\n\"ndensity\" # density, scaled to maximum of 1\n\"ngroup\"   # number of points in group\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom: str | geom = “histogram”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “stack”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\nbinwidth: float = None\n\nThe width of the bins. The default is to use bins bins that cover the range of the data. You should always override this value, exploring multiple widths to find the best to illustrate the stories in your data.\n\nbins: int = None\n\nNumber of bins. Overridden by binwidth. If None, a number is computed using the freedman-diaconis method.\n\nbreaks: array - like = None\n\nBin boundaries. This supercedes the binwidth, bins, center and boundary.\n\ncenter: float = None\n\nThe center of one of the bins. Note that if center is above or below the range of the data, things will be shifted by an appropriate number of widths. To center on integers, for example, use width=1 and :py:center=0, even if 0 i s outside the range of the data. At most one of center and boundary may be specified.\n\nboundary: float = None\n\nA boundary between two bins. As with center, things are shifted when boundary is outside the range of the data. For example, to center on integers, use width=1 and boundary=0.5, even if 1 is outside the range of the data. At most one of center and boundary may be specified.\n\nclosed: left | right = “right”\n\nWhich edge of the bins is included.\n\npad: bool = False\n\nIf True, adds empty bins at either side of x. This ensures that frequency polygons touch 0."
  },
  {
    "objectID": "reference/stat_bindot.html",
    "href": "reference/stat_bindot.html",
    "title": "stat_bindot",
    "section": "",
    "text": "stats.stat_bindot()\n\n\nBinning for a dot plot\nUsage\nstat_bindot(mapping=None, data=None, geom='dotplot', position='identity',\n            na_rm=False, origin=None, breaks=None, method='dotdensity',\n            bins=None, binwidth=None, binaxis='x', binpositions='bygroup',\n            drop=False, width=0.9, right=True, **kwargs)\nOnly the mapping and data can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the geom.\n\n\n\n\nmapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\nafter_stat('count')\n\n\n\n\nThe bold aesthetics are required.\nOptions for computed aesthetics\n\"count\"    # number of points in bin\n\"density\"  # density of points in bin, scaled to integrate to 1\n\"ncount\"   # count, scaled to maximum of 1\n\"ndensity\" # density, scaled to maximum of 1\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom: str | geom = “dotplot”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\nbins: int = None\n\nNumber of bins. Overridden by binwidth. If None, a number is computed using the freedman-diaconis method.\n\nbinwidth: float = None\n\nWhen method='dotdensity', this specifies the maximum binwidth. When method='histodot', this specifies the binwidth. This supercedes the bins.\n\norigin: float = None\n\nWhen method='histodot', origin of the first bin.\n\nwidth: float = 0.9\n\nWhen binaxis='y', the spacing of the dotstacks for dodging.\n\nbinaxis: ‘x’ | ‘y’ = “x”\n\nAxis to bin along.\n\nmethod: ‘dotdensity’ | ‘histodot’ = “dotdensity”\n\nWhether to do dot-density binning or fixed widths binning.\n\nbinpositions: ‘all’ | ‘bygroup’ = “bygroup”\n\nPosition of the bins when method=\"dotdensity\". The value - bygroup - positions of the bins for each group are determined separately. - all - positions of the bins are determined with all data taken together. This aligns the dots stacks across multiple groups.\n\ndrop: bool = False\n\nIf True, remove all bins with zero counts.\n\nright: bool = True\n\nWhen method='histodot', :py:True means include right edge of the bins and if False the left edge is included.\n\nbreaks: array - like = None\n\nBin boundaries for method='histodot'. This supercedes the binwidth and bins.\n\n\n\n\n\n\nplotnine.stats.stat_bin"
  },
  {
    "objectID": "reference/stat_bindot.html#parameters",
    "href": "reference/stat_bindot.html#parameters",
    "title": "stat_bindot",
    "section": "",
    "text": "mapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\nafter_stat('count')\n\n\n\n\nThe bold aesthetics are required.\nOptions for computed aesthetics\n\"count\"    # number of points in bin\n\"density\"  # density of points in bin, scaled to integrate to 1\n\"ncount\"   # count, scaled to maximum of 1\n\"ndensity\" # density, scaled to maximum of 1\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom: str | geom = “dotplot”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\nbins: int = None\n\nNumber of bins. Overridden by binwidth. If None, a number is computed using the freedman-diaconis method.\n\nbinwidth: float = None\n\nWhen method='dotdensity', this specifies the maximum binwidth. When method='histodot', this specifies the binwidth. This supercedes the bins.\n\norigin: float = None\n\nWhen method='histodot', origin of the first bin.\n\nwidth: float = 0.9\n\nWhen binaxis='y', the spacing of the dotstacks for dodging.\n\nbinaxis: ‘x’ | ‘y’ = “x”\n\nAxis to bin along.\n\nmethod: ‘dotdensity’ | ‘histodot’ = “dotdensity”\n\nWhether to do dot-density binning or fixed widths binning.\n\nbinpositions: ‘all’ | ‘bygroup’ = “bygroup”\n\nPosition of the bins when method=\"dotdensity\". The value - bygroup - positions of the bins for each group are determined separately. - all - positions of the bins are determined with all data taken together. This aligns the dots stacks across multiple groups.\n\ndrop: bool = False\n\nIf True, remove all bins with zero counts.\n\nright: bool = True\n\nWhen method='histodot', :py:True means include right edge of the bins and if False the left edge is included.\n\nbreaks: array - like = None\n\nBin boundaries for method='histodot'. This supercedes the binwidth and bins."
  },
  {
    "objectID": "reference/stat_bindot.html#see-also",
    "href": "reference/stat_bindot.html#see-also",
    "title": "stat_bindot",
    "section": "",
    "text": "plotnine.stats.stat_bin"
  },
  {
    "objectID": "reference/stat_count.html",
    "href": "reference/stat_count.html",
    "title": "stat_count",
    "section": "",
    "text": "stats.stat_count()\n\n\nCounts the number of cases at each x position\nUsage\nstat_count(mapping=None, data=None, geom='histogram', position='stack',\n           na_rm=False, width=None, **kwargs)\nOnly the mapping and data can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the geom.\n\n\n\n\nmapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\nafter_stat('count')\n\n\n\n\nThe bold aesthetics are required.\nOptions for computed aesthetics\n\"count\"  # Number of observations at a position\n\"prop\"   # Ratio of points in the panel at a position\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom: str | geom = “histogram”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “stack”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\nwidth: float = None\n\nBar width. If None, set to 90% of the resolution of the data.\n\n\n\n\n\n\nplotnine.stats.stat_bin"
  },
  {
    "objectID": "reference/stat_count.html#parameters",
    "href": "reference/stat_count.html#parameters",
    "title": "stat_count",
    "section": "",
    "text": "mapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\nafter_stat('count')\n\n\n\n\nThe bold aesthetics are required.\nOptions for computed aesthetics\n\"count\"  # Number of observations at a position\n\"prop\"   # Ratio of points in the panel at a position\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom: str | geom = “histogram”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “stack”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\nwidth: float = None\n\nBar width. If None, set to 90% of the resolution of the data."
  },
  {
    "objectID": "reference/stat_count.html#see-also",
    "href": "reference/stat_count.html#see-also",
    "title": "stat_count",
    "section": "",
    "text": "plotnine.stats.stat_bin"
  },
  {
    "objectID": "reference/stat_density_2d.html",
    "href": "reference/stat_density_2d.html",
    "title": "stat_density_2d",
    "section": "",
    "text": "stats.stat_density_2d()\n\n\nCompute 2D kernel density estimation\nUsage\nstat_density_2d(mapping=None, data=None, geom='density_2d',\n                position='identity', na_rm=False, kde_params=None, n=64,\n                levels=5, package='statsmodels', contour=True, **kwargs)\nOnly the mapping and data can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the geom.\n\n\n\n\nmapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\nThe bold aesthetics are required.\nOptions for computed aesthetics\n\"level\"     # density level of a contour\n\"density\"   # Computed density at a point\n\"piece\"     # Numeric id of a contour in a given group\nlevel is only relevant when contours are computed. density is available only when no contours are computed. piece is largely irrelevant.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom: str | geom = “density_2d”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ncontour: bool = True\n\nWhether to create contours of the 2d density estimate.\n\nn: int = 64\n\nNumber of equally spaced points at which the density is to be estimated. For efficient computation, it should be a power of two.\n\nlevels: int | array_like = 5\n\nContour levels. If an integer, it specifies the maximum number of levels, if array_like it is the levels themselves.\n\npackage: statsmodels | scipy | sklearn = “statsmodels”\n\nPackage whose kernel density estimation to use.\n\nkde_params: dict\n\nKeyword arguments to pass on to the kde class.\n\n\n\n\n\n\nstatsmodels.nonparametric.kde.KDEMultivariate\n\n\n\nscipy.stats.gaussian_kde\n\n\n\nsklearn.neighbors.KernelDensity"
  },
  {
    "objectID": "reference/stat_density_2d.html#parameters",
    "href": "reference/stat_density_2d.html#parameters",
    "title": "stat_density_2d",
    "section": "",
    "text": "mapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\nThe bold aesthetics are required.\nOptions for computed aesthetics\n\"level\"     # density level of a contour\n\"density\"   # Computed density at a point\n\"piece\"     # Numeric id of a contour in a given group\nlevel is only relevant when contours are computed. density is available only when no contours are computed. piece is largely irrelevant.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom: str | geom = “density_2d”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ncontour: bool = True\n\nWhether to create contours of the 2d density estimate.\n\nn: int = 64\n\nNumber of equally spaced points at which the density is to be estimated. For efficient computation, it should be a power of two.\n\nlevels: int | array_like = 5\n\nContour levels. If an integer, it specifies the maximum number of levels, if array_like it is the levels themselves.\n\npackage: statsmodels | scipy | sklearn = “statsmodels”\n\nPackage whose kernel density estimation to use.\n\nkde_params: dict\n\nKeyword arguments to pass on to the kde class."
  },
  {
    "objectID": "reference/stat_density_2d.html#see-also",
    "href": "reference/stat_density_2d.html#see-also",
    "title": "stat_density_2d",
    "section": "",
    "text": "statsmodels.nonparametric.kde.KDEMultivariate\n\n\n\nscipy.stats.gaussian_kde\n\n\n\nsklearn.neighbors.KernelDensity"
  },
  {
    "objectID": "reference/stat_ellipse.html",
    "href": "reference/stat_ellipse.html",
    "title": "stat_ellipse",
    "section": "",
    "text": "stats.stat_ellipse()\n\n\nCalculate normal confidence interval ellipse\nUsage\nstat_ellipse(mapping=None, data=None, geom='path', position='identity',\n             na_rm=False, level=0.95, segments=51, type='t', **kwargs)\nOnly the mapping and data can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the geom.\n\n\n\n\nmapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom: str | geom = “path”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ntype: ‘t’ | ‘norm’ | ‘euclid’ = “t”\n\nThe type of ellipse. t assumes a multivariate t-distribution. norm assumes a multivariate normal distribution. euclid draws a circle with the radius equal to level, representing the euclidean distance from the center.\n\nlevel: float = 0.95\n\nThe confidence level at which to draw the ellipse.\n\nsegments: int = 51\n\nNumber of segments to be used in drawing the ellipse."
  },
  {
    "objectID": "reference/stat_ellipse.html#parameters",
    "href": "reference/stat_ellipse.html#parameters",
    "title": "stat_ellipse",
    "section": "",
    "text": "mapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom: str | geom = “path”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ntype: ‘t’ | ‘norm’ | ‘euclid’ = “t”\n\nThe type of ellipse. t assumes a multivariate t-distribution. norm assumes a multivariate normal distribution. euclid draws a circle with the radius equal to level, representing the euclidean distance from the center.\n\nlevel: float = 0.95\n\nThe confidence level at which to draw the ellipse.\n\nsegments: int = 51\n\nNumber of segments to be used in drawing the ellipse."
  },
  {
    "objectID": "reference/stat_hull.html",
    "href": "reference/stat_hull.html",
    "title": "stat_hull",
    "section": "",
    "text": "stats.stat_hull()\n\n\n2 Dimensional Convex Hull\nUsage\nstat_hull(mapping=None, data=None, geom='path', position='identity',\n          na_rm=False, qhull_options=None, **kwargs)\nOnly the mapping and data can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the geom.\n\n\n\n\nmapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nThe bold aesthetics are required.\nOptions for computed aesthetics\n\"area\"  # Area of the convex hull\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom: str | geom = “path”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\nqhull_options\n\nAdditional options to pass to Qhull. See Qhull &lt;http://www.qhull.org/&gt;__ documentation for details.\n\n\n\n\n\n\nQhullError\n\nRaised when Qhull encounters an error condition, such as geometrical degeneracy when options to resolve are not enabled."
  },
  {
    "objectID": "reference/stat_hull.html#parameters",
    "href": "reference/stat_hull.html#parameters",
    "title": "stat_hull",
    "section": "",
    "text": "mapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nThe bold aesthetics are required.\nOptions for computed aesthetics\n\"area\"  # Area of the convex hull\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom: str | geom = “path”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\nqhull_options\n\nAdditional options to pass to Qhull. See Qhull &lt;http://www.qhull.org/&gt;__ documentation for details."
  },
  {
    "objectID": "reference/stat_hull.html#raises",
    "href": "reference/stat_hull.html#raises",
    "title": "stat_hull",
    "section": "",
    "text": "QhullError\n\nRaised when Qhull encounters an error condition, such as geometrical degeneracy when options to resolve are not enabled."
  },
  {
    "objectID": "reference/stat_qq.html",
    "href": "reference/stat_qq.html",
    "title": "stat_qq",
    "section": "",
    "text": "stats.stat_qq()\n\n\nCalculation for quantile-quantile plot\nUsage\nstat_qq(mapping=None, data=None, geom='qq', position='identity', na_rm=False,\n        alpha_beta=(0.375, 0.375), distribution='norm', dparams={},\n        quantiles=None, **kwargs)\nOnly the mapping and data can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the geom.\n\n\n\n\nmapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nsample\n\n\n\n\n\n\nx\n\n\nafter_stat('theoretical')\n\n\n\n\ny\n\n\nafter_stat('sample')\n\n\n\n\nThe bold aesthetics are required.\nOptions for computed aesthetics\n'theoretical'  # theoretical quantiles\n'sample'       # sample quantiles\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom: str | geom = “qq”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ndistribution: str = “norm”\n\nDistribution or distribution function name. The default is norm for a normal probability plot. Objects that look enough like a stats.distributions instance (i.e. they have a ppf method) are also accepted. See :mod:scipy stats &lt;scipy.stats&gt; for available distributions.\n\ndparams: dict = None\n\nDistribution-specific shape parameters (shape parameters plus location and scale).\n\nquantiles: array_like = None\n\nProbability points at which to calculate the theoretical quantile values. If provided, must be the same number as as the sample data points. The default is to use calculated theoretical points, use to alpha_beta control how these points are generated.\n\nalpha_beta: tuple = (3/8, 3/8)\n\nParameter values to use when calculating the quantiles.\n\n\n\n\n\n\nscipy.stats.mstats.plotting_positions\n\nUses alpha_beta to calculate the quantiles."
  },
  {
    "objectID": "reference/stat_qq.html#parameters",
    "href": "reference/stat_qq.html#parameters",
    "title": "stat_qq",
    "section": "",
    "text": "mapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nsample\n\n\n\n\n\n\nx\n\n\nafter_stat('theoretical')\n\n\n\n\ny\n\n\nafter_stat('sample')\n\n\n\n\nThe bold aesthetics are required.\nOptions for computed aesthetics\n'theoretical'  # theoretical quantiles\n'sample'       # sample quantiles\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom: str | geom = “qq”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ndistribution: str = “norm”\n\nDistribution or distribution function name. The default is norm for a normal probability plot. Objects that look enough like a stats.distributions instance (i.e. they have a ppf method) are also accepted. See :mod:scipy stats &lt;scipy.stats&gt; for available distributions.\n\ndparams: dict = None\n\nDistribution-specific shape parameters (shape parameters plus location and scale).\n\nquantiles: array_like = None\n\nProbability points at which to calculate the theoretical quantile values. If provided, must be the same number as as the sample data points. The default is to use calculated theoretical points, use to alpha_beta control how these points are generated.\n\nalpha_beta: tuple = (3/8, 3/8)\n\nParameter values to use when calculating the quantiles."
  },
  {
    "objectID": "reference/stat_qq.html#see-also",
    "href": "reference/stat_qq.html#see-also",
    "title": "stat_qq",
    "section": "",
    "text": "scipy.stats.mstats.plotting_positions\n\nUses alpha_beta to calculate the quantiles."
  },
  {
    "objectID": "reference/stat_quantile.html",
    "href": "reference/stat_quantile.html",
    "title": "stat_quantile",
    "section": "",
    "text": "stats.stat_quantile()\n\n\nCompute quantile regression lines\nUsage\nstat_quantile(mapping=None, data=None, geom='quantile', position='identity',\n              na_rm=False, formula='y ~ x', method_args={}, quantiles=(0.25,\n              0.5, 0.75), **kwargs)\nOnly the mapping and data can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the geom.\n\n\n\n\nmapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nThe bold aesthetics are required.\nOptions for computed aesthetics\n\"quantile\"  # quantile\n\"group\"     # group identifier\nCalculated aesthetics are accessed using the after_stat function. e.g. after_stat('quantile').\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom: str | geom = “quantile”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\nquantiles: tuple = (0.25, 0.5, 0.75)\n\nQuantiles of y to compute\n\nformula: str = “y ~ x”\n\nFormula relating y variables to x variables\n\nmethod_args: dict = None\n\nExtra arguments passed on to the model fitting method, :meth:statsmodels.regression.quantile_regression.QuantReg.fit.\n\n\n\n\n\n\nstatsmodels.regression.quantile_regression.QuantReg\n\n\n\nplotnine.geoms.geom_quantile"
  },
  {
    "objectID": "reference/stat_quantile.html#parameters",
    "href": "reference/stat_quantile.html#parameters",
    "title": "stat_quantile",
    "section": "",
    "text": "mapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nThe bold aesthetics are required.\nOptions for computed aesthetics\n\"quantile\"  # quantile\n\"group\"     # group identifier\nCalculated aesthetics are accessed using the after_stat function. e.g. after_stat('quantile').\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom: str | geom = “quantile”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\nquantiles: tuple = (0.25, 0.5, 0.75)\n\nQuantiles of y to compute\n\nformula: str = “y ~ x”\n\nFormula relating y variables to x variables\n\nmethod_args: dict = None\n\nExtra arguments passed on to the model fitting method, :meth:statsmodels.regression.quantile_regression.QuantReg.fit."
  },
  {
    "objectID": "reference/stat_quantile.html#see-also",
    "href": "reference/stat_quantile.html#see-also",
    "title": "stat_quantile",
    "section": "",
    "text": "statsmodels.regression.quantile_regression.QuantReg\n\n\n\nplotnine.geoms.geom_quantile"
  },
  {
    "objectID": "reference/stat_smooth.html",
    "href": "reference/stat_smooth.html",
    "title": "stat_smooth",
    "section": "",
    "text": "stats.stat_smooth()\n\n\nCalculate a smoothed conditional mean\nUsage\nstat_smooth(mapping=None, data=None, geom='smooth', position='identity',\n            na_rm=False, method='auto', n=80, level=0.95, span=0.75,\n            method_args={}, se=True, formula=None, fullrange=False, **kwargs)\nOnly the mapping and data can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the geom.\n\n\n\n\nmapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nThe bold aesthetics are required.\nOptions for computed aesthetics\n\"se\"    # Standard error of points in bin\n\"ymin\"  # Lower confidence limit\n\"ymax\"  # Upper confidence limit\nCalculated aesthetics are accessed using the after_stat function. e.g. after_stat('se').\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom: str | geom = “smooth”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\nmethod: str | callable = “auto”\n\nThe available methods are:\n\"auto\"       # Use loess if (n&lt;1000), glm otherwise\n\"lm\", \"ols\"  # Linear Model\n\"wls\"        # Weighted Linear Model\n\"rlm\"        # Robust Linear Model\n\"glm\"        # Generalized linear Model\n\"gls\"        # Generalized Least Squares\n\"lowess\"     # Locally Weighted Regression (simple)\n\"loess\"      # Locally Weighted Regression\n\"mavg\"       # Moving Average\n\"gpr\"        # Gaussian Process Regressor\nIf a callable is passed, it must have the signature:\ndef my_smoother(data, xseq, **params):\n    # * data - has the x and y values for the model\n    # * xseq - x values to be predicted\n    # * params - stat parameters\n    #\n    # It must return a new dataframe. Below is the\n    # template used internally by Plotnine\n\n    # Input data into the model\n    x, y = data[\"x\"], data[\"y\"]\n\n    # Create and fit a model\n    model = Model(x, y)\n    results = Model.fit()\n\n    # Create output data by getting predictions on\n    # the xseq values\n    data = pd.DataFrame({\n        \"x\": xseq,\n        \"y\": results.predict(xseq)})\n\n    # Compute confidence intervals, this depends on\n    # the model. However, given standard errors and the\n    # degrees of freedom we can compute the confidence\n    # intervals using the t-distribution.\n    #\n    # For an alternative, implement confidence interals by\n    # the bootstrap method\n    if params[\"se\"]:\n        from plotnine.utils.smoothers import tdist_ci\n        y = data[\"y\"]            # The predicted value\n        df = 123                 # Degrees of freedom\n        stderr = results.stderr  # Standard error\n        level = params[\"level\"]  # The parameter value\n        low, high = tdist_ci(y, df, stderr, level)\n        data[\"se\"] = stderr\n        data[\"ymin\"] = low\n        data[\"ymax\"] = high\n\n    return data\nFor loess smoothing you must install the scikit-misc package. You can install it using with pip install scikit-misc or pip install plotnine[all].\n\nformula: formula_like = None\n\nAn object that can be used to construct a patsy design matrix. This is usually a string. You can only use a formula if method is one of lm, ols, wls, glm, rlm or gls, and in the :ref:formula &lt;patsy:formulas&gt; you may refer to the x and y aesthetic variables.\n\nse: bool = True\n\nIf True draw confidence interval around the smooth line.\n\nn: int = 80\n\nNumber of points to evaluate the smoother at. Some smoothers like mavg do not support this.\n\nfullrange: bool = False\n\nIf True the fit will span the full range of the plot.\n\nlevel: float = 0.95\n\nLevel of confidence to use if se=True.\n\nspan: float = 2/3.\n\nControls the amount of smoothing for the loess smoother. Larger number means more smoothing. It should be in the (0, 1) range.\n\nmethod_args: dict = {}\n\nAdditional arguments passed on to the modelling method.\n\n\n\n\n\n\nstatsmodels.regression.linear_model.OLS\n\n\n\nstatsmodels.regression.linear_model.WLS\n\n\n\nstatsmodels.robust.robust_linear_model.RLM\n\n\n\nstatsmodels.genmod.generalized_linear_model.GLM\n\n\n\nstatsmodels.regression.linear_model.GLS\n\n\n\nstatsmodels.nonparametric.smoothers_lowess.lowess\n\n\n\nskmisc.loess.loess\n\n\n\npandas.DataFrame.rolling\n\n\n\nsklearn.gaussian_process.GaussianProcessRegressor\n\n\n\n\n\n\n\ngeom_smooth and stat_smooth are effectively aliases, they both use the same arguments. Use geom_smooth unless you want to display the results with a non-standard geom."
  },
  {
    "objectID": "reference/stat_smooth.html#parameters",
    "href": "reference/stat_smooth.html#parameters",
    "title": "stat_smooth",
    "section": "",
    "text": "mapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nThe bold aesthetics are required.\nOptions for computed aesthetics\n\"se\"    # Standard error of points in bin\n\"ymin\"  # Lower confidence limit\n\"ymax\"  # Upper confidence limit\nCalculated aesthetics are accessed using the after_stat function. e.g. after_stat('se').\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom: str | geom = “smooth”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\nmethod: str | callable = “auto”\n\nThe available methods are:\n\"auto\"       # Use loess if (n&lt;1000), glm otherwise\n\"lm\", \"ols\"  # Linear Model\n\"wls\"        # Weighted Linear Model\n\"rlm\"        # Robust Linear Model\n\"glm\"        # Generalized linear Model\n\"gls\"        # Generalized Least Squares\n\"lowess\"     # Locally Weighted Regression (simple)\n\"loess\"      # Locally Weighted Regression\n\"mavg\"       # Moving Average\n\"gpr\"        # Gaussian Process Regressor\nIf a callable is passed, it must have the signature:\ndef my_smoother(data, xseq, **params):\n    # * data - has the x and y values for the model\n    # * xseq - x values to be predicted\n    # * params - stat parameters\n    #\n    # It must return a new dataframe. Below is the\n    # template used internally by Plotnine\n\n    # Input data into the model\n    x, y = data[\"x\"], data[\"y\"]\n\n    # Create and fit a model\n    model = Model(x, y)\n    results = Model.fit()\n\n    # Create output data by getting predictions on\n    # the xseq values\n    data = pd.DataFrame({\n        \"x\": xseq,\n        \"y\": results.predict(xseq)})\n\n    # Compute confidence intervals, this depends on\n    # the model. However, given standard errors and the\n    # degrees of freedom we can compute the confidence\n    # intervals using the t-distribution.\n    #\n    # For an alternative, implement confidence interals by\n    # the bootstrap method\n    if params[\"se\"]:\n        from plotnine.utils.smoothers import tdist_ci\n        y = data[\"y\"]            # The predicted value\n        df = 123                 # Degrees of freedom\n        stderr = results.stderr  # Standard error\n        level = params[\"level\"]  # The parameter value\n        low, high = tdist_ci(y, df, stderr, level)\n        data[\"se\"] = stderr\n        data[\"ymin\"] = low\n        data[\"ymax\"] = high\n\n    return data\nFor loess smoothing you must install the scikit-misc package. You can install it using with pip install scikit-misc or pip install plotnine[all].\n\nformula: formula_like = None\n\nAn object that can be used to construct a patsy design matrix. This is usually a string. You can only use a formula if method is one of lm, ols, wls, glm, rlm or gls, and in the :ref:formula &lt;patsy:formulas&gt; you may refer to the x and y aesthetic variables.\n\nse: bool = True\n\nIf True draw confidence interval around the smooth line.\n\nn: int = 80\n\nNumber of points to evaluate the smoother at. Some smoothers like mavg do not support this.\n\nfullrange: bool = False\n\nIf True the fit will span the full range of the plot.\n\nlevel: float = 0.95\n\nLevel of confidence to use if se=True.\n\nspan: float = 2/3.\n\nControls the amount of smoothing for the loess smoother. Larger number means more smoothing. It should be in the (0, 1) range.\n\nmethod_args: dict = {}\n\nAdditional arguments passed on to the modelling method."
  },
  {
    "objectID": "reference/stat_smooth.html#see-also",
    "href": "reference/stat_smooth.html#see-also",
    "title": "stat_smooth",
    "section": "",
    "text": "statsmodels.regression.linear_model.OLS\n\n\n\nstatsmodels.regression.linear_model.WLS\n\n\n\nstatsmodels.robust.robust_linear_model.RLM\n\n\n\nstatsmodels.genmod.generalized_linear_model.GLM\n\n\n\nstatsmodels.regression.linear_model.GLS\n\n\n\nstatsmodels.nonparametric.smoothers_lowess.lowess\n\n\n\nskmisc.loess.loess\n\n\n\npandas.DataFrame.rolling\n\n\n\nsklearn.gaussian_process.GaussianProcessRegressor"
  },
  {
    "objectID": "reference/stat_smooth.html#notes",
    "href": "reference/stat_smooth.html#notes",
    "title": "stat_smooth",
    "section": "",
    "text": "geom_smooth and stat_smooth are effectively aliases, they both use the same arguments. Use geom_smooth unless you want to display the results with a non-standard geom."
  },
  {
    "objectID": "reference/stat_summary.html",
    "href": "reference/stat_summary.html",
    "title": "stat_summary",
    "section": "",
    "text": "stats.stat_summary()\n\n\nCalculate summary statistics depending on x\nUsage\nstat_summary(mapping=None, data=None, geom='pointrange', position='identity',\n             na_rm=False, fun_args=None, fun_y=None, fun_ymin=None,\n             fun_ymax=None, fun_data='mean_cl_boot', random_state=None,\n             **kwargs)\nOnly the mapping and data can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the geom.\n\n\n\n\nmapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nThe bold aesthetics are required.\nOptions for computed aesthetics\n\"ymin\"  # ymin computed by the summary function\n\"ymax\"  # ymax computed by the summary function\nCalculated aesthetics are accessed using the after_stat function. e.g. after_stat('ymin').\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom: str | geom = “pointrange”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\nfun_data: str | callable = “mean_cl_boot”\n\nIf string, it should be one of:\n# Bootstrapped mean, confidence interval\n# Arguments:\n#     n_samples - No. of samples to draw\n#     confidence_interval\n#     random_state\n\"mean_cl_boot\"\n\n# Mean, C.I. assuming normal distribution\n# Arguments:\n#     confidence_interval\n\"mean_cl_normal\"\n\n# Mean, standard deviation * constant\n# Arguments:\n#     mult - multiplication factor\n\"mean_sdl\"\n\n# Median, outlier quantiles with equal tail areas\n# Arguments:\n#     confidence_interval\n\"median_hilow\"\n\n# Mean, Standard Errors * constant\n# Arguments:\n#     mult - multiplication factor\n\"mean_se\"\nor any function that takes a array and returns a dataframe with three columns named y, ymin and ymax.\n\nfun_y: callable = None\n\nAny function that takes a array-like and returns a value\n\nfun_ymin: callable = None\n\nAny function that takes an array-like and returns a value\n\nfun_ymax: callable = None\n\nAny function that takes an array-like and returns a value\n\nfun_args: dict = None\n\nArguments to any of the functions. Provided the names of the arguments of the different functions are in not conflict, the arguments will be assigned to the right functions. If there is a conflict, create a wrapper function that resolves the ambiguity in the argument names.\n\nrandom_state: int | ~numpy.random.RandomState = None\n\nSeed or Random number generator to use. If None, then numpy global generator :class:numpy.random is used.\n\n\n\n\n\nIf any of fun_y, fun_ymin or fun_ymax are provided, the value of fun_data will be ignored.\n\n\n\n\nplotnine.geoms.geom_pointrange"
  },
  {
    "objectID": "reference/stat_summary.html#parameters",
    "href": "reference/stat_summary.html#parameters",
    "title": "stat_summary",
    "section": "",
    "text": "mapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\nAesthetic\n\n\nDefault value\n\n\n\n\n\n\nx\n\n\n\n\n\n\ny\n\n\n\n\n\n\nThe bold aesthetics are required.\nOptions for computed aesthetics\n\"ymin\"  # ymin computed by the summary function\n\"ymax\"  # ymax computed by the summary function\nCalculated aesthetics are accessed using the after_stat function. e.g. after_stat('ymin').\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom: str | geom = “pointrange”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\nfun_data: str | callable = “mean_cl_boot”\n\nIf string, it should be one of:\n# Bootstrapped mean, confidence interval\n# Arguments:\n#     n_samples - No. of samples to draw\n#     confidence_interval\n#     random_state\n\"mean_cl_boot\"\n\n# Mean, C.I. assuming normal distribution\n# Arguments:\n#     confidence_interval\n\"mean_cl_normal\"\n\n# Mean, standard deviation * constant\n# Arguments:\n#     mult - multiplication factor\n\"mean_sdl\"\n\n# Median, outlier quantiles with equal tail areas\n# Arguments:\n#     confidence_interval\n\"median_hilow\"\n\n# Mean, Standard Errors * constant\n# Arguments:\n#     mult - multiplication factor\n\"mean_se\"\nor any function that takes a array and returns a dataframe with three columns named y, ymin and ymax.\n\nfun_y: callable = None\n\nAny function that takes a array-like and returns a value\n\nfun_ymin: callable = None\n\nAny function that takes an array-like and returns a value\n\nfun_ymax: callable = None\n\nAny function that takes an array-like and returns a value\n\nfun_args: dict = None\n\nArguments to any of the functions. Provided the names of the arguments of the different functions are in not conflict, the arguments will be assigned to the right functions. If there is a conflict, create a wrapper function that resolves the ambiguity in the argument names.\n\nrandom_state: int | ~numpy.random.RandomState = None\n\nSeed or Random number generator to use. If None, then numpy global generator :class:numpy.random is used."
  },
  {
    "objectID": "reference/stat_summary.html#notes",
    "href": "reference/stat_summary.html#notes",
    "title": "stat_summary",
    "section": "",
    "text": "If any of fun_y, fun_ymin or fun_ymax are provided, the value of fun_data will be ignored."
  },
  {
    "objectID": "reference/stat_summary.html#see-also",
    "href": "reference/stat_summary.html#see-also",
    "title": "stat_summary",
    "section": "",
    "text": "plotnine.geoms.geom_pointrange"
  },
  {
    "objectID": "reference/stat_unique.html",
    "href": "reference/stat_unique.html",
    "title": "stat_unique",
    "section": "",
    "text": "stats.stat_unique()\n\n\nRemove duplicates\nUsage\nstat_unique(mapping=None, data=None, geom='point', position='identity',\n            na_rm=False, **kwargs)\nOnly the mapping and data can be positional, the rest must be keyword arguments. **kwargs can be aesthetics (or parameters) used by the geom.\n\n\n\n\nmapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom: str | geom = “point”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values."
  },
  {
    "objectID": "reference/stat_unique.html#parameters",
    "href": "reference/stat_unique.html#parameters",
    "title": "stat_unique",
    "section": "",
    "text": "mapping: aes = None\n\nAesthetic mappings created with :class:~plotnine.mapping.aes). If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\n\nThe bold aesthetics are required.\n\ndata: dataframe = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom: str | geom = “point”\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition: str | position = “identity”\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm: bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values."
  },
  {
    "objectID": "reference/strip_align.html",
    "href": "reference/strip_align.html",
    "title": "strip_align",
    "section": "",
    "text": "themes.themeable.strip_align()\n\n\nAlignment of the strip & its background w.r.t the panel border\n\n\n\n\ntheme_element: float\n\nValue as a proportion of the strip text size. A good value should be the range [-1, 0.5]. A negative value puts the strip inside the axes and a positive value creates a space between the strip and the axes."
  },
  {
    "objectID": "reference/strip_align.html#parameters",
    "href": "reference/strip_align.html#parameters",
    "title": "strip_align",
    "section": "",
    "text": "theme_element: float\n\nValue as a proportion of the strip text size. A good value should be the range [-1, 0.5]. A negative value puts the strip inside the axes and a positive value creates a space between the strip and the axes."
  },
  {
    "objectID": "reference/strip_align_y.html",
    "href": "reference/strip_align_y.html",
    "title": "strip_align_y",
    "section": "",
    "text": "themes.themeable.strip_align_y()\n\n\nHorizontal alignment of the strip & its background w.r.t the panel border\n\n\n\n\ntheme_element: float\n\nValue as a proportion of the strip size. A good value should be the range [-1, 0.5]. A negative value puts the strip inside the axes. A positive value creates a margin between the strip and the axes. 0 puts the strip exactly beside the panels."
  },
  {
    "objectID": "reference/strip_align_y.html#parameters",
    "href": "reference/strip_align_y.html#parameters",
    "title": "strip_align_y",
    "section": "",
    "text": "theme_element: float\n\nValue as a proportion of the strip size. A good value should be the range [-1, 0.5]. A negative value puts the strip inside the axes. A positive value creates a margin between the strip and the axes. 0 puts the strip exactly beside the panels."
  },
  {
    "objectID": "reference/strip_background_x.html",
    "href": "reference/strip_background_x.html",
    "title": "strip_background_x",
    "section": "",
    "text": "themes.themeable.strip_background_x()\n\n\nHorizontal facet label background\n\n\n\n\ntheme_element: element_rect"
  },
  {
    "objectID": "reference/strip_background_x.html#parameters",
    "href": "reference/strip_background_x.html#parameters",
    "title": "strip_background_x",
    "section": "",
    "text": "theme_element: element_rect"
  },
  {
    "objectID": "reference/strip_text.html",
    "href": "reference/strip_text.html",
    "title": "strip_text",
    "section": "",
    "text": "themes.themeable.strip_text()\n\n\nFacet labels along both axes\n\n\n\n\ntheme_element: element_text"
  },
  {
    "objectID": "reference/strip_text.html#parameters",
    "href": "reference/strip_text.html#parameters",
    "title": "strip_text",
    "section": "",
    "text": "theme_element: element_text"
  },
  {
    "objectID": "reference/strip_text_y.html",
    "href": "reference/strip_text_y.html",
    "title": "strip_text_y",
    "section": "",
    "text": "themes.themeable.strip_text_y()\n\n\nFacet labels along the vertical axis\n\n\n\n\ntheme_element: element_text"
  },
  {
    "objectID": "reference/strip_text_y.html#parameters",
    "href": "reference/strip_text_y.html#parameters",
    "title": "strip_text_y",
    "section": "",
    "text": "theme_element: element_text"
  },
  {
    "objectID": "reference/theme.html",
    "href": "reference/theme.html",
    "title": "theme",
    "section": "",
    "text": "themes.theme(self, complete=False, axis_title_x=None, axis_title_y=None, axis_title=None, legend_title=None, legend_text_legend=None, legend_text_colorbar=None, legend_text=None, plot_title=None, plot_subtitle=None, plot_caption=None, strip_text_x=None, strip_text_y=None, strip_text=None, title=None, axis_text_x=None, axis_text_y=None, axis_text=None, text=None, axis_line_x=None, axis_line_y=None, axis_line=None, axis_ticks_minor_x=None, axis_ticks_minor_y=None, axis_ticks_major_x=None, axis_ticks_major_y=None, axis_ticks_major=None, axis_ticks_minor=None, axis_ticks_x=None, axis_ticks_y=None, axis_ticks=None, panel_grid_major_x=None, panel_grid_major_y=None, panel_grid_minor_x=None, panel_grid_minor_y=None, panel_grid_major=None, panel_grid_minor=None, panel_grid=None, line=None, legend_key=None, legend_background=None, legend_box_background=None, panel_background=None, panel_border=None, plot_background=None, strip_background_x=None, strip_background_y=None, strip_background=None, rect=None, axis_ticks_length_major_x=None, axis_ticks_length_major_y=None, axis_ticks_length_major=None, axis_ticks_length_minor_x=None, axis_ticks_length_minor_y=None, axis_ticks_length_minor=None, axis_ticks_length=None, axis_ticks_pad_major_x=None, axis_ticks_pad_major_y=None, axis_ticks_pad_major=None, axis_ticks_pad_minor_x=None, axis_ticks_pad_minor_y=None, axis_ticks_pad_minor=None, axis_ticks_pad=None, axis_ticks_direction_x=None, axis_ticks_direction_y=None, axis_ticks_direction=None, panel_spacing_x=None, panel_spacing_y=None, panel_spacing=None, plot_margin_left=None, plot_margin_right=None, plot_margin_top=None, plot_margin_bottom=None, plot_margin=None, panel_ontop=None, aspect_ratio=None, dpi=None, figure_size=None, legend_box=None, legend_box_margin=None, legend_box_just=None, legend_direction=None, legend_key_width=None, legend_key_height=None, legend_key_size=None, legend_margin=None, legend_box_spacing=None, legend_spacing=None, legend_position=None, legend_title_align=None, legend_entry_spacing_x=None, legend_entry_spacing_y=None, legend_entry_spacing=None, strip_align_x=None, strip_align_y=None, strip_align=None, subplots_adjust=None, **kwargs)\n\n\nBase class for themes\nIn general, only complete themes should subclass this class.\n\n\n\n\ncomplete: bool = False\n\nThemes that are complete will override any existing themes. themes that are not complete (ie. partial) will add to or override specific elements of the current theme. e.g:\ntheme_gray() + theme_xkcd()\nwill be completely determined by theme_xkcd, but:\ntheme_gray() + theme(axis_text_x=element_text(angle=45))\nwill only modify the x-axis text.\n\nkwargs={}\n\nkwargs are :ref:themeables &lt;themeables&gt;. The themeables are elements that are subclasses of themeable. Many themeables are defined using theme elements i.e\n\nelement_line\nelement_rect\nelement_text\n\nThese simply bind together all the aspects of a themeable that can be themed. See themeable.\n\n\n\n\n\nWhen subclassing, make sure to call :python:theme.__init__. After which you can customise :python:self._rcParams within the __init__ method of the new theme. The rcParams should not be modified after that."
  },
  {
    "objectID": "reference/theme.html#parameters",
    "href": "reference/theme.html#parameters",
    "title": "theme",
    "section": "",
    "text": "complete: bool = False\n\nThemes that are complete will override any existing themes. themes that are not complete (ie. partial) will add to or override specific elements of the current theme. e.g:\ntheme_gray() + theme_xkcd()\nwill be completely determined by theme_xkcd, but:\ntheme_gray() + theme(axis_text_x=element_text(angle=45))\nwill only modify the x-axis text.\n\nkwargs={}\n\nkwargs are :ref:themeables &lt;themeables&gt;. The themeables are elements that are subclasses of themeable. Many themeables are defined using theme elements i.e\n\nelement_line\nelement_rect\nelement_text\n\nThese simply bind together all the aspects of a themeable that can be themed. See themeable."
  },
  {
    "objectID": "reference/theme.html#notes",
    "href": "reference/theme.html#notes",
    "title": "theme",
    "section": "",
    "text": "When subclassing, make sure to call :python:theme.__init__. After which you can customise :python:self._rcParams within the __init__ method of the new theme. The rcParams should not be modified after that."
  },
  {
    "objectID": "reference/theme_bw.html",
    "href": "reference/theme_bw.html",
    "title": "theme_bw",
    "section": "",
    "text": "themes.theme_bw(self, base_size=11, base_family=None)\n\n\nWhite background with black gridlines\n\n\n\n\nbase_size: int = 11\n\nBase font size. All text sizes are a scaled versions of the base font size.\n\nbase_family: str = None\n\nBase font family. If None, use plotnine.options.base_family."
  },
  {
    "objectID": "reference/theme_bw.html#parameters",
    "href": "reference/theme_bw.html#parameters",
    "title": "theme_bw",
    "section": "",
    "text": "base_size: int = 11\n\nBase font size. All text sizes are a scaled versions of the base font size.\n\nbase_family: str = None\n\nBase font family. If None, use plotnine.options.base_family."
  },
  {
    "objectID": "reference/theme_dark.html",
    "href": "reference/theme_dark.html",
    "title": "theme_dark",
    "section": "",
    "text": "themes.theme_dark(self, base_size=11, base_family=None)\n\n\nThe dark cousin of theme_light\nIt has similar line sizes but a dark background. Useful to make thin colored lines pop out.\n\n\n\n\nbase_size: int = 11\n\nBase font size. All text sizes are a scaled versions of the base font size.\n\nbase_family: str = None\n\nBase font family. If None, use plotnine.options.base_family."
  },
  {
    "objectID": "reference/theme_dark.html#parameters",
    "href": "reference/theme_dark.html#parameters",
    "title": "theme_dark",
    "section": "",
    "text": "base_size: int = 11\n\nBase font size. All text sizes are a scaled versions of the base font size.\n\nbase_family: str = None\n\nBase font family. If None, use plotnine.options.base_family."
  },
  {
    "objectID": "reference/theme_gray.html",
    "href": "reference/theme_gray.html",
    "title": "theme_gray",
    "section": "",
    "text": "themes.theme_gray(self, base_size=11, base_family=None)\n\n\nA gray background with white gridlines.\nThis is the default theme\n\n\n\n\nbase_size: int = 11\n\nBase font size. All text sizes are a scaled versions of the base font size.\n\nbase_family: str = None\n\nBase font family. If None, use plotnine.options.base_family."
  },
  {
    "objectID": "reference/theme_gray.html#parameters",
    "href": "reference/theme_gray.html#parameters",
    "title": "theme_gray",
    "section": "",
    "text": "base_size: int = 11\n\nBase font size. All text sizes are a scaled versions of the base font size.\n\nbase_family: str = None\n\nBase font family. If None, use plotnine.options.base_family."
  },
  {
    "objectID": "reference/theme_light.html",
    "href": "reference/theme_light.html",
    "title": "theme_light",
    "section": "",
    "text": "themes.theme_light(self, base_size=11, base_family=None)\n\n\nA theme similar to theme_linedraw\nHas light grey lines lines and axes to direct more attention towards the data.\n\n\n\n\nbase_size: int = 11\n\nBase font size. All text sizes are a scaled versions of the base font size.\n\nbase_family: str = None\n\nBase font family. If None, use plotnine.options.base_family."
  },
  {
    "objectID": "reference/theme_light.html#parameters",
    "href": "reference/theme_light.html#parameters",
    "title": "theme_light",
    "section": "",
    "text": "base_size: int = 11\n\nBase font size. All text sizes are a scaled versions of the base font size.\n\nbase_family: str = None\n\nBase font family. If None, use plotnine.options.base_family."
  },
  {
    "objectID": "reference/theme_matplotlib.html",
    "href": "reference/theme_matplotlib.html",
    "title": "theme_matplotlib",
    "section": "",
    "text": "themes.theme_matplotlib(self, rc=None, fname=None, use_defaults=True)\n\n\nThe default matplotlib look and feel.\nThe theme can be used (and has the same parameter to customize) like a :class:matplotlib.rc_context manager.\n\n\n\n\nrc: dict = None\n\nrcParams which should be applied on top of mathplotlib default.\n\nfname: str = None\n\nFilename to a matplotlibrc file\n\nuse_defaults: bool = True\n\nIf True (the default) resets the plot setting to the (current) matplotlib.rcParams values"
  },
  {
    "objectID": "reference/theme_matplotlib.html#parameters",
    "href": "reference/theme_matplotlib.html#parameters",
    "title": "theme_matplotlib",
    "section": "",
    "text": "rc: dict = None\n\nrcParams which should be applied on top of mathplotlib default.\n\nfname: str = None\n\nFilename to a matplotlibrc file\n\nuse_defaults: bool = True\n\nIf True (the default) resets the plot setting to the (current) matplotlib.rcParams values"
  },
  {
    "objectID": "reference/theme_seaborn.html",
    "href": "reference/theme_seaborn.html",
    "title": "theme_seaborn",
    "section": "",
    "text": "themes.theme_seaborn(self, style='darkgrid', context='notebook', font='sans-serif', font_scale=1)\n\n\nTheme for seaborn.\nCredit to Michael Waskom’s seaborn:\n- http://stanford.edu/~mwaskom/software/seaborn\n- https://github.com/mwaskom/seaborn\n\n\n\n\nstyle=‘darkgrid’\n\nStyle of axis background.\n\ncontext=‘notebook’\n\nIntended context for resulting figures.\n\nfont: str = ‘sans-serif’\n\nFont family, see matplotlib font manager.\n\nfont_scale: float = 1\n\nSeparate scaling factor to independently scale the size of the font elements."
  },
  {
    "objectID": "reference/theme_seaborn.html#parameters",
    "href": "reference/theme_seaborn.html#parameters",
    "title": "theme_seaborn",
    "section": "",
    "text": "style=‘darkgrid’\n\nStyle of axis background.\n\ncontext=‘notebook’\n\nIntended context for resulting figures.\n\nfont: str = ‘sans-serif’\n\nFont family, see matplotlib font manager.\n\nfont_scale: float = 1\n\nSeparate scaling factor to independently scale the size of the font elements."
  },
  {
    "objectID": "reference/theme_tufte.html",
    "href": "reference/theme_tufte.html",
    "title": "theme_tufte",
    "section": "",
    "text": "themes.theme_tufte(self, base_size=11, base_family=None, ticks=True)\n\n\nTufte Maximal Data, Minimal Ink Theme\nTheme based on Chapter 6 Data-Ink Maximization and Graphical Design of Edward Tufte The Visual Display of Quantitative Information. No border, no axis lines, no grids. This theme works best in combination with geom_rug.\nThe default font family is set to “serif” as he uses serif fonts for labels in The Visual Display of Quantitative Information. The serif font used by Tufte in his books is a variant of Bembo, while the sans serif font is Gill Sans. If these fonts are installed on your system, consider setting them explicitly via the argument base_family.\n\n\n\n\nbase_size: int = 11\n\nBase font size. All text sizes are a scaled versions of the base font size.\n\nbase_family: str = None\n\nBase font family. If None, use plotnine.options.base_family.\n\nticks=True\n\nWhether to show axis ticks.\n\n\n\n\n\nTufte, Edward R. (2001) The Visual Display of Quantitative Information, Chapter 6.\nTranslated from the R ggthemes package by hyiltiz hyiltiz@gmail.com. Released under GNU GPL v2 license or later."
  },
  {
    "objectID": "reference/theme_tufte.html#parameters",
    "href": "reference/theme_tufte.html#parameters",
    "title": "theme_tufte",
    "section": "",
    "text": "base_size: int = 11\n\nBase font size. All text sizes are a scaled versions of the base font size.\n\nbase_family: str = None\n\nBase font family. If None, use plotnine.options.base_family.\n\nticks=True\n\nWhether to show axis ticks."
  },
  {
    "objectID": "reference/theme_tufte.html#references",
    "href": "reference/theme_tufte.html#references",
    "title": "theme_tufte",
    "section": "",
    "text": "Tufte, Edward R. (2001) The Visual Display of Quantitative Information, Chapter 6.\nTranslated from the R ggthemes package by hyiltiz hyiltiz@gmail.com. Released under GNU GPL v2 license or later."
  },
  {
    "objectID": "reference/theme_void.html",
    "href": "reference/theme_void.html",
    "title": "theme_void",
    "section": "",
    "text": "themes.theme_void(self, base_size=11, base_family=None)\n\n\nA classic-looking theme, with x & y axis lines and no gridlines.\n\n\n\n\nbase_size: int = 11\n\nBase font size. All text sizes are a scaled versions of the base font size.\n\nbase_family: str = None\n\nBase font family."
  },
  {
    "objectID": "reference/theme_void.html#parameters",
    "href": "reference/theme_void.html#parameters",
    "title": "theme_void",
    "section": "",
    "text": "base_size: int = 11\n\nBase font size. All text sizes are a scaled versions of the base font size.\n\nbase_family: str = None\n\nBase font family."
  },
  {
    "objectID": "reference/themeable.html",
    "href": "reference/themeable.html",
    "title": "themeable",
    "section": "",
    "text": "themes.themeable.themeable(self, theme_element=None)\n\n\n\n\n\n\nName\nDescription\n\n\n\n\norder\nint([x]) -&gt; integer\n\n\nrcParams\nReturn themeables rcparams to an rcparam dict before plotting.\n\n\n\n\nAbstract class of things that can be themed.\nEvery subclass of themeable is stored in a dict at :python:themeable.register with the name of the subclass as the key.\nIt is the base of a class hierarchy that uses inheritance in a non-traditional manner. In the textbook use of class inheritance, superclasses are general and subclasses are specializations. In some since the hierarchy used here is the opposite in that superclasses are more specific than subclasses.\nIt is probably better to think if this hierarchy of leveraging Python’s multiple inheritance to implement composition. For example the axis_title themeable is composed of the x_axis_title and the y_axis_title. We are just using multiple inheritance to specify this composition.\nWhen implementing a new themeable based on the ggplot2 documentation, it is important to keep this in mind and reverse the order of the “inherits from” in the documentation.\nFor example, to implement,\n\naxis_title_x - x axis label (element_text; inherits from axis_title)\naxis_title_y - y axis label (element_text; inherits from axis_title)\n\nYou would have this implementation:\nclass axis_title_x(themeable):\n    ...\n\nclass axis_title_y(themeable):\n    ...\n\nclass axis_title(axis_title_x, axis_title_y):\n    ...\nIf the superclasses fully implement the subclass, the body of the subclass should be “pass”. Python(mro) will do the right thing.\nWhen a method does require implementation, call :python:super() then add the themeable’s implementation to the axes.\n\n\n\n\nA user should never create instances of class  or subclasses of it.\n\n\n\n\n\n\nName\nDescription\n\n\n\n\napply\nCalled by the theme to apply the themeable\n\n\napply_ax\nCalled after a chart has been plotted.\n\n\napply_figure\nApply theme to the figure\n\n\nblank_ax\nBlank out theme elements\n\n\nblank_figure\nBlank out elements on the figure\n\n\nfrom_class_name\nCreate a themeable by name\n\n\nis_blank\nReturn True if theme_element is made of element_blank\n\n\nmerge\nMerge properties of other into self\n\n\nsetup_figure\nApply theme to the figure\n\n\n\n\n\n\nthemes.themeable.themeable.apply(theme)\n\n\nCalled by the theme to apply the themeable\nSubclasses shouldn’t have to override this method to customize.\n\n\n\n\n\nthemes.themeable.themeable.apply_ax(ax)\n\n\nCalled after a chart has been plotted.\nSubclasses can override this method to customize the plot according to the theme.\n\n\n\n\nax: matplotlib.axes.Axes\n\n\n\nThis\n\n\n\nfollowed\n\n\n\nthemeable\n\n\n\n\n\n\n\n\n\nthemes.themeable.themeable.apply_figure(figure, targets)\n\n\nApply theme to the figure\nCompared to :meth:setup_figure, this method is called after plotting and all the elements are drawn onto the figure.\n\n\n\n\n\nthemes.themeable.themeable.blank_ax(ax)\n\n\nBlank out theme elements\n\n\n\n\n\nthemes.themeable.themeable.blank_figure(figure, targets)\n\n\nBlank out elements on the figure\n\n\n\n\n\nthemes.themeable.themeable.from_class_name(name, theme_element)\n\n\nCreate a themeable by name\n\n\n\n\nname: str\n\nClass name\n\ntheme_element: element object\n\nA of the type required by the theme For lines, text and rects it should be one of: element_line, element_rect, element_text or \n\n\n\n\n\n\nout: Themeable\n\n\n\n\n\n\n\n\n\nthemes.themeable.themeable.is_blank()\n\n\nReturn True if theme_element is made of element_blank\n\n\n\n\n\nthemes.themeable.themeable.merge(other)\n\n\nMerge properties of other into self\n\n\n\n\nValueError\n\nIf any of the properties are blank\n\n\n\n\n\n\n\nthemes.themeable.themeable.setup_figure(figure)\n\n\nApply theme to the figure\nCompared to :meth:apply_figure, this method is called before any plotting is done. This is necessary in some cases where the drawing functions need(or can make use of) this information."
  },
  {
    "objectID": "reference/themeable.html#attributes",
    "href": "reference/themeable.html#attributes",
    "title": "themeable",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\norder\nint([x]) -&gt; integer\n\n\nrcParams\nReturn themeables rcparams to an rcparam dict before plotting.\n\n\n\n\nAbstract class of things that can be themed.\nEvery subclass of themeable is stored in a dict at :python:themeable.register with the name of the subclass as the key.\nIt is the base of a class hierarchy that uses inheritance in a non-traditional manner. In the textbook use of class inheritance, superclasses are general and subclasses are specializations. In some since the hierarchy used here is the opposite in that superclasses are more specific than subclasses.\nIt is probably better to think if this hierarchy of leveraging Python’s multiple inheritance to implement composition. For example the axis_title themeable is composed of the x_axis_title and the y_axis_title. We are just using multiple inheritance to specify this composition.\nWhen implementing a new themeable based on the ggplot2 documentation, it is important to keep this in mind and reverse the order of the “inherits from” in the documentation.\nFor example, to implement,\n\naxis_title_x - x axis label (element_text; inherits from axis_title)\naxis_title_y - y axis label (element_text; inherits from axis_title)\n\nYou would have this implementation:\nclass axis_title_x(themeable):\n    ...\n\nclass axis_title_y(themeable):\n    ...\n\nclass axis_title(axis_title_x, axis_title_y):\n    ...\nIf the superclasses fully implement the subclass, the body of the subclass should be “pass”. Python(mro) will do the right thing.\nWhen a method does require implementation, call :python:super() then add the themeable’s implementation to the axes."
  },
  {
    "objectID": "reference/themeable.html#notes",
    "href": "reference/themeable.html#notes",
    "title": "themeable",
    "section": "",
    "text": "A user should never create instances of class  or subclasses of it."
  },
  {
    "objectID": "reference/themeable.html#methods",
    "href": "reference/themeable.html#methods",
    "title": "themeable",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\napply\nCalled by the theme to apply the themeable\n\n\napply_ax\nCalled after a chart has been plotted.\n\n\napply_figure\nApply theme to the figure\n\n\nblank_ax\nBlank out theme elements\n\n\nblank_figure\nBlank out elements on the figure\n\n\nfrom_class_name\nCreate a themeable by name\n\n\nis_blank\nReturn True if theme_element is made of element_blank\n\n\nmerge\nMerge properties of other into self\n\n\nsetup_figure\nApply theme to the figure\n\n\n\n\n\n\nthemes.themeable.themeable.apply(theme)\n\n\nCalled by the theme to apply the themeable\nSubclasses shouldn’t have to override this method to customize.\n\n\n\n\n\nthemes.themeable.themeable.apply_ax(ax)\n\n\nCalled after a chart has been plotted.\nSubclasses can override this method to customize the plot according to the theme.\n\n\n\n\nax: matplotlib.axes.Axes\n\n\n\nThis\n\n\n\nfollowed\n\n\n\nthemeable\n\n\n\n\n\n\n\n\n\nthemes.themeable.themeable.apply_figure(figure, targets)\n\n\nApply theme to the figure\nCompared to :meth:setup_figure, this method is called after plotting and all the elements are drawn onto the figure.\n\n\n\n\n\nthemes.themeable.themeable.blank_ax(ax)\n\n\nBlank out theme elements\n\n\n\n\n\nthemes.themeable.themeable.blank_figure(figure, targets)\n\n\nBlank out elements on the figure\n\n\n\n\n\nthemes.themeable.themeable.from_class_name(name, theme_element)\n\n\nCreate a themeable by name\n\n\n\n\nname: str\n\nClass name\n\ntheme_element: element object\n\nA of the type required by the theme For lines, text and rects it should be one of: element_line, element_rect, element_text or \n\n\n\n\n\n\nout: Themeable\n\n\n\n\n\n\n\n\n\nthemes.themeable.themeable.is_blank()\n\n\nReturn True if theme_element is made of element_blank\n\n\n\n\n\nthemes.themeable.themeable.merge(other)\n\n\nMerge properties of other into self\n\n\n\n\nValueError\n\nIf any of the properties are blank\n\n\n\n\n\n\n\nthemes.themeable.themeable.setup_figure(figure)\n\n\nApply theme to the figure\nCompared to :meth:apply_figure, this method is called before any plotting is done. This is necessary in some cases where the drawing functions need(or can make use of) this information."
  },
  {
    "objectID": "reference/txhousing.html",
    "href": "reference/txhousing.html",
    "title": "txhousing",
    "section": "",
    "text": "txhousing\ndata.txhousing\n\nHousing sales in TX.\nDescription\nInformation about the housing market in Texas provided by the TAMU real estate center, http://recenter.tamu.edu/.\nFormat\nA data frame with 8602 observations and 9 variables:\n\n\n\n\n\n\n\nColumn\nDescription\n\n\n\n\ncity\nName of MLS area\n\n\nyear\nYear\n\n\nmonth\nMonth\n\n\nsales\nNumber of sales\n\n\nvolume\nTotal value of sales\n\n\nmedian\nMedian sale price\n\n\nlistings\nTotal active listings\n\n\ninventory\n“Months inventory”: amount of time it would take to sell all current listings at current pace of sales.\n\n\ndate\nDate"
  },
  {
    "objectID": "reference/xlab.html",
    "href": "reference/xlab.html",
    "title": "xlab",
    "section": "",
    "text": "labels.xlab(self, xlab)\n\n\nCreate x-axis label\n\n\n\n\nxlab: str\n\nx-axis label"
  },
  {
    "objectID": "reference/xlab.html#parameters",
    "href": "reference/xlab.html#parameters",
    "title": "xlab",
    "section": "",
    "text": "xlab: str\n\nx-axis label"
  },
  {
    "objectID": "reference/ylab.html",
    "href": "reference/ylab.html",
    "title": "ylab",
    "section": "",
    "text": "labels.ylab(self, ylab)\n\n\nCreate y-axis label\n\n\n\n\nylab: str\n\ny-axis label"
  },
  {
    "objectID": "reference/ylab.html#parameters",
    "href": "reference/ylab.html#parameters",
    "title": "ylab",
    "section": "",
    "text": "ylab: str\n\ny-axis label"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About Plotnine",
    "section": "",
    "text": "plotnine started as an effort to improve the scaling functionality in ggpy_ formally known as “ggplot for python”. It was part of a larger goal to evolve the package into one that supported a full plotting grammar. It turned out that to have a grammar of graphics system we had to just about start anew.\nThe complete guide to what constitutes a “Grammar of Graphics” is Leland Wilkinson’s book The Grammar of Graphics. To create ggplot2_ Hadley Wickham came up with an interpretation termed A layered grammar of graphics 1. Core to the interpretation is a crucial plot building pipeline 2 in ggplot2 that we adopted 3 for plotnine.\nThe R programming language has a rich statistical ecosystem that ggplot2 taps into with ease. In plotnine we have done our best to integrate with the rest of the scientific python ecosystem. Though we feel we could do more on that integration, notwithstanding language differences, users familiar with ggplot2 should be comfortable and productive with plotnine.\n\n\n\n\nmatplotlib - Plotting backend.\npandas - Data handling.\nmizani - Scales framework.\nstatsmodels - For various statistical computations.\nscipy - For various statistical computation procedures."
  },
  {
    "objectID": "about.html#history-and-objective",
    "href": "about.html#history-and-objective",
    "title": "About Plotnine",
    "section": "",
    "text": "plotnine started as an effort to improve the scaling functionality in ggpy_ formally known as “ggplot for python”. It was part of a larger goal to evolve the package into one that supported a full plotting grammar. It turned out that to have a grammar of graphics system we had to just about start anew.\nThe complete guide to what constitutes a “Grammar of Graphics” is Leland Wilkinson’s book The Grammar of Graphics. To create ggplot2_ Hadley Wickham came up with an interpretation termed A layered grammar of graphics 1. Core to the interpretation is a crucial plot building pipeline 2 in ggplot2 that we adopted 3 for plotnine.\nThe R programming language has a rich statistical ecosystem that ggplot2 taps into with ease. In plotnine we have done our best to integrate with the rest of the scientific python ecosystem. Though we feel we could do more on that integration, notwithstanding language differences, users familiar with ggplot2 should be comfortable and productive with plotnine."
  },
  {
    "objectID": "about.html#built-with",
    "href": "about.html#built-with",
    "title": "About Plotnine",
    "section": "",
    "text": "matplotlib - Plotting backend.\npandas - Data handling.\nmizani - Scales framework.\nstatsmodels - For various statistical computations.\nscipy - For various statistical computation procedures."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "A Grammar of Graphics for Python",
    "section": "",
    "text": "plotnine\nplotnine is an implementation of a grammar of graphics in Python based on ggplot2. The grammar allows you to compose plots by explicitly mapping variables in a dataframe to the visual objects that make up the plot.\nPlotting with a grammar of graphics is powerful. Custom (and otherwise complex) plots are easy to think about and build incremently, while the simple plots remain simple to create."
  },
  {
    "objectID": "index.html#example",
    "href": "index.html#example",
    "title": "A Grammar of Graphics for Python",
    "section": "Example",
    "text": "Example\n\nfrom plotnine import ggplot, geom_point, aes, stat_smooth, facet_wrap\nfrom plotnine.data import mtcars\n\n(ggplot(mtcars, aes(\"wt\", \"mpg\", color=\"factor(gear)\"))\n    + geom_point()\n    + stat_smooth(method=\"lm\")\n    + facet_wrap(\"~gear\"))\n\n/opt/hostedtoolcache/Python/3.11.6/x64/lib/python3.11/site-packages/plotnine/utils.py:326: FutureWarning: is_categorical_dtype is deprecated and will be removed in a future version. Use isinstance(dtype, CategoricalDtype) instead\n/opt/hostedtoolcache/Python/3.11.6/x64/lib/python3.11/site-packages/plotnine/utils.py:326: FutureWarning: is_categorical_dtype is deprecated and will be removed in a future version. Use isinstance(dtype, CategoricalDtype) instead\n/opt/hostedtoolcache/Python/3.11.6/x64/lib/python3.11/site-packages/plotnine/utils.py:1221: FutureWarning: is_categorical_dtype is deprecated and will be removed in a future version. Use isinstance(dtype, CategoricalDtype) instead\n/opt/hostedtoolcache/Python/3.11.6/x64/lib/python3.11/site-packages/plotnine/utils.py:326: FutureWarning: is_categorical_dtype is deprecated and will be removed in a future version. Use isinstance(dtype, CategoricalDtype) instead\n/opt/hostedtoolcache/Python/3.11.6/x64/lib/python3.11/site-packages/plotnine/utils.py:326: FutureWarning: is_categorical_dtype is deprecated and will be removed in a future version. Use isinstance(dtype, CategoricalDtype) instead\n/opt/hostedtoolcache/Python/3.11.6/x64/lib/python3.11/site-packages/plotnine/utils.py:633: FutureWarning: The default of observed=False is deprecated and will be changed to True in a future version of pandas. Pass observed=False to retain current behavior or observed=True to adopt the future default and silence this warning.\n/opt/hostedtoolcache/Python/3.11.6/x64/lib/python3.11/site-packages/plotnine/utils.py:633: FutureWarning: The default of observed=False is deprecated and will be changed to True in a future version of pandas. Pass observed=False to retain current behavior or observed=True to adopt the future default and silence this warning.\n/opt/hostedtoolcache/Python/3.11.6/x64/lib/python3.11/site-packages/mizani/scale.py:256: FutureWarning: is_categorical_dtype is deprecated and will be removed in a future version. Use isinstance(dtype, CategoricalDtype) instead\n/opt/hostedtoolcache/Python/3.11.6/x64/lib/python3.11/site-packages/mizani/scale.py:256: FutureWarning: is_categorical_dtype is deprecated and will be removed in a future version. Use isinstance(dtype, CategoricalDtype) instead\n/opt/hostedtoolcache/Python/3.11.6/x64/lib/python3.11/site-packages/plotnine/geoms/geom.py:289: FutureWarning: The default of observed=False is deprecated and will be changed to True in a future version of pandas. Pass observed=False to retain current behavior or observed=True to adopt the future default and silence this warning.\n/opt/hostedtoolcache/Python/3.11.6/x64/lib/python3.11/site-packages/plotnine/geoms/geom.py:289: FutureWarning: The default of observed=False is deprecated and will be changed to True in a future version of pandas. Pass observed=False to retain current behavior or observed=True to adopt the future default and silence this warning."
  },
  {
    "objectID": "index.html#documentation",
    "href": "index.html#documentation",
    "title": "A Grammar of Graphics for Python",
    "section": "Documentation",
    "text": "Documentation\n\nAPI Reference\nInstallation (TODO)\nGallery\nChangelog (TODO)\nAbout plotnine\nTutorials\nGlossary (TODO)\nExternal Resources external-resources"
  }
]